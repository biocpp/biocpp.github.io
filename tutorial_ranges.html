<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: Ranges</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BioC++
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tutorial_ranges.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Ranges </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md35">Motivation</a></li>
<li class="level1"><a href="#autotoc_md36">Ranges</a><ul><li class="level2"><a href="#autotoc_md37">Range concepts</a></li>
<li class="level2"><a href="#autotoc_md38">Storage behaviour</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md39">Views</a><ul><li class="level2"><a href="#autotoc_md40">Lazy-evaluation</a></li>
<li class="level2"><a href="#autotoc_md41">Combinability</a></li>
<li class="level2"><a href="#autotoc_md42">View concepts</a></li>
<li class="level2"><a href="#autotoc_md43">Views in the standard library and in SeqAn</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md44">Containers</a><ul><li class="level2"><a href="#autotoc_md45">The bitcompressed vector</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_hannes_devel_bio_core_doc_biocpp_core_tutorial_ranges_index"></a></p>
<p>This tutorial introduces the notion of <em>ranges</em>, a C++20 feature that SeqAn3 makes strong use of.</p>
<table class="doxtable">
<tr>
<th>Difficulty</th><td>Moderate</td></tr>
<tr>
<th>Duration</th><td>90 min</td></tr>
<tr>
<th>Prerequisite tutorials</th><td><a class="el" href="tutorial_concepts.html">C++ Concepts</a></td></tr>
<tr>
<th>Recommended reading</th><td></td></tr>
</table>
<h1><a class="anchor" id="autotoc_md35"></a>
Motivation</h1>
<p>Traditionally most generic algorithms in the C++ standard library, like std::sort, take a pair of iterators (e.g. the object returned by <code>begin()</code>). If you want to sort a <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> <code>v</code>, you have to call <code>std::sort(v.begin(), v.end())</code> and not <code>std::sort(v)</code>. Why was this design with iterators chosen? It is more flexible, because it allows e.g.:</p><ul>
<li>sorting only all elements after the fifth one: <code>std::sort(v.begin() + 5, v.end())</code></li>
<li>using non-standard iterators like reverse iterators: <code>std::sort(v.rbegin() + 5, v.rend())</code> (sorts in reverse order)</li>
</ul>
<p>But this interface is less intuitive than just calling std::sort on the entity that you wish to sort and it allows for more mistakes, e.g. mixing two incompatible iterators. C++20 introduces the notion of <em>ranges</em> and provides algorithms that accept such in the namespace <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/namespacestd_1_1ranges.html">std::ranges</a>::</code>, e.g. <code>std::ranges::sort(v)</code> now works if <code>v</code> is range â€“ and vectors are ranges!</p>
<p>What about the two examples that suggest superiority of the iterator-based approach? In C++20 you can do the following:</p><ul>
<li>sorting only all elements after the fifth one: <code>std::ranges::sort(std::views::drop(v, 5))</code></li>
<li>sorting in reverse order: <code>std::ranges::sort(std::views::reverse(v))</code></li>
</ul>
<p>We will discuss later what <code>std::views::reverse(v)</code> does, for now it is enough to understand that it returns something that appears like a container and that std::ranges::sort can sort it. Later we will see that this approach offers even more flexibility than working with iterators.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Ranges</h1>
<p><em>Ranges</em> are an abstraction of "a collection of items", or "something iterable". The most basic definition requires only the existence of <code>begin()</code> and <code>end()</code> on the range.</p>
<p>There are different ways to classify ranges, one way is through the capabilities of its iterator.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Range concepts</h2>
<p>Ranges are typically either <a class="el" href="">input ranges </a> (they can be read from) or <a class="el" href="">output ranges </a> (they can be written to) or both. E.g. a <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;int&gt;</code> is both, but a <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;int&gt; const</code> would only be an input range.</p>
<p><a class="el" href="">Input ranges </a> have different <em>strengths</em> that are realised through more refined concepts (i.e. types that model a stronger concept, always also model the weaker one):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::input_range   </td><td class="markdownTableBodyNone">can be iterated from beginning to end <b>at least once</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::forward_range   </td><td class="markdownTableBodyNone">can be iterated from beginning to end <b>multiple times</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::bidirectional_range   </td><td class="markdownTableBodyNone">iterator can also move backwards with <code>--</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::random_access_range   </td><td class="markdownTableBodyNone">you can jump to elements <b>in constant-time</b> <code>[]</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::contiguous_range   </td><td class="markdownTableBodyNone">elements are always stored consecutively in memory   </td></tr>
</table>
<p>For the well-known containers from the standard library this matrix shows which concepts they model:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/forward_list.html">std::forward_list</a>   </th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/list.html">std::list</a>   </th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>   </th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/array.html">std::array</a>   </th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::input_range   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::forward_range   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::bidirectional_range   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::random_access_range   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::contiguous_range   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">âœ…   </td><td class="markdownTableBodyCenter">âœ…   </td></tr>
</table>
<p>There are also range concepts that are independent of input or output or one of the above concept, e.g. std::ranges::sized_range which requires that the size of a range can be computed and in constant time.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Storage behaviour</h2>
<p><b>Containers</b> are the ranges most well known, they own their elements. SeqAn3 makes use of standard STL containers like <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code>, but also implements some custom containers.</p>
<p><b>Decorators</b> are ranges that are always defined on another range and decorate/annotate the underlying range with additional information. They do not own the underlying range, but can contain member data of their own.</p>
<p><b>Views</b> are ranges that are usually defined on another range and transform the underlying range via some algorithm or operation. Views do not own any data beyond their algorithm and the time it takes to construct, destruct or copy them should not depend on the number of elements they represent. The algorithm is required to be lazy-evaluated so it is feasible to combine multiple views. More on this below.</p>
<p>If you are confused about <em>decorators</em> vs <em>views</em>, think of decorators as "underlying range + data" and views as "underlying range + algorithm".</p>
<p>The storage behaviour is orthogonal to the range concepts defined by the iterators mentioned above, i.e. you can have a container that satisfies std::ranges::random_access_range (e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> does, but <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/list.html">std::list</a></code> does not) and you can have views or decorators that do so or don't. For some combinations of iterator capabilities and storage behaviour there are extra concept definitions, e.g. <a class="el" href="interfacebio_1_1random__access__container.html" title="A more refined container concept than bio::sequence_container.">bio::random_access_container</a>.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Views</h1>
<p>As mentioned above, views are a specific kind of range. They are incredibly useful and you will find them throughout the library.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Lazy-evaluation</h2>
<p>A key feature of views is that whatever transformation they apply, they do so at the moment you request an element, not when the view is created.</p>
<div class="fragment"></div><!-- fragment --><p> Here <code>v</code> is a view; creating it neither changes <code>vec</code>, nor does <code>v</code> store any elements. The time it takes to construct <code>v</code> and its size in memory is independent of the size of <code>vec</code>.</p>
<div class="fragment"></div><!-- fragment --><p> This will print "6", but the important thing is that resolving the first element of <code>v</code> to the last element of <code>vec</code> happens <b>on-demand</b>. This guarantees that views can be used as flexibly as iterators, but it also means that if the view performs an expensive transformation, it will have to do so repeatedly if the same element is requested multiple times.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
Combinability</h2>
<p>You may have wondered why we wrote</p>
<div class="fragment"></div><!-- fragment --><p> and not </p><div class="fragment"><div class="line">std::views::reverse v{vec};</div>
</div><!-- fragment --><p>That's because <code>std::views::reverse</code> is not the view itself, it's an <em>adaptor</em> that takes the underlying range (in our case the vector) and returns a view object over the vector. The exact type of this view is hidden behind the <code>auto</code> statement. This has the advantage, that we don't need to worry about the template arguments of the view type, but more importantly the adaptor has an additional feature: it can be <em>chained</em> with other adaptors!</p>
<div class="fragment"></div><!-- fragment --><p> What will this print?  <div class="assignment"> <details><summary><b>Hint</b></summary>  It will print "4".  </details> </div> </p>
<p>In the above example the vector is "piped" (similar to the unix command line) into the reverse adaptor and then into the drop adaptor and a combined view object is returned. Note that accessing the 0th element of the view is still lazy, determining which element it maps to happens at the time of access.</p>
<p> <div class="assignemnt"><h4>Assignment 1: Fun with views I</h4><div class="assignment_content"> Look up the documentation of std::views::transform and std::views::filter. Both take a invocable object as parameter, e.g. a lambda function. std::views::transform applies the lambda on each element in the underlying range and std::views::filter filter "removes" those elements that its lambda function evaluates to false for.</p>
<p>What does this imply for argument types and return types of the lambda functions?</p>
<p> <div class="assignment"> <details><summary><b>Hint</b></summary>  The transform's lambda should return something of the same type as the input and the filter's lambda should return true or false!  </details> </div> </p>
<p>Task: Create a view on <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</code> that filters out all uneven numbers and squares the remaining (even) values, i.e. </p><div class="fragment"><div class="line"><a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</div>
<div class="line"><span class="keyword">auto</span> v = vec | <span class="comment">// ...?</span></div>
<div class="line"> </div>
<div class="line"><a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; *v.begin() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// should print 4</span></div>
<div class="ttc" id="acout_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a></div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><p>  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"></div><!-- fragment --><p>  </details> </div> </p>
<h2><a class="anchor" id="autotoc_md42"></a>
View concepts</h2>
<p>Views are a specific kind of range that is formalised in the std::ranges::view concept. Every view returned by a view adaptor models this concept, but which other range concepts are modeled by a view?</p>
<p>It depends on the underlying range and also the view itself. With few exceptions, views don't model more/stronger range concepts than their underlying range (other than std::ranges::view) and they try to preserve as much of the underlying range's concepts as possible. For instance the view returned by <code>std::views::reverse</code> models std::ranges::random_access_range (and weaker concepts) iff the underlying range also models the respective concept. It never models std::ranges::contiguous_range, because the third element of the view is not located immediately after the second in memory (but instead before the second).</p>
<p>Perhaps surprising to some, many views also model std::ranges::output_range if the underlying range does, i.e. <b>views are not read-only</b>:</p>
<div class="fragment"></div><!-- fragment --><p>  <div class="assignemnt"><h4>Assignment 2: Fun with views II</h4><div class="assignment_content"> Have a look at the solution to the previous assignment (filter+transform). Which of the following concepts do you think <code>v</code> models?</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept   </th><th class="markdownTableHeadCenter">yes/no?    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::input_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::forward_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::bidirectional_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::random_access_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::contiguous_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::view   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::sized_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::output_range   </td><td class="markdownTableBodyCenter"></td></tr>
</table>
<p> </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary> </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept   </th><th class="markdownTableHeadCenter">yes/no?    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::input_range   </td><td class="markdownTableBodyCenter">âœ…    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::forward_range   </td><td class="markdownTableBodyCenter">âœ…    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::bidirectional_range   </td><td class="markdownTableBodyCenter">âœ…    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::random_access_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::contiguous_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::view   </td><td class="markdownTableBodyCenter">âœ…    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::sized_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::output_range   </td><td class="markdownTableBodyCenter"></td></tr>
</table>
<p>Surprised? Let's have a closer look at the std::views::filter view. The filter view only returns the value of the underlying range for which the given predicate evaluates to <code>true</code>. To know which value is an element of the filter view, the view has to look at each of them. Thus, it must scan the underlying range value-by-value and cannot jump to an arbitrary location in constant time since it cannot know how many elements it had to skip without looking at them. Accordingly, the std::views::filter preserves only std::ranges::bidirectional_range, because it can scan the text in reverse order as well. Since the view cannot guarantee that the values lie in contiguous memory, it can also not preserve std::ranges::contiguous_range. Similarly, the view cannot model std::ranges::sized_range as it cannot determine the number of values not filtered out in constant time.</p>
<p>The transform on the other hand produces a new element on every access (the result of the multiplication), therefore <code>v</code> is not a std::ranges::output_range, you cannot assign values to its elements. Note that this prevents modelling the std::ranges::contiguous_range as well because values are created on-demand and are not stored in memory at all.  </details> </div> </p>
<p>We provide overview tables for all our view adaptors that document which concepts are modelled by the views they return.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Views in the standard library and in SeqAn</h2>
<p>The standard library in C++20 provides a number of useful views and SeqAn provides many views, as well. Most views provided by SeqAn3 are specific to biological operations, like <a class="el" href="group__views.html#gab2e512ec0d0fe1967dfd7aee03c74eae" title="A view that does quality-threshold trimming on a range of bio::quality_alphabet.">bio::views::trim_quality</a> which trims sequences based on the quality or <a class="el" href="group__views.html#ga531cd11552ed966a1d8a63611d0b280b" title="A view that converts a range of nucleotides to their complement.">bio::views::complement</a> which generates the complement of a nucleotide sequence. But SeqAn3 also provides some general purpose views.</p>
<p>Have a look at the <a class="el" href="group__views.html">views-submodule </a> to get an overview of SeqAn's views and also read through the detailed description on that page now that you had a more gentle introduction.</p>
<p> <div class="assignemnt"><h4>Assignment 3: Fun with views III</h4><div class="assignment_content"> Create a small program that</p><ol type="1">
<li>reads a string from the command line (first argument to the program)</li>
<li>"converts" the string to a range of <a class="el" href="classbio_1_1dna5.html" title="The five letter DNA alphabet of A,C,G,T and the unknown character N.">bio::dna5</a> (Bonus: throw an exception if loss of information occurs)</li>
<li>prints the string and it's reverse complement</li>
<li>prints the six-frame translation of the string</li>
</ol>
<p>Use views to implement steps 2.-4.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"></div><!-- fragment --><p>  </details> </div> </p>
<h1><a class="anchor" id="autotoc_md44"></a>
Containers</h1>
<p>containers are ranges that own their data. SeqAn3 uses the standard library containers, like <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> and <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/list.html">std::list</a> to store elements. For certain use-cases we have introduced our own containers, though.</p>
<p>All standard library containers model std::ranges::forward_range (see above), but we have introduced container concepts that encompass more of a containers interface. Have a look at the API documentation of <a class="el" href="interfacebio_1_1container.html" title="The (most general) container concept as defined by the standard library.">bio::container</a> and unfold the inheritance diagram. What can you learn about the different refinements and their relation to the range concepts?</p>
<h2><a class="anchor" id="autotoc_md45"></a>
The bitcompressed vector</h2>
<p>If you followed the alphabet tutorial closely, you will know that <a class="el" href="classbio_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T.">bio::dna4</a> needs only two bits to represent its state. However, single objects are always at least a byte (eight bits) big in C++. To store sequences of small alphabets more space-efficiently, we have developed <a class="el" href="classbio_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bio::bitcompressed_vector</a>.</p>
<p>Open the API documentation of <a class="el" href="classbio_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bio::bitcompressed_vector</a>, display the inheritance diagram and read through the interface overview and the detailed description.</p>
<p> <div class="assignemnt"><h4>Assignment 4: The bitcompressed vector</h4><div class="assignment_content"> Create a small program that asks the user for a size and then creates a vector of <a class="el" href="classbio_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T.">bio::dna4</a> of that size. Add an argument parser flag that allows the user to decide whether <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> or <a class="el" href="classbio_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bio::bitcompressed_vector</a> is used. After creating the vector, print its size.</p>
<p>Measure and compare the amount of main memory that your program uses depending on the vector implementation. On Linux based systems use <code>/usr/bin/time -v &lt;program&gt; &lt;args&gt;</code> and look for "Maximum resident set size". (Not to be confused with the built-in Bash time command! So use the full path <code>/usr/bin/time</code>)</p>
<p>On macOS and BSD use <code>/usr/bin/time -l &lt;program&gt; &lt;args&gt;</code> and look for "maximum resident set size".</p>
<dl class="section note"><dt>Note</dt><dd>This command diplays the peak memory usage and only gives you a first impression. You can use <a href="https://valgrind.org/docs/manual/ms-manual.html">valgrind</a> if you want to have a more detailed analysis of your memory consumption.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  <div class="fragment"></div><!-- fragment -->  </details> </div>  </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Thu Jun 9 2022 19:02:37 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
