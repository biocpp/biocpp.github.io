<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: C++ Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BioC++
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('core_concepts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md34">Constraints</a><ul><li class="level2"><a href="#autotoc_md35">Motivation</a></li>
<li class="level2"><a href="#autotoc_md36">Syntax variants</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md37">Terminology</a></li>
<li class="level1"><a href="#autotoc_md38">Overloading and specialisation</a><ul><li class="level2"><a href="#autotoc_md39">Function (template) overloading</a></li>
<li class="level2"><a href="#autotoc_md40">Partial template specialisation</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md41">Concepts in BioC++ and this documentation</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_hannes_devel_bio_core_doc_core_tutorial_concepts_index"></a></p>
<p>This tutorial introduces "C++ Concepts", a feature of C++20 (and available to some extent in older GCC versions). You will learn the terminology used in the context of concepts and how to use BioC++'s concepts in your application.</p>
<table class="doxtable">
<tr>
<th>Difficulty</th><td>Moderate</td></tr>
<tr>
<th>Duration</th><td>60 min</td></tr>
<tr>
<th>Prerequisite tutorials</th><td><a class="el" href="core_setup.html">Quick Setup (using CMake)</a></td></tr>
<tr>
<th>Recommended reading</th><td></td></tr>
</table>
<p>This tutorial teaches the very basics of working with concepts. For more background and information on how to implement your own concepts, we recommend:</p><ul>
<li>A well-readable <a href="https://www.stroustrup.com/good_concepts.pdf">paper</a> with motivation and historical background.</li>
<li>The (rather dense) <a href="https://en.cppreference.com/w/cpp/language/constraints">documentation on cppreference</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md34"></a>
Constraints</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
Motivation</h2>
<p>One central design goal of BioC++ is to provide generic algorithms and data structures which can be used for different types without reimplementing the same algorithms over and over again for particular types. This has multiple benefits: improved maintainability due to an additional level of abstraction and more importantly the ability to reuse the code with user provided types. A familiar example for generic code is <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> and the algorithms in the standard library. They are <em>templates</em> which means that they can be <em>instantiated</em> with other types. Most often the type cannot be arbitrary, because the template expects a particular interface from the type.</p>
<p>A BioC++ example is the local alignment algorithm. It computes the best local match between two sequences over a finite alphabet. The algorithm is generic in so far that it allows any alphabet that offers the minimal interface which is used inside the algorithm (e.g. objects of the alphabet type must be equality comparable). Before C++20, this could not be checked easily and using the interface with non-conforming types would result in very hard to read compiler errors and consequently frustration of the user. In the following part of the tutorial you will learn how to <em>constrain</em> such template arguments of generic functions and data structures and how this can have a huge impact on your code.</p>
<p>Here's a shorter example:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> t&gt;</div>
<div class="line">t add(t <span class="keyword">const</span> v1, t <span class="keyword">const</span> v2)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> v1 + v2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> add(1, 3); <span class="comment">// instantiates add&lt;int&gt;()</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The template parameter <code>t</code> is said to be <em>unconstrained</em>, in theory it can be instantiated with any type. But of course it won't actually compile for all types, because the function template <b>implicitly requires</b> that types provide a <code>+</code> operator. If a type is used that does not have a <code>+</code> operator, this implicitness causes the compiler to fail at the place where such operator is used â€“ and not at the place the template is instantiated. This leads to very complex error messages for deeply nested code.</p>
<p><em>Constraints</em> are a way of making requirements of template arguments <b>explicit</b>. Constraints can be formulated ad-hoc, but this tutorial only covers <em>concepts</em>. The interested reader can check the <a href="https://en.cppreference.com/w/cpp/language/constraints">documentation</a> to learn about ad-hoc definitions. Concepts are a set of constraints with a given name. Let's assume there is a concept called <code>Addable</code> that requires the existence of a <code>+</code> operator (as previously mentioned the syntax for defining concepts is not covered here). The following snippet demonstrates how we can constrain our function template, i.e. make the template immediately reject any types that don't satisfy the requirement:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;Addable t&gt;</div>
<div class="line">t add(t <span class="keyword">const</span> v1, t <span class="keyword">const</span> v2)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> v1 + v2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> add(1, 3); <span class="comment">// instantiates add&lt;int&gt;()</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The only difference is that we have replaced <code>typename</code> with <code>Addable</code>. If you plug in a type that does not model <code>Addable</code>, you will get a message stating exactly that and not a cryptic template backtrace.</p>
<p>The standard library provides a set of <a href="https://en.cppreference.com/w/cpp/concepts">predefined concepts</a>. For our example above, the std::integral concept could have been used.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Syntax variants</h2>
<p>Depending on the complexity of your constraint statements, three different syntaxes are available to enforce constraints; all of the following are equivalent.</p>
<p>(1) The "verbose syntax", especially useful when enforcing multiple constraints:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> t1, <span class="keyword">typename</span> t2&gt;</div>
<div class="line">    requires std::integral&lt;t1&gt; &amp;&amp; std::integral&lt;t2&gt; <span class="comment">// &amp;&amp; MyOtherConcept&lt;t1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> add(t1 <span class="keyword">const</span> v1, t2 <span class="keyword">const</span> v2)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> v1 + v2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>(2) The "intermediate syntax": </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">int</span>egral t1, std::<span class="keywordtype">int</span>egral t2&gt;                       <span class="comment">// one constraint per type</span></div>
<div class="line"><span class="keyword">auto</span> add(t1 <span class="keyword">const</span> v1, t2 <span class="keyword">const</span> v2)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> v1 + v2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>(3) The "terse syntax": </p><div class="fragment"><div class="line"><span class="keyword">auto</span> add(std::integral <span class="keyword">auto</span> <span class="keyword">const</span> v1, std::integral <span class="keyword">auto</span> <span class="keyword">const</span> v2)  <span class="comment">// one constraint per type</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> v1 + v2;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>The terse syntax in this form is not yet available in GCC7, GCC8 and GCC9.</dd></dl>
<p>Different constraints can be applied to different template parameters and a single template parameter can be constrained by multiple concepts. Syntaxes can also be combined: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">int</span>egral t1, std::<span class="keywordtype">int</span>egral t2&gt;</div>
<div class="line">    <span class="comment">// requires MyOtherConcept&lt;t1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> add(t1 <span class="keyword">const</span> v1, t2 <span class="keyword">const</span> v2)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> v1 + v2;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
Terminology</h1>
<ul>
<li>Template arguments can be <em><b>constrained</b></em>.</li>
<li>A named set of constraints is a <em><b>concept</b></em>.</li>
<li>A type that satisfies all requirements of a concept is said to <em><b>model</b></em> said concept.</li>
<li>A <em>concept</em> that is composed of another concept and additional constraints is said to <em><b>refine</b></em> said concept(s).</li>
</ul>
<p>Some people confuse concepts with <em>interfaces</em>. Both can be used as an abstraction of concrete types, but interfaces have to be inherited from. â†’ the abstraction is explicit in the definition of the type. Concepts on the other hand "describe properties from the outside". â†’ types don't need to be related and don't need to "know about the concept" to model it.</p>
<p>Furthermore, the polymorphism possible with concepts (see below) is faster, because it is resolved at compile-time while interface inheritance is resolved at run-time.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Overloading and specialisation</h1>
<p>In generic programming, "function overloading" and "template specialisation" play an important role. They allow providing generic interfaces and (gradually) more specialised implementations for specific types or groups of types.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Function (template) overloading</h2>
<p>When a function is overloaded and multiple overloads are valid for a given/deduced template argument, the <em>most-refined</em> overload is chosen:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/concepts.html">concepts</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">int</span>egral t&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(t <span class="keyword">const</span> v)</div>
<div class="line">{</div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;integral value: &quot;</span> &lt;&lt; v &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i{4};</div>
<div class="line">    <span class="keywordtype">unsigned</span> u{3};</div>
<div class="line"> </div>
<div class="line">    print(i);                       <span class="comment">// prints &quot;integral value: 4&quot;</span></div>
<div class="line">    print(u);                       <span class="comment">// prints &quot;integral value: 3&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="aconcepts_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/concepts.html">concepts</a></div></div>
<div class="ttc" id="acout_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a></div></div>
<div class="ttc" id="aiostream_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a></div></div>
</div><!-- fragment --><p>But as soon as we introduce another overload, the compiler will pick the "best" match:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/concepts.html">concepts</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">int</span>egral t&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(t <span class="keyword">const</span> v)</div>
<div class="line">{</div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;integral value: &quot;</span> &lt;&lt; v &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">unsigned</span>_<span class="keywordtype">int</span>egral t&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(t <span class="keyword">const</span> v)</div>
<div class="line">{</div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Unsigned value: &quot;</span> &lt;&lt; v &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i{4};</div>
<div class="line">    <span class="keywordtype">unsigned</span> u{3};</div>
<div class="line"> </div>
<div class="line">    print(i);                       <span class="comment">// prints &quot;integral value: 4&quot;</span></div>
<div class="line">    print(u);                       <span class="comment">// prints &quot;Unsigned value: 3&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> <div class="assignemnt"><h4>Assignment 1: Static polymorphism with alphabets I</h4><div class="assignment_content"> Write a small program, similar to the one above with the following "skeleton": </p><div class="fragment"><div class="line"><span class="comment">// which includes?</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_dna5;</div>
<div class="line"><span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_aa27;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add one or more `void print` function template(s) here //</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> d = <span class="charliteral">&#39;A&#39;</span>_dna5;</div>
<div class="line">    <span class="keyword">auto</span> a = <span class="charliteral">&#39;L&#39;</span>_aa27;</div>
<div class="line">    <span class="keyword">auto</span> g = <a class="code" href="classbio_1_1gap.html">bio::gap</a>{};</div>
<div class="line"> </div>
<div class="line">    print(d);</div>
<div class="line">    print(a);</div>
<div class="line">    print(g);</div>
<div class="line">}</div>
<div class="ttc" id="aclassbio_1_1gap_html"><div class="ttname"><a href="classbio_1_1gap.html">bio::gap</a></div><div class="ttdoc">The alphabet of a gap character '-'.</div><div class="ttdef"><b>Definition:</b> gap.hpp:38</div></div>
</div><!-- fragment --><p>The <code>print</code> function (template) should print for every object <code>v</code> passed to it the result of <code>to_char(v)</code> and it should be constrained to only accepts types that model <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>. Try calling <code>print</code> with a different type, e.g. <code>int</code> to make sure that it does.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span>                     <span class="comment">// for std::cout</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2all_8hpp.html">bio/alphabet/all.hpp</a>&gt;</span>      <span class="comment">// include all alphabet headers</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;bio::alphabet t&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(t <span class="keyword">const</span> v)</div>
<div class="line">{</div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;I am an alphabet and my value as char is: &quot;</span> &lt;&lt; <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(v) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_dna5;</div>
<div class="line"><span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_aa27;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> d = <span class="charliteral">&#39;A&#39;</span>_dna5;</div>
<div class="line">    <span class="keyword">auto</span> a = <span class="charliteral">&#39;L&#39;</span>_aa27;</div>
<div class="line">    <span class="keyword">auto</span> g = <a class="code" href="classbio_1_1gap.html">bio::gap</a>{};</div>
<div class="line"> </div>
<div class="line">    print(d);</div>
<div class="line">    print(a);</div>
<div class="line">    print(g);</div>
<div class="line">}</div>
<div class="ttc" id="aalphabet_2all_8hpp_html"><div class="ttname"><a href="alphabet_2all_8hpp.html">all.hpp</a></div><div class="ttdoc">Meta-header for the alphabet module.</div></div>
<div class="ttc" id="agroup__alphabet_html_gab295f04aea840000aafc640b5e6528c8"><div class="ttname"><a href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a></div><div class="ttdeci">constexpr auto to_char</div><div class="ttdoc">Return the char representation of an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:322</div></div>
</div><!-- fragment --><p>  </details> </div> </p>
<p> <div class="assignemnt"><h4>Assignment 2: Static polymorphism with alphabets II</h4><div class="assignment_content"> Adapt your previous solution to handle nucleotides differently from the rest. For nucleotides, it should print both the value and its complement.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span>                     <span class="comment">// for std::cout</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2all_8hpp.html">bio/alphabet/all.hpp</a>&gt;</span>      <span class="comment">// include all alphabet headers</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;bio::alphabet t&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(t <span class="keyword">const</span> v)</div>
<div class="line">{</div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;I am an alphabet and my value as char is: &quot;</span> &lt;&lt; <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(v) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;bio::nucleot<span class="keywordtype">id</span>e_alphabet t&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(t <span class="keyword">const</span> v)</div>
<div class="line">{</div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;I am a nucleotide, my value as char is: &quot;</span> &lt;&lt; <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(v)</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; and my complement is: &quot;</span> &lt;&lt; <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(<a class="code" href="group__nucleotide.html#ga4b00de5b7d39cf416e62e14edef83f03">bio::complement</a>(v)) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_dna5;</div>
<div class="line"><span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_aa27;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> d = <span class="charliteral">&#39;A&#39;</span>_dna5;</div>
<div class="line">    <span class="keyword">auto</span> a = <span class="charliteral">&#39;L&#39;</span>_aa27;</div>
<div class="line">    <span class="keyword">auto</span> g = <a class="code" href="classbio_1_1gap.html">bio::gap</a>{};</div>
<div class="line"> </div>
<div class="line">    print(d);</div>
<div class="line">    print(a);</div>
<div class="line">    print(g);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__nucleotide_html_ga4b00de5b7d39cf416e62e14edef83f03"><div class="ttname"><a href="group__nucleotide.html#ga4b00de5b7d39cf416e62e14edef83f03">bio::complement</a></div><div class="ttdeci">constexpr auto complement</div><div class="ttdoc">Return the complement of a nucleotide object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:96</div></div>
</div><!-- fragment --><p>  </details> </div> </p>
<h2><a class="anchor" id="autotoc_md40"></a>
Partial template specialisation</h2>
<p>Similar to function template overloading it is possible to use concepts for partially specialising class and variable templates.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/concepts.html">concepts</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/utility.html">utility</a>&gt;</span>                          <span class="comment">// for std::pair</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> t&gt;</div>
<div class="line"><span class="keyword">struct </span>square_root_type;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">int</span>egral t&gt;</div>
<div class="line"><span class="keyword">struct </span>square_root_type&lt;t&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> type = <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;float, float&gt;</a>;   <span class="comment">// real and imaginary part</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">unsigned</span>_<span class="keywordtype">int</span>egral t&gt;</div>
<div class="line"><span class="keyword">struct </span>square_root_type&lt;t&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> type = float;                     <span class="comment">// doesn&#39;t need imaginary part</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `int` models std::integral but not std::unsigned_integral:</span></div>
<div class="line">static_assert(std::same_as&lt;<span class="keyword">typename</span> square_root_type&lt;int&gt;::type,           <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;float, float&gt;</a>&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `unsigned` models std::integral and std::unsigned_integral, but the latter is more refined:</span></div>
<div class="line">static_assert(std::same_as&lt;<span class="keyword">typename</span> square_root_type&lt;unsigned&gt;::type,      <span class="keywordtype">float</span>&gt;);</div>
<div class="ttc" id="apair_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></div></div>
<div class="ttc" id="autility_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/utility.html">utility</a></div></div>
</div><!-- fragment --><p>This is a typical example of a "type transformation trait". It maps one type to another type; in this case it returns a type that is able to represent the square root of the<br  />
"input type". This can be used in generic algorithms to hold data in different types depending on the type of the input â€“ in this case we could avoid half of the space consumption for unsigned integral types VS signed integral types.</p>
<dl class="section note"><dt>Note</dt><dd>The std::same_as used above is a concept with two template parameters. It requires that both parameters are the same. The <code>static_assert</code> checks conditions at compile-time; it can be used to verify whether a type or a combination of types model a concept. In the above case we can use the combination to check the "return type" of the transformation trait.</dd></dl>
<h1><a class="anchor" id="autotoc_md41"></a>
Concepts in BioC++ and this documentation</h1>
<p>BioC++ uses concepts extensively, for specialisation/overloading, but also to prevent misuse of templates and to clearly specify all public interfaces. We prefer the intermediate syntax and additionally use the verbose expressions if necessary. Unfortunately, doxygen, the system used to generate this documentation, does not handle C++ concepts very well, yet. In some parts of the documentation concepts are called "interfaces", please don't let this confuse you. And the "verbose syntax" introduced above is not visible at all in the automatically generated documentation. That's why it's important to read the detailed documentation section where all requirements are documented.</p>
<p>Have a look at the documentation of bio::argument_parser::add_positional_option(). It has two template parameters, one seems unconstrained (<code>typename</code> in the signature) and one is constrained (<code>validator</code> in the signature). But in fact both are constrained as the detailed documentation reveals.</p>
<p>Now, follow the link to bio::validator. We will check in the next section whether you understand the documentation for the concept. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Sun Jun 12 2022 17:23:28 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
