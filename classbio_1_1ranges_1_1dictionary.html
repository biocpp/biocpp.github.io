<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: bio::ranges::dictionary&lt; key_t, mapped_t, mapped_t_is_context_aware &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">BioC++<span id="projectnumber">&#160;core-0.7.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classbio_1_1ranges_1_1dictionary.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classbio_1_1ranges_1_1dictionary-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bio::ranges::dictionary&lt; key_t, mapped_t, mapped_t_is_context_aware &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__range.html">Ranges</a> &raquo; <a class="el" href="group__container.html">Container</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>An associative container with contiguous, predictable storage.  
 <a href="classbio_1_1ranges_1_1dictionary.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dictionary_8hpp_source.html">bio/ranges/container/dictionary.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for bio::ranges::dictionary&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classbio_1_1ranges_1_1dictionary__inherit__graph.svg" width="430" height="279"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Associated types</div></td></tr>
<tr class="memitem:ad2c1d6c9fa6b708902feb3b832d8283c"><td class="memItemLeft" align="right" valign="top"><a id="ad2c1d6c9fa6b708902feb3b832d8283c" name="ad2c1d6c9fa6b708902feb3b832d8283c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_ref_t</b> = <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/conditional.html">std::conditional_t</a>&lt; mapped_t_is_context_aware, mapped_t const &amp;, mapped_t &amp; &gt;</td></tr>
<tr class="memdesc:ad2c1d6c9fa6b708902feb3b832d8283c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usually <code>mapped_t &amp;</code>. <br /></td></tr>
<tr class="separator:ad2c1d6c9fa6b708902feb3b832d8283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8507b5056de3944f9c765f9868622d67"><td class="memItemLeft" align="right" valign="top"><a id="a8507b5056de3944f9c765f9868622d67" name="a8507b5056de3944f9c765f9868622d67"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; key_t, mapped_t &gt;</td></tr>
<tr class="memdesc:a8507b5056de3944f9c765f9868622d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value_type type. <br /></td></tr>
<tr class="separator:a8507b5056de3944f9c765f9868622d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e76e09ed0c84063f079249f4cbadeb5"><td class="memItemLeft" align="right" valign="top"><a id="a8e76e09ed0c84063f079249f4cbadeb5" name="a8e76e09ed0c84063f079249f4cbadeb5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; key_t const &amp;, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad2c1d6c9fa6b708902feb3b832d8283c">mapped_ref_t</a> &gt;</td></tr>
<tr class="memdesc:a8e76e09ed0c84063f079249f4cbadeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference type. <br /></td></tr>
<tr class="separator:a8e76e09ed0c84063f079249f4cbadeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c7944c8d741706cab4430820d62848"><td class="memItemLeft" align="right" valign="top"><a id="a71c7944c8d741706cab4430820d62848" name="a71c7944c8d741706cab4430820d62848"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; key_t const &amp;, mapped_t const &amp; &gt;</td></tr>
<tr class="memdesc:a71c7944c8d741706cab4430820d62848"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const_reference type. <br /></td></tr>
<tr class="separator:a71c7944c8d741706cab4430820d62848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f587644f4640b4c8417e5644730e9a5"><td class="memItemLeft" align="right" valign="top"><a id="a9f587644f4640b4c8417e5644730e9a5" name="a9f587644f4640b4c8417e5644730e9a5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = ptrdiff_t</td></tr>
<tr class="memdesc:a9f587644f4640b4c8417e5644730e9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference_type type. <br /></td></tr>
<tr class="separator:a9f587644f4640b4c8417e5644730e9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13b36964d579d6258a2699003787047"><td class="memItemLeft" align="right" valign="top"><a id="ad13b36964d579d6258a2699003787047" name="ad13b36964d579d6258a2699003787047"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = size_t</td></tr>
<tr class="memdesc:ad13b36964d579d6258a2699003787047"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size_type type. <br /></td></tr>
<tr class="separator:ad13b36964d579d6258a2699003787047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc155122dfef685f0ca4eab6e017773"><td class="memItemLeft" align="right" valign="top"><a id="a2dc155122dfef685f0ca4eab6e017773" name="a2dc155122dfef685f0ca4eab6e017773"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = detail::random_access_iterator&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const  &gt;</td></tr>
<tr class="memdesc:a2dc155122dfef685f0ca4eab6e017773"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const_iterator type. <br /></td></tr>
<tr class="separator:a2dc155122dfef685f0ca4eab6e017773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd748291518c0cc53ba6e3091b9918f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> = <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/conditional.html">std::conditional_t</a>&lt; mapped_t_is_context_aware, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>, detail::random_access_iterator&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> &gt; &gt;</td></tr>
<tr class="separator:abfd748291518c0cc53ba6e3091b9918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor and assignment</div></td></tr>
<tr class="memitem:a8f0e24f002895e57e0d60e0a00050036"><td class="memItemLeft" align="right" valign="top"><a id="a8f0e24f002895e57e0d60e0a00050036" name="a8f0e24f002895e57e0d60e0a00050036"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dictionary</b> ()=default</td></tr>
<tr class="memdesc:a8f0e24f002895e57e0d60e0a00050036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:a8f0e24f002895e57e0d60e0a00050036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e83b7d56fee1dd0b6a1248b57b548e"><td class="memItemLeft" align="right" valign="top"><a id="a97e83b7d56fee1dd0b6a1248b57b548e" name="a97e83b7d56fee1dd0b6a1248b57b548e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dictionary</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const &amp;)=default</td></tr>
<tr class="memdesc:a97e83b7d56fee1dd0b6a1248b57b548e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:a97e83b7d56fee1dd0b6a1248b57b548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77af70a3255c125f031b61121e2a4003"><td class="memItemLeft" align="right" valign="top"><a id="a77af70a3255c125f031b61121e2a4003" name="a77af70a3255c125f031b61121e2a4003"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dictionary</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a77af70a3255c125f031b61121e2a4003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:a77af70a3255c125f031b61121e2a4003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5d8e4fb6e910897de7196de5097fb2"><td class="memItemLeft" align="right" valign="top"><a id="a1f5d8e4fb6e910897de7196de5097fb2" name="a1f5d8e4fb6e910897de7196de5097fb2"></a>
<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const &amp;)=default</td></tr>
<tr class="memdesc:a1f5d8e4fb6e910897de7196de5097fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:a1f5d8e4fb6e910897de7196de5097fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7575d7500ee88a4cb661ee972d6cf070"><td class="memItemLeft" align="right" valign="top"><a id="a7575d7500ee88a4cb661ee972d6cf070" name="a7575d7500ee88a4cb661ee972d6cf070"></a>
<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a7575d7500ee88a4cb661ee972d6cf070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:a7575d7500ee88a4cb661ee972d6cf070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420fea22185035d4db02768061500261"><td class="memItemLeft" align="right" valign="top"><a id="a420fea22185035d4db02768061500261" name="a420fea22185035d4db02768061500261"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~dictionary</b> ()=default</td></tr>
<tr class="memdesc:a420fea22185035d4db02768061500261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:a420fea22185035d4db02768061500261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa51eeb2af0b85152dcd5868a40a25a4"><td class="memTemplParams" colspan="2">template&lt;typename... value_type_&gt; <br />
requires ((std::convertible_to&lt;value_type_, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt; &amp;&amp; ...) &amp;&amp; sizeof...(value_type_) &gt; 0)</td></tr>
<tr class="memitem:afa51eeb2af0b85152dcd5868a40a25a4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#afa51eeb2af0b85152dcd5868a40a25a4">dictionary</a> (value_type_ &amp;&amp;... args)</td></tr>
<tr class="memdesc:afa51eeb2af0b85152dcd5868a40a25a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a list of values of value_type.  <br /></td></tr>
<tr class="separator:afa51eeb2af0b85152dcd5868a40a25a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68cbbed5ea28476e31c97f6c875aec8"><td class="memTemplParams" colspan="2">template&lt;meta::different_from&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> &gt; begin_it_type, typename end_it_type &gt; <br />
requires (meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>, begin_it_type&gt; &amp;&amp; std::forward_iterator&lt;begin_it_type&gt; &amp;&amp; std::sentinel_for&lt;end_it_type, begin_it_type&gt; &amp;&amp; std::convertible_to&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iter_t.html">std::iter_reference_t</a>&lt;begin_it_type&gt;, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt;)</td></tr>
<tr class="memitem:ab68cbbed5ea28476e31c97f6c875aec8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ab68cbbed5ea28476e31c97f6c875aec8">dictionary</a> (begin_it_type const begin_it, end_it_type const end_it)</td></tr>
<tr class="memdesc:ab68cbbed5ea28476e31c97f6c875aec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from two iterators.  <br /></td></tr>
<tr class="separator:ab68cbbed5ea28476e31c97f6c875aec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68868009edb46a3db8ca5cc9c3c5a022"><td class="memItemLeft" align="right" valign="top"><a id="a68868009edb46a3db8ca5cc9c3c5a022" name="a68868009edb46a3db8ca5cc9c3c5a022"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dictionary</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> const begin_it, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> const end_it)</td></tr>
<tr class="memdesc:a68868009edb46a3db8ca5cc9c3c5a022"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a68868009edb46a3db8ca5cc9c3c5a022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76a4a7c8cf7b95834540672b6c1755f"><td class="memItemLeft" align="right" valign="top"><a id="ab76a4a7c8cf7b95834540672b6c1755f" name="ab76a4a7c8cf7b95834540672b6c1755f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dictionary</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> const begin_it, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> const end_it)</td></tr>
<tr class="memdesc:ab76a4a7c8cf7b95834540672b6c1755f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ab76a4a7c8cf7b95834540672b6c1755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7038b3d7008de29d6462f96369efe3"><td class="memTemplParams" colspan="2">template&lt;meta::different_from&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> &gt; other_range_t&gt; <br />
requires (std::ranges::input_range&lt;other_range_t&gt;)</td></tr>
<tr class="memitem:a0a7038b3d7008de29d6462f96369efe3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0a7038b3d7008de29d6462f96369efe3">dictionary</a> (other_range_t &amp;&amp;range)</td></tr>
<tr class="memdesc:a0a7038b3d7008de29d6462f96369efe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a different range.  <br /></td></tr>
<tr class="separator:a0a7038b3d7008de29d6462f96369efe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5745c69a2831bba6a7b85dd81cd452"><td class="memTemplParams" colspan="2">template&lt;typename... value_type_&gt; <br />
requires ((meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a>, value_type_&gt; &amp;&amp; ...) &amp;&amp; (meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a>, value_type_&gt; &amp;&amp; ...) &amp;&amp; (meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>, value_type_&gt; &amp;&amp; ...) &amp;&amp; (std::convertible_to&lt;value_type_, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(value_type_) &gt; 0))</td></tr>
<tr class="memitem:aee5745c69a2831bba6a7b85dd81cd452"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#aee5745c69a2831bba6a7b85dd81cd452">assign</a> (value_type_ &amp;&amp;... args)</td></tr>
<tr class="memdesc:aee5745c69a2831bba6a7b85dd81cd452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from multiple elements.  <br /></td></tr>
<tr class="separator:aee5745c69a2831bba6a7b85dd81cd452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f5eb20f3433d53d8f7169afdc34011"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range other_range_t&gt; <br />
requires std::convertible_to&lt;std::ranges::range_reference_t&lt;other_range_t&gt;, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt;</td></tr>
<tr class="memitem:a96f5eb20f3433d53d8f7169afdc34011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a96f5eb20f3433d53d8f7169afdc34011">assign</a> (other_range_t &amp;&amp;range)</td></tr>
<tr class="memdesc:a96f5eb20f3433d53d8f7169afdc34011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a different range.  <br /></td></tr>
<tr class="separator:a96f5eb20f3433d53d8f7169afdc34011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396c78c4ade1cd6d6319c19edb9b981d"><td class="memTemplParams" colspan="2">template&lt;meta::different_from&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> &gt; begin_it_type, typename end_it_type &gt; <br />
requires (meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>, begin_it_type&gt; &amp;&amp; std::forward_iterator&lt;begin_it_type&gt; &amp;&amp; std::sentinel_for&lt;end_it_type, begin_it_type&gt; &amp;&amp; std::convertible_to&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iter_t.html">std::iter_reference_t</a>&lt;begin_it_type&gt;, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt;)</td></tr>
<tr class="memitem:a396c78c4ade1cd6d6319c19edb9b981d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a396c78c4ade1cd6d6319c19edb9b981d">assign</a> (begin_it_type begin_it, end_it_type end_it)</td></tr>
<tr class="memdesc:a396c78c4ade1cd6d6319c19edb9b981d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from pair of iterators.  <br /></td></tr>
<tr class="separator:a396c78c4ade1cd6d6319c19edb9b981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bb5046ca688bc223e71e05247d4aeb"><td class="memItemLeft" align="right" valign="top"><a id="a63bb5046ca688bc223e71e05247d4aeb" name="a63bb5046ca688bc223e71e05247d4aeb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> begin_it, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> end_it)</td></tr>
<tr class="memdesc:a63bb5046ca688bc223e71e05247d4aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a63bb5046ca688bc223e71e05247d4aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6474f57330071294f871f9ae900d476"><td class="memItemLeft" align="right" valign="top"><a id="ae6474f57330071294f871f9ae900d476" name="ae6474f57330071294f871f9ae900d476"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> begin_it, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> end_it)</td></tr>
<tr class="memdesc:ae6474f57330071294f871f9ae900d476"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ae6474f57330071294f871f9ae900d476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a120764d978a65d9e173f37d5c4518891"><td class="memItemLeft" align="right" valign="top"><a id="a120764d978a65d9e173f37d5c4518891" name="a120764d978a65d9e173f37d5c4518891"></a>
<a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="memdesc:a120764d978a65d9e173f37d5c4518891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the begin iterator. <br /></td></tr>
<tr class="separator:a120764d978a65d9e173f37d5c4518891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2227c370f0beb916aac58d8e89fb84af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2227c370f0beb916aac58d8e89fb84af">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a2227c370f0beb916aac58d8e89fb84af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the begin iterator.    <br /></td></tr>
<tr class="separator:a2227c370f0beb916aac58d8e89fb84af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1669bd5e350f33b29fb77491638bac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad1669bd5e350f33b29fb77491638bac3">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ad1669bd5e350f33b29fb77491638bac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the begin iterator.    <br /></td></tr>
<tr class="separator:ad1669bd5e350f33b29fb77491638bac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce858f7614242a5932dc2f2007c2491"><td class="memItemLeft" align="right" valign="top"><a id="a0ce858f7614242a5932dc2f2007c2491" name="a0ce858f7614242a5932dc2f2007c2491"></a>
<a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="memdesc:a0ce858f7614242a5932dc2f2007c2491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator past the end. <br /></td></tr>
<tr class="separator:a0ce858f7614242a5932dc2f2007c2491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1237167bdeacd4fba56a5ac857016e5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a1237167bdeacd4fba56a5ac857016e5d">end</a> () const noexcept</td></tr>
<tr class="memdesc:a1237167bdeacd4fba56a5ac857016e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator past the end.    <br /></td></tr>
<tr class="separator:a1237167bdeacd4fba56a5ac857016e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9d75e306a10b48c06ba63b4be056f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#acf9d75e306a10b48c06ba63b4be056f9">cend</a> () const noexcept</td></tr>
<tr class="memdesc:acf9d75e306a10b48c06ba63b4be056f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator past the end.    <br /></td></tr>
<tr class="separator:acf9d75e306a10b48c06ba63b4be056f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr class="memitem:a150fa19eaa89e599e7a1a977403c92c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a150fa19eaa89e599e7a1a977403c92c7">at</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const i)</td></tr>
<tr class="memdesc:a150fa19eaa89e599e7a1a977403c92c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element.  <br /></td></tr>
<tr class="separator:a150fa19eaa89e599e7a1a977403c92c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793fd184fb4cc75423f6d0783e7cb066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a71c7944c8d741706cab4430820d62848">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a793fd184fb4cc75423f6d0783e7cb066">at</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const i) const</td></tr>
<tr class="memdesc:a793fd184fb4cc75423f6d0783e7cb066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element.    <br /></td></tr>
<tr class="separator:a793fd184fb4cc75423f6d0783e7cb066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942191042f11f41056565211dcdd12a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a942191042f11f41056565211dcdd12a1">operator[]</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const i) noexcept</td></tr>
<tr class="memdesc:a942191042f11f41056565211dcdd12a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element.  <br /></td></tr>
<tr class="separator:a942191042f11f41056565211dcdd12a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aef999e43ac2d3bf1e4db614d5ef41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a71c7944c8d741706cab4430820d62848">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a5aef999e43ac2d3bf1e4db614d5ef41d">operator[]</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const i) const noexcept</td></tr>
<tr class="memdesc:a5aef999e43ac2d3bf1e4db614d5ef41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element.    <br /></td></tr>
<tr class="separator:a5aef999e43ac2d3bf1e4db614d5ef41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f26b35d874441feb7f1c95935f0ced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a74f26b35d874441feb7f1c95935f0ced">front</a> () noexcept</td></tr>
<tr class="memdesc:a74f26b35d874441feb7f1c95935f0ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element. Calling front on an empty container is undefined.  <br /></td></tr>
<tr class="separator:a74f26b35d874441feb7f1c95935f0ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0ddf812a0350ddd4ec383b115aa284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a71c7944c8d741706cab4430820d62848">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2b0ddf812a0350ddd4ec383b115aa284">front</a> () const noexcept</td></tr>
<tr class="memdesc:a2b0ddf812a0350ddd4ec383b115aa284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element. Calling front on an empty container is undefined.    <br /></td></tr>
<tr class="separator:a2b0ddf812a0350ddd4ec383b115aa284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88ca6e0341a3f2767c4417f8d639de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ae88ca6e0341a3f2767c4417f8d639de9">back</a> () noexcept</td></tr>
<tr class="memdesc:ae88ca6e0341a3f2767c4417f8d639de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element.  <br /></td></tr>
<tr class="separator:ae88ca6e0341a3f2767c4417f8d639de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d6b4803073cb358b11fa04623743bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a71c7944c8d741706cab4430820d62848">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a63d6b4803073cb358b11fa04623743bc">back</a> () const noexcept</td></tr>
<tr class="memdesc:a63d6b4803073cb358b11fa04623743bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element.    <br /></td></tr>
<tr class="separator:a63d6b4803073cb358b11fa04623743bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:a665ba669648851a4c24142990117a6da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a665ba669648851a4c24142990117a6da">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a665ba669648851a4c24142990117a6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <br /></td></tr>
<tr class="separator:a665ba669648851a4c24142990117a6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b3572aa4a5f64698b1b81c6455764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a880b3572aa4a5f64698b1b81c6455764">size</a> () const noexcept</td></tr>
<tr class="memdesc:a880b3572aa4a5f64698b1b81c6455764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <br /></td></tr>
<tr class="separator:a880b3572aa4a5f64698b1b81c6455764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c032e734346dbd960abe861e321ed37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2c032e734346dbd960abe861e321ed37">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a2c032e734346dbd960abe861e321ed37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold.  <br /></td></tr>
<tr class="separator:a2c032e734346dbd960abe861e321ed37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa9d093428a1c028ea994af46a38324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#adaa9d093428a1c028ea994af46a38324">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:adaa9d093428a1c028ea994af46a38324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container is able to hold without reallocating (<em>see below</em>).  <br /></td></tr>
<tr class="separator:adaa9d093428a1c028ea994af46a38324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb245d553d892fbf31ce86b22336254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8cb245d553d892fbf31ce86b22336254">reserve</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const new_cap)</td></tr>
<tr class="memdesc:a8cb245d553d892fbf31ce86b22336254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve storage in the underlying data types to accomodate for future inserts.  <br /></td></tr>
<tr class="separator:a8cb245d553d892fbf31ce86b22336254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbe9de92e7404b75c33b1d8fad77be8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0bbe9de92e7404b75c33b1d8fad77be8">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a0bbe9de92e7404b75c33b1d8fad77be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce capacity to current <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a880b3572aa4a5f64698b1b81c6455764" title="Returns the number of elements in the container.">size()</a> to free unused memory.  <br /></td></tr>
<tr class="separator:a0bbe9de92e7404b75c33b1d8fad77be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr class="memitem:a0a01ae7812cea25a852e26dadfe312bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0a01ae7812cea25a852e26dadfe312bc">clear</a> () noexcept</td></tr>
<tr class="memdesc:a0a01ae7812cea25a852e26dadfe312bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the container.  <br /></td></tr>
<tr class="separator:a0a01ae7812cea25a852e26dadfe312bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ea3ffdec23348b28912f7ec599df6"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a> &gt; value_type_ = value_type&gt; </td></tr>
<tr class="memitem:adb3ea3ffdec23348b28912f7ec599df6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#adb3ea3ffdec23348b28912f7ec599df6">push_back</a> (value_type_ &amp;&amp;value)</td></tr>
<tr class="memdesc:adb3ea3ffdec23348b28912f7ec599df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <br /></td></tr>
<tr class="separator:adb3ea3ffdec23348b28912f7ec599df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe4df834458de2bcb08c8b242906a94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a> (auto &amp;&amp;... args)</td></tr>
<tr class="memdesc:adfe4df834458de2bcb08c8b242906a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the end of the container.  <br /></td></tr>
<tr class="separator:adfe4df834458de2bcb08c8b242906a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae227cb84b4162252bae2863aee80e358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ae227cb84b4162252bae2863aee80e358">pop_back</a> ()</td></tr>
<tr class="memdesc:ae227cb84b4162252bae2863aee80e358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container.  <br /></td></tr>
<tr class="separator:ae227cb84b4162252bae2863aee80e358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca440f8d719058ab3bb89d75da0c8ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8ca440f8d719058ab3bb89d75da0c8ab">extract_back</a> ()</td></tr>
<tr class="memdesc:a8ca440f8d719058ab3bb89d75da0c8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last element of the container.  <br /></td></tr>
<tr class="separator:a8ca440f8d719058ab3bb89d75da0c8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr class="memitem:ac30df9d59ad26674011abbe03f78164e"><td class="memItemLeft" align="right" valign="top"><a id="ac30df9d59ad26674011abbe03f78164e" name="ac30df9d59ad26674011abbe03f78164e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const &amp;lhs, <a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac30df9d59ad26674011abbe03f78164e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise comparison. <br /></td></tr>
<tr class="separator:ac30df9d59ad26674011abbe03f78164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b655d5f3946c296fad483a0859295"><td class="memItemLeft" align="right" valign="top"><a id="abe6b655d5f3946c296fad483a0859295" name="abe6b655d5f3946c296fad483a0859295"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=&gt;</b> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const &amp;lhs, <a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:abe6b655d5f3946c296fad483a0859295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise comparison. <br /></td></tr>
<tr class="separator:abe6b655d5f3946c296fad483a0859295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Key-based element access</h2></td></tr>
<tr class="memitem:a4c343a16eb29fb5a7dc362d2270e819a"><td class="memItemLeft" align="right" valign="top"><a id="a4c343a16eb29fb5a7dc362d2270e819a" name="a4c343a16eb29fb5a7dc362d2270e819a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>het_key_t</b> = key_t const &amp;</td></tr>
<tr class="memdesc:a4c343a16eb29fb5a7dc362d2270e819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for key-based access. <br /></td></tr>
<tr class="separator:a4c343a16eb29fb5a7dc362d2270e819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bf348c338735d9fe9b1a8e75747baa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#af0bf348c338735d9fe9b1a8e75747baa">contains</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a> key) const</td></tr>
<tr class="memdesc:af0bf348c338735d9fe9b1a8e75747baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the container has an element with the given key.  <br /></td></tr>
<tr class="separator:af0bf348c338735d9fe9b1a8e75747baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba3ddc0e2ff9cf14d20bbb76d3af41f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a5ba3ddc0e2ff9cf14d20bbb76d3af41f">count</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a> key) const</td></tr>
<tr class="memdesc:a5ba3ddc0e2ff9cf14d20bbb76d3af41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in the container with the specified key.  <br /></td></tr>
<tr class="separator:a5ba3ddc0e2ff9cf14d20bbb76d3af41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace807aa4c3d6d3957a2db08b440820ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ace807aa4c3d6d3957a2db08b440820ab">find</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a> key)</td></tr>
<tr class="memdesc:ace807aa4c3d6d3957a2db08b440820ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element with the given key.  <br /></td></tr>
<tr class="separator:ace807aa4c3d6d3957a2db08b440820ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af482aa37e0119a02a2e5947430073355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#af482aa37e0119a02a2e5947430073355">find</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a> key) const</td></tr>
<tr class="memdesc:af482aa37e0119a02a2e5947430073355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element with the given key.    <br /></td></tr>
<tr class="separator:af482aa37e0119a02a2e5947430073355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ce59924070160783151182dfb54e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad2c1d6c9fa6b708902feb3b832d8283c">mapped_ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a35ce59924070160783151182dfb54e63">at</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a> key)</td></tr>
<tr class="memdesc:a35ce59924070160783151182dfb54e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by key.  <br /></td></tr>
<tr class="separator:a35ce59924070160783151182dfb54e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7317c51dca16d875c7e8776692c7ef7"><td class="memItemLeft" align="right" valign="top">mapped_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ab7317c51dca16d875c7e8776692c7ef7">at</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a> key) const</td></tr>
<tr class="memdesc:ab7317c51dca16d875c7e8776692c7ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by key.    <br /></td></tr>
<tr class="separator:ab7317c51dca16d875c7e8776692c7ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecc2ee1f9a4e55a5c1e96204c8dfc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad2c1d6c9fa6b708902feb3b832d8283c">mapped_ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a7ecc2ee1f9a4e55a5c1e96204c8dfc7a">operator[]</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a> key)</td></tr>
<tr class="memdesc:a7ecc2ee1f9a4e55a5c1e96204c8dfc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by key.  <br /></td></tr>
<tr class="separator:a7ecc2ee1f9a4e55a5c1e96204c8dfc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed8d230a429538240128b12b57e73e0"><td class="memItemLeft" align="right" valign="top">mapped_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8ed8d230a429538240128b12b57e73e0">operator[]</a> (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a> key) const</td></tr>
<tr class="memdesc:a8ed8d230a429538240128b12b57e73e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by key.    <br /></td></tr>
<tr class="separator:a8ed8d230a429538240128b12b57e73e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Key-based element access (context-aware)</h2></td></tr>
<tr class="memitem:a8f1514325d586a04f92bded938c6d3c5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (requires(<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> d) { <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a>&lt;key&gt;(d); })</td></tr>
<tr class="memitem:a8f1514325d586a04f92bded938c6d3c5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8f1514325d586a04f92bded938c6d3c5">at</a> (<a class="el" href="structbio_1_1meta_1_1vtag__t.html">meta::vtag_t</a>&lt; key &gt; key_tag)</td></tr>
<tr class="memdesc:a8f1514325d586a04f92bded938c6d3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it.  <br /></td></tr>
<tr class="separator:a8f1514325d586a04f92bded938c6d3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db1b977e8795b2e72196412c01d9e52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (requires(<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const d) { <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a>&lt;key&gt;(d); })</td></tr>
<tr class="memitem:a4db1b977e8795b2e72196412c01d9e52"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4db1b977e8795b2e72196412c01d9e52">at</a> (<a class="el" href="structbio_1_1meta_1_1vtag__t.html">meta::vtag_t</a>&lt; key &gt; key_tag) const</td></tr>
<tr class="memdesc:a4db1b977e8795b2e72196412c01d9e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it.    <br /></td></tr>
<tr class="separator:a4db1b977e8795b2e72196412c01d9e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabe749de7708bdfaebfd29c460f7fc1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (requires(<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> d) { <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a>&lt;key&gt;(d); })</td></tr>
<tr class="memitem:afabe749de7708bdfaebfd29c460f7fc1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#afabe749de7708bdfaebfd29c460f7fc1">operator[]</a> (<a class="el" href="structbio_1_1meta_1_1vtag__t.html">meta::vtag_t</a>&lt; key &gt; key_tag)</td></tr>
<tr class="memdesc:afabe749de7708bdfaebfd29c460f7fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it.    <br /></td></tr>
<tr class="separator:afabe749de7708bdfaebfd29c460f7fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e10b9b67478f88751e22ae1342729a7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (requires(<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const d) { <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a>&lt;key&gt;(d); })</td></tr>
<tr class="memitem:a5e10b9b67478f88751e22ae1342729a7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a5e10b9b67478f88751e22ae1342729a7">operator[]</a> (<a class="el" href="structbio_1_1meta_1_1vtag__t.html">meta::vtag_t</a>&lt; key &gt; key_tag) const</td></tr>
<tr class="memdesc:a5e10b9b67478f88751e22ae1342729a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it.    <br /></td></tr>
<tr class="separator:a5e10b9b67478f88751e22ae1342729a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579c40970768d2a1bf942f01df2e9a34"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (mapped_t_is_context_aware &amp;&amp; requires { get&lt;key&gt;(get&lt;1&gt;(dict.storage[0])); })</td></tr>
<tr class="memitem:a579c40970768d2a1bf942f01df2e9a34"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a> (meta::decays_to&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> &gt; auto &amp;&amp;dict)</td></tr>
<tr class="memdesc:a579c40970768d2a1bf942f01df2e9a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it.  <br /></td></tr>
<tr class="separator:a579c40970768d2a1bf942f01df2e9a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename key_t, typename mapped_t, bool mapped_t_is_context_aware = false&gt;<br />
class bio::ranges::dictionary&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;</div><p>An associative container with contiguous, predictable storage. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key_t</td><td>The key type; must be convertible to <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string_view.html">std::string_view</a> (e.g. also <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>). </td></tr>
    <tr><td class="paramname">mapped_t</td><td>The mapped type; must be an object type. </td></tr>
    <tr><td class="paramname">mapped_t_is_context_aware</td><td>See below.</td></tr>
  </table>
  </dd>
</dl>
<p>This container behaves like a mixture of <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> and <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>.</p>
<p>It has the following properties:</p><ul>
<li>The element type is <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;key_t, mapped_t&gt;</code>, but the reference type is <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;key_t const &amp;, mapped_t &amp;&gt;</code>.</li>
<li>Contiguous storage of elements in the same order they are inserted.</li>
<li>O(1) access to elements via <code>operator[size_t]</code> and ~O(1) <a class="el" href="classbio_1_1ranges_1_1dictionary.html#adb3ea3ffdec23348b28912f7ec599df6" title="Appends the given element value to the end of the container.">push_back</a> (like <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>).</li>
<li>~O(1) access to mapped value via the key (like <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>).</li>
<li>The size overhead compared to <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>: every key stored twice + at least one uint64_t per element.</li>
<li>The key_type must be convertible to <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string_view.html">std::string_view</a>, and every key must be unique.</li>
<li>There is no <code>insert()</code> member, only <a class="el" href="classbio_1_1ranges_1_1dictionary.html#aee5745c69a2831bba6a7b85dd81cd452" title="Assign from multiple elements.">assign()</a> and <a class="el" href="classbio_1_1ranges_1_1dictionary.html#adb3ea3ffdec23348b28912f7ec599df6" title="Appends the given element value to the end of the container.">push_back()</a> to add elements.</li>
<li>There is no <code>erase()</code> member, only <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0a01ae7812cea25a852e26dadfe312bc" title="Removes all elements from the container.">clear()</a> and <a class="el" href="classbio_1_1ranges_1_1dictionary.html#ae227cb84b4162252bae2863aee80e358" title="Removes the last element of the container.">pop_back()</a> to remove elements.</li>
<li>There is no <code>resize()</code> member, but there is a <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8cb245d553d892fbf31ce86b22336254" title="Reserve storage in the underlying data types to accomodate for future inserts.">reserve()</a> member.</li>
</ul>
<p>This data structure is used in several places where the order of elements must be preserved but fast random access by key is still desirable. It usually makes sense when the key-string is short (less than 16 characters), the value_type is large, and the data structure does not need many changes after construction.</p>
<h3>Element access</h3>
<p>The element type (<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67" title="The value_type type.">value_type</a>) of the dictionary is <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;key_t, mapped_t&gt;</code>. Most functions that provide access to the elements, return <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;key_t const &amp;, mapped_t &amp;&gt;</code> (and not <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;key_t &amp;, mapped_t &amp;&gt;</code> or <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;key_t, mapped_t&gt; &amp;</code>). This prevents changes to the key of an element (which would break the container).</p>
<p>Functions that access an element by key, return a reference to the mapped value instead (like for <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dictionary_8hpp.html">bio/ranges/container/dictionary.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary&lt;std::string, std::string&gt;</a> employee_status;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* add some elements */</span></div>
<div class="line">    employee_status.<a class="code hl_function" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a>(<span class="stringliteral">&quot;Bob&quot;</span>, <span class="stringliteral">&quot;hired&quot;</span>);</div>
<div class="line">    employee_status.<a class="code hl_function" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a>(<span class="stringliteral">&quot;Jane&quot;</span>, <span class="stringliteral">&quot;hired&quot;</span>);</div>
<div class="line">    employee_status.<a class="code hl_function" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a>(<span class="stringliteral">&quot;Marc&quot;</span>, <span class="stringliteral">&quot;fired&quot;</span>);</div>
<div class="line">    employee_status.<a class="code hl_function" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a>(<span class="stringliteral">&quot;Maria&quot;</span>, <span class="stringliteral">&quot;promoted&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Access by position in dictionary; same as insert-order */</span></div>
<div class="line">    <span class="keyword">auto</span> &amp;&amp; first = employee_status[0];         <span class="comment">// a tuple of key and mapped_value</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, first);                  <span class="comment">// prints &#39;(&quot;Bob&quot;, &quot;hired&quot;)&#39;</span></div>
<div class="line">    <span class="comment">//get&lt;0&gt;(first) = &quot;Rob&quot;;                    // key cannot be changed</span></div>
<div class="line">    get&lt;1&gt;(first) = <span class="stringliteral">&quot;tired&quot;</span>;                    <span class="comment">// mapped_value can be changed</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, employee_status[0]);     <span class="comment">// prints &#39;(&quot;Bob&quot;, &quot;tired&quot;)&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Access by key */</span></div>
<div class="line">    <span class="keyword">auto</span> &amp;&amp; jane = employee_status[<span class="stringliteral">&quot;Jane&quot;</span>];     <span class="comment">// the mapped_value belonging to Jane</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, jane);                   <span class="comment">// prints &#39;hired&#39;</span></div>
<div class="line">    jane = <span class="stringliteral">&quot;wired&quot;</span>;                             <span class="comment">// can be changed</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, employee_status[<span class="stringliteral">&quot;Jane&quot;</span>]);<span class="comment">// prints &#39;wired&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* No implicit inserts like std::unordered_map */</span></div>
<div class="line">    <span class="comment">//employee_status[&quot;Shane&quot;] = &quot;hired&quot;;       // DOES NOT WORK.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassbio_1_1ranges_1_1dictionary_html"><div class="ttname"><a href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a></div><div class="ttdoc">An associative container with contiguous, predictable storage.</div><div class="ttdef"><b>Definition:</b> dictionary.hpp:100</div></div>
<div class="ttc" id="aclassbio_1_1ranges_1_1dictionary_html_adfe4df834458de2bcb08c8b242906a94"><div class="ttname"><a href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">bio::ranges::dictionary::emplace_back</a></div><div class="ttdeci">void emplace_back(auto &amp;&amp;... args)</div><div class="ttdoc">Constructs an element in-place at the end of the container.</div><div class="ttdef"><b>Definition:</b> dictionary.hpp:806</div></div>
<div class="ttc" id="adictionary_8hpp_html"><div class="ttname"><a href="dictionary_8hpp.html">dictionary.hpp</a></div><div class="ttdoc">Provides bio::ranges::dictionary.</div></div>
</div><!-- fragment --><h3>Context-aware mapped value types</h3>
<p>If the template parameter <code>mapped_t_is_context_aware</code> is set to true, the <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5" title="The reference type.">reference</a> type of the dictionary becomes <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;key_t const &amp;, mapped_t const &amp;&gt;</code>, i.e. the mapped value in dictionary elements cannot be changed via regular element access.</p>
<p>Additionally, given an object <code>o</code> of type <code>mapped_t</code>, if <code>get&lt;"foo"&gt;(o)</code> is valid, this container provides a special interface:</p>
<ul>
<li>A <code>get&lt;"foo"&gt;(dict)</code> friend function that calls <code>get&lt;"foo"&gt;(dict.at("foo"))</code>.</li>
<li>The <code>.at("foo"_vtag)</code> and <code>operator["foo"_vtag]</code> member functions with identical semantics.</li>
<li>These functions may or may not expose mutable references to the mapped value (or one of its members).</li>
</ul>
<p>In combination with element types that are derived from <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/variant.html">std::variant</a> (and additionally provide the aforementioned string-based get-interface), this can be used to create heterogeneous dictionaries, i.e. transparent access to mapped values of different types by string-IDs known at compile-time.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/array.html">array</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/variant.html">variant</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vtag_8hpp.html">bio/meta/tag/vtag.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dictionary_8hpp.html">bio/ranges/container/dictionary.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"><span class="keyword">using namespace </span>std::string_view_literals;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1meta_1_1literals.html">bio::meta::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* A type to hold an optional field in a SAM record.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * See https://samtools.github.io/hts-specs/SAMtags.pdf for how this is used.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * These optional fields can have data of different types, e.g. string and int (other types</span></div>
<div class="line"><span class="comment"> * are ignored for this simple example). The way to store this in C++ is a std::variant.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Since the relationship between the identifier tag and the type is usually known,</span></div>
<div class="line"><span class="comment"> * we can provide a string-based get&lt;&gt;() interface.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">struct </span>sam_optional_field : <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/variant.html">std::variant</a>&lt;std::string, int32_t&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Declare the get&lt;&quot;foo&quot;&gt;(obj) interface; overloads for cv-qualified versions omitted here. */</span></div>
<div class="line">    <span class="keyword">template</span> &lt;bio::ranges::small_<span class="keywordtype">string</span> tag&gt;</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) get(sam_optional_field <span class="keyword">const</span> &amp; me)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">static_assert</span>(contains(as_strings, tag) || contains(as_ints, tag),</div>
<div class="line">                      <span class="stringliteral">&quot;Don&#39;t know how to choose type for given id.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (contains(as_strings, tag))</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> std::get&lt;std::string&gt;(me);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="comment">/* is int */</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> std::get&lt;int32_t&gt;(me);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">/* Define which tags result in which types; only four example tags defined here. */</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> as_strings = <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/array.html">std::array</a>{<span class="stringliteral">&quot;CO&quot;</span>sv, <span class="stringliteral">&quot;OA&quot;</span>sv};</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> as_ints    = <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/array.html">std::array</a>{<span class="stringliteral">&quot;AS&quot;</span>sv, <span class="stringliteral">&quot;NM&quot;</span>sv};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* In C++23, you can use std::ranges::contains() instead. */</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a class="code hl_variable" href="group__meta__type__list.html#ga919f0a90dd203cf16f02b519e55675ef">contains</a>(<span class="keyword">auto</span> <span class="keyword">const</span> &amp; arr, <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string_view.html">std::string_view</a> <span class="keyword">const</span> val)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/algorithm/ranges/find.html">std::ranges::find</a>(arr, val) != arr.end();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary&lt;std::string, sam_optional_field, true&gt;</a> sam_optional_fields;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* You can easily insert elements of different types, but you need to make sure they match the predefined IDs! */</span></div>
<div class="line">    sam_optional_fields.<a class="code hl_function" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a>(<span class="stringliteral">&quot;CO&quot;</span>, <span class="stringliteral">&quot;This is a comment.&quot;</span>);</div>
<div class="line">    sam_optional_fields.<a class="code hl_function" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a>(<span class="stringliteral">&quot;AS&quot;</span>, 42);                    <span class="comment">// Alignment score 42</span></div>
<div class="line">    sam_optional_fields.<a class="code hl_function" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a>(<span class="stringliteral">&quot;NM&quot;</span>, 23);                    <span class="comment">// Edit distance 23</span></div>
<div class="line">    sam_optional_fields.<a class="code hl_function" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94">emplace_back</a>(<span class="stringliteral">&quot;OA&quot;</span>, <span class="stringliteral">&quot;23M3I11M&quot;</span>);            <span class="comment">// Original cigar</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// std::string s = sam_optional_fields[&quot;CO&quot;];   // [&quot;CO&quot;] returns sam_optional_field</span></div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> s = sam_optional_fields[<span class="stringliteral">&quot;CO&quot;</span>_vtag]; <span class="comment">// [&quot;CO&quot;_vtag] returns std::string (type &quot;inside variant&quot;)</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, s);                          <span class="comment">// prints &quot;This is a comment.&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// int32_t i = sam_optional_fields[&quot;AS&quot;];       // [&quot;AS&quot;] returns sam_optional_field</span></div>
<div class="line">    int32_t i = sam_optional_fields[<span class="stringliteral">&quot;AS&quot;</span>_vtag];     <span class="comment">// [&quot;AS&quot;_vtag] returns int (type &quot;inside variant&quot;)</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, i);                          <span class="comment">// prints &quot;42&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/array.html">array</a></div></div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="abasic_string_view_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/string/basic_string_view.html">std::string_view</a></div></div>
<div class="ttc" id="afind_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/find.html">std::ranges::find</a></div><div class="ttdeci">T find(T... args)</div></div>
<div class="ttc" id="agroup__meta__type__list_html_ga919f0a90dd203cf16f02b519e55675ef"><div class="ttname"><a href="group__meta__type__list.html#ga919f0a90dd203cf16f02b519e55675ef">bio::meta::list_traits::contains</a></div><div class="ttdeci">constexpr bool contains</div><div class="ttdoc">Whether a type occurs in a type list or not.</div><div class="ttdef"><b>Definition:</b> traits.hpp:282</div></div>
<div class="ttc" id="anamespacebio_1_1meta_1_1literals_html"><div class="ttname"><a href="namespacebio_1_1meta_1_1literals.html">bio::meta::literals</a></div><div class="ttdoc">An inline namespace for meta literals. It exists to safely allow using namespace.</div></div>
<div class="ttc" id="avariant_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/variant.html">variant</a></div></div>
<div class="ttc" id="avtag_8hpp_html"><div class="ttname"><a href="vtag_8hpp.html">vtag.hpp</a></div><div class="ttdoc">Provides bio::meta::vtag.</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abfd748291518c0cc53ba6e3091b9918f" name="abfd748291518c0cc53ba6e3091b9918f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd748291518c0cc53ba6e3091b9918f">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::iterator =  <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/conditional.html">std::conditional_t</a>&lt;mapped_t_is_context_aware, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>, detail::random_access_iterator&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The iterator type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afa51eeb2af0b85152dcd5868a40a25a4" name="afa51eeb2af0b85152dcd5868a40a25a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa51eeb2af0b85152dcd5868a40a25a4">&#9670;&#160;</a></span>dictionary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;typename... value_type_&gt; <br />
requires ((std::convertible_to&lt;value_type_, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt; &amp;&amp; ...) &amp;&amp; sizeof...(value_type_) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">value_type_ &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a list of values of value_type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type_</td><td>A parameter pack where each type is equal to value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The values to construct from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the number of elements.</p>
<h3>Exceptions</h3>
<p>Basic exception gurantee. </p>

</div>
</div>
<a id="ab68cbbed5ea28476e31c97f6c875aec8" name="ab68cbbed5ea28476e31c97f6c875aec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68cbbed5ea28476e31c97f6c875aec8">&#9670;&#160;</a></span>dictionary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;meta::different_from&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> &gt; begin_it_type, typename end_it_type &gt; <br />
requires (meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>, begin_it_type&gt; &amp;&amp; std::forward_iterator&lt;begin_it_type&gt; &amp;&amp; std::sentinel_for&lt;end_it_type, begin_it_type&gt; &amp;&amp; std::convertible_to&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iter_t.html">std::iter_reference_t</a>&lt;begin_it_type&gt;, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">begin_it_type const&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">end_it_type const&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from two iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">begin_it_type</td><td>Must model std::forward_iterator and <code>value_type</code> must be constructible from the reference type of begin_it_type. </td></tr>
    <tr><td class="paramname">end_it_type</td><td>Must satisfy std::sentinel_for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_it</td><td>Begin of range to construct/assign from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_it</td><td>End of range to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the distance between <code>begin_it</code> and <code>end_it</code>.</p>
<h3>Exceptions</h3>
<p>Basic exception gurantee. </p>

</div>
</div>
<a id="a0a7038b3d7008de29d6462f96369efe3" name="a0a7038b3d7008de29d6462f96369efe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7038b3d7008de29d6462f96369efe3">&#9670;&#160;</a></span>dictionary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;meta::different_from&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> &gt; other_range_t&gt; <br />
requires (std::ranges::input_range&lt;other_range_t&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">other_range_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a different range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">other_range_t</td><td>The type of range to be inserted; must satisfy std::ranges::input_range and <code>value_type</code> must be constructible from std::ranges::range_reference_t&lt;other_range_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>The sequences to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the size of <code>range</code>.</p>
<h3>Exceptions</h3>
<p>Basic exception gurantee. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a396c78c4ade1cd6d6319c19edb9b981d" name="a396c78c4ade1cd6d6319c19edb9b981d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396c78c4ade1cd6d6319c19edb9b981d">&#9670;&#160;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;meta::different_from&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> &gt; begin_it_type, typename end_it_type &gt; <br />
requires (meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>, begin_it_type&gt; &amp;&amp; std::forward_iterator&lt;begin_it_type&gt; &amp;&amp; std::sentinel_for&lt;end_it_type, begin_it_type&gt; &amp;&amp; std::convertible_to&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iter_t.html">std::iter_reference_t</a>&lt;begin_it_type&gt;, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">begin_it_type&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">end_it_type&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from pair of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">begin_it_type</td><td>Must satisfy std::forward_iterator and the <code>value_type</code> must be constructible from the reference type of begin_it_type. </td></tr>
    <tr><td class="paramname">end_it_type</td><td>Must satisfy std::sentinel_for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_it</td><td>Begin of range to construct/assign from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_it</td><td>End of range to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the distance between <code>begin_it</code> and <code>end_it</code>.</p>
<h3>Exceptions</h3>
<p>Basic exception gurantee. </p>

</div>
</div>
<a id="a96f5eb20f3433d53d8f7169afdc34011" name="a96f5eb20f3433d53d8f7169afdc34011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f5eb20f3433d53d8f7169afdc34011">&#9670;&#160;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range other_range_t&gt; <br />
requires std::convertible_to&lt;std::ranges::range_reference_t&lt;other_range_t&gt;, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">other_range_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from a different range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">other_range_t</td><td>The type of range to be inserted; must satisfy std::ranges::input_range and <code>value_type</code> must be constructible from std::ranges::range_reference_t&lt;other_range_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>The sequences to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the size of <code>range</code>.</p>
<h3>Exceptions</h3>
<p>Basic exception gurantee. </p>

</div>
</div>
<a id="aee5745c69a2831bba6a7b85dd81cd452" name="aee5745c69a2831bba6a7b85dd81cd452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5745c69a2831bba6a7b85dd81cd452">&#9670;&#160;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;typename... value_type_&gt; <br />
requires ((meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a>, value_type_&gt; &amp;&amp; ...) &amp;&amp; (meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a>, value_type_&gt; &amp;&amp; ...) &amp;&amp; (meta::different_from&lt;<a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a>, value_type_&gt; &amp;&amp; ...) &amp;&amp; (std::convertible_to&lt;value_type_, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a>&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(value_type_) &gt; 0))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">value_type_ &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from multiple elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Multiple elements of value_type; must be at least one.</td></tr>
  </table>
  </dd>
</dl>
<p>This replaces the container's contents with the provided elements.</p>
<h3>Complexity</h3>
<p>Linear in the size of <code>args</code> and/or container size.</p>
<h3>Exceptions</h3>
<p>Basic exception gurantee. </p>

</div>
</div>
<a id="a35ce59924070160783151182dfb54e63" name="a35ce59924070160783151182dfb54e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ce59924070160783151182dfb54e63">&#9670;&#160;</a></span>at() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad2c1d6c9fa6b708902feb3b832d8283c">mapped_ref_t</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mapped value belonging to the key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function returns a reference to the mapped object (not a key-value-pair).</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee. </p>

</div>
</div>
<a id="ab7317c51dca16d875c7e8776692c7ef7" name="ab7317c51dca16d875c7e8776692c7ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7317c51dca16d875c7e8776692c7ef7">&#9670;&#160;</a></span>at() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mapped_t const  &amp; <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by key.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mapped value belonging to the key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function returns a reference to the mapped object (not a key-value-pair).</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee.   </p>

</div>
</div>
<a id="a8f1514325d586a04f92bded938c6d3c5" name="a8f1514325d586a04f92bded938c6d3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1514325d586a04f92bded938c6d3c5">&#9670;&#160;</a></span>at() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (requires(<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> d) { <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a>&lt;key&gt;(d); })</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbio_1_1meta_1_1vtag__t.html">meta::vtag_t</a>&lt; key &gt;&#160;</td>
          <td class="paramname"><em>key_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_tag</td><td>A tag object wrapping the compile-time string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>get&lt;key&gt;(dict[key])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only available if <code>mapped_t_is_context_aware</code> is set to true and if <code>get&lt;key&gt;()</code> can be called on an object of type <code>mapped_t</code>.</p>
<p>Note that while <code>dict[key]</code> always returns a <code>const &amp;</code> for context-aware dictionaries, this function may return a writable <code>&amp;</code>.</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee. </p>

</div>
</div>
<a id="a4db1b977e8795b2e72196412c01d9e52" name="a4db1b977e8795b2e72196412c01d9e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db1b977e8795b2e72196412c01d9e52">&#9670;&#160;</a></span>at() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (requires(<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const d) { <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a>&lt;key&gt;(d); })</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbio_1_1meta_1_1vtag__t.html">meta::vtag_t</a>&lt; key &gt;&#160;</td>
          <td class="paramname"><em>key_tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_tag</td><td>A tag object wrapping the compile-time string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>get&lt;key&gt;(dict[key])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only available if <code>mapped_t_is_context_aware</code> is set to true and if <code>get&lt;key&gt;()</code> can be called on an object of type <code>mapped_t</code>.</p>
<p>Note that while <code>dict[key]</code> always returns a <code>const &amp;</code> for context-aware dictionaries, this function may return a writable <code>&amp;</code>.</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee.   </p>

</div>
</div>
<a id="a150fa19eaa89e599e7a1a977403c92c7" name="a150fa19eaa89e599e7a1a977403c92c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150fa19eaa89e599e7a1a977403c92c7">&#9670;&#160;</a></span>at() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5">reference</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>If you access an element behind the last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value at position <code>i</code>.</dd></dl>
<p>Note that this function returns the value_type, i.e. a key-value-pair.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>Throws <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a> if <code>i &gt;= <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a880b3572aa4a5f64698b1b81c6455764" title="Returns the number of elements in the container.">size()</a></code>. </p>

</div>
</div>
<a id="a793fd184fb4cc75423f6d0783e7cb066" name="a793fd184fb4cc75423f6d0783e7cb066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793fd184fb4cc75423f6d0783e7cb066">&#9670;&#160;</a></span>at() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a71c7944c8d741706cab4430820d62848">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>If you access an element behind the last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value at position <code>i</code>.</dd></dl>
<p>Note that this function returns the value_type, i.e. a key-value-pair.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>Throws <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a> if <code>i &gt;= <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a880b3572aa4a5f64698b1b81c6455764" title="Returns the number of elements in the container.">size()</a></code>.   </p>

</div>
</div>
<a id="a63d6b4803073cb358b11fa04623743bc" name="a63d6b4803073cb358b11fa04623743bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d6b4803073cb358b11fa04623743bc">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a71c7944c8d741706cab4430820d62848">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last element.   </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value at the last position.</dd></dl>
<p>Note that this function returns a key-value-pair (not the mapped value).</p>
<p>Calling back on an empty container is undefined. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee.   </p>

</div>
</div>
<a id="ae88ca6e0341a3f2767c4417f8d639de9" name="ae88ca6e0341a3f2767c4417f8d639de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88ca6e0341a3f2767c4417f8d639de9">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5">reference</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value at the last position.</dd></dl>
<p>Note that this function returns a key-value-pair (not the mapped value).</p>
<p>Calling back on an empty container is undefined. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a2227c370f0beb916aac58d8e89fb84af" name="a2227c370f0beb916aac58d8e89fb84af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2227c370f0beb916aac58d8e89fb84af">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the begin iterator.   </p>

</div>
</div>
<a id="adaa9d093428a1c028ea994af46a38324" name="adaa9d093428a1c028ea994af46a38324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa9d093428a1c028ea994af46a38324">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that the container is able to hold without reallocating (<em>see below</em>). </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the currently allocated storage.</dd></dl>
<p>This returns the capacity of the internal storage vector. Depending on the implementation, this may or may not be identical to the capacity of the internal hash-map. Thus, <a class="el" href="classbio_1_1ranges_1_1dictionary.html#adb3ea3ffdec23348b28912f7ec599df6" title="Appends the given element value to the end of the container.">push_back()</a> and <a class="el" href="classbio_1_1ranges_1_1dictionary.html#adfe4df834458de2bcb08c8b242906a94" title="Constructs an element in-place at the end of the container.">emplace_back()</a> within the current capacity are guaranteed to not invalidate any iterators, but may result in the hash-table allocating.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="ad1669bd5e350f33b29fb77491638bac3" name="ad1669bd5e350f33b29fb77491638bac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1669bd5e350f33b29fb77491638bac3">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the begin iterator.   </p>

</div>
</div>
<a id="acf9d75e306a10b48c06ba63b4be056f9" name="acf9d75e306a10b48c06ba63b4be056f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9d75e306a10b48c06ba63b4be056f9">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator past the end.   </p>

</div>
</div>
<a id="a0a01ae7812cea25a852e26dadfe312bc" name="a0a01ae7812cea25a852e26dadfe312bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a01ae7812cea25a852e26dadfe312bc">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the container. </p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="af0bf348c338735d9fe9b1a8e75747baa" name="af0bf348c338735d9fe9b1a8e75747baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bf348c338735d9fe9b1a8e75747baa">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the container has an element with the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an element with the key exists, <code>false</code> otherwise.</dd></dl>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a5ba3ddc0e2ff9cf14d20bbb76d3af41f" name="a5ba3ddc0e2ff9cf14d20bbb76d3af41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba3ddc0e2ff9cf14d20bbb76d3af41f">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of elements in the container with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if an element with the key exists, <code>0</code> otherwise.</dd></dl>
<p>Since keys are required to be unique, this function can only return <code>0</code> or <code>1</code>.</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="adfe4df834458de2bcb08c8b242906a94" name="adfe4df834458de2bcb08c8b242906a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe4df834458de2bcb08c8b242906a94">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments used to construct the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>If an element with the key already exists in the container.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee. </p>

</div>
</div>
<a id="a665ba669648851a4c24142990117a6da" name="a665ba669648851a4c24142990117a6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665ba669648851a4c24142990117a6da">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty, <code>false</code> otherwise.</dd></dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a1237167bdeacd4fba56a5ac857016e5d" name="a1237167bdeacd4fba56a5ac857016e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1237167bdeacd4fba56a5ac857016e5d">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator past the end.   </p>

</div>
</div>
<a id="a8ca440f8d719058ab3bb89d75da0c8ab" name="a8ca440f8d719058ab3bb89d75da0c8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca440f8d719058ab3bb89d75da0c8ab">&#9670;&#160;</a></span>extract_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::extract_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes and returns the last element of the container. </p>
<p>Calling <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8ca440f8d719058ab3bb89d75da0c8ab" title="Removes and returns the last element of the container.">extract_back()</a> on an empty container is undefined. In debug mode an assertion will be thrown.</p>
<p>No iterators or references except for <a class="el" href="classbio_1_1ranges_1_1dictionary.html#ae88ca6e0341a3f2767c4417f8d639de9" title="Return the last element.">back()</a> and <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0ce858f7614242a5932dc2f2007c2491" title="Returns iterator past the end.">end()</a> are invalidated.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee. </p>

</div>
</div>
<a id="ace807aa4c3d6d3957a2db08b440820ab" name="ace807aa4c3d6d3957a2db08b440820ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace807aa4c3d6d3957a2db08b440820ab">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#abfd748291518c0cc53ba6e3091b9918f">iterator</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an element with the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the found element or <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0ce858f7614242a5932dc2f2007c2491" title="Returns iterator past the end.">end()</a> if the key is not found.</dd></dl>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="af482aa37e0119a02a2e5947430073355" name="af482aa37e0119a02a2e5947430073355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af482aa37e0119a02a2e5947430073355">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2dc155122dfef685f0ca4eab6e017773">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an element with the given key.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the found element or <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0ce858f7614242a5932dc2f2007c2491" title="Returns iterator past the end.">end()</a> if the key is not found.</dd></dl>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee.   </p>

</div>
</div>
<a id="a2b0ddf812a0350ddd4ec383b115aa284" name="a2b0ddf812a0350ddd4ec383b115aa284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0ddf812a0350ddd4ec383b115aa284">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a71c7944c8d741706cab4430820d62848">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first element. Calling front on an empty container is undefined.   </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value at the first position.</dd></dl>
<p>Note that this function returns a key-value-pair (not the mapped value).</p>
<p>Calling front on an empty container is undefined. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee.   </p>

</div>
</div>
<a id="a74f26b35d874441feb7f1c95935f0ced" name="a74f26b35d874441feb7f1c95935f0ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f26b35d874441feb7f1c95935f0ced">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5">reference</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first element. Calling front on an empty container is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value at the first position.</dd></dl>
<p>Note that this function returns a key-value-pair (not the mapped value).</p>
<p>Calling front on an empty container is undefined. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a2c032e734346dbd960abe861e321ed37" name="a2c032e734346dbd960abe861e321ed37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c032e734346dbd960abe861e321ed37">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<p>This value typically reflects the theoretical limit on the size of the container. At runtime, the size of the container may be limited to a value smaller than <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a2c032e734346dbd960abe861e321ed37" title="Returns the maximum number of elements the container is able to hold.">max_size()</a> by the amount of RAM available.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a7ecc2ee1f9a4e55a5c1e96204c8dfc7a" name="a7ecc2ee1f9a4e55a5c1e96204c8dfc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecc2ee1f9a4e55a5c1e96204c8dfc7a">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad2c1d6c9fa6b708902feb3b832d8283c">mapped_ref_t</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mapped value belonging to the key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is identical to <code>.at(key)</code>. It never inserts elements like the respective function in <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a> would do; instead it throws an exception if an element with the given key does not exist.</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee. </p>

</div>
</div>
<a id="a8ed8d230a429538240128b12b57e73e0" name="a8ed8d230a429538240128b12b57e73e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed8d230a429538240128b12b57e73e0">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mapped_t const  &amp; <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a4c343a16eb29fb5a7dc362d2270e819a">het_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by key.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mapped value belonging to the key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is identical to <code>.at(key)</code>. It never inserts elements like the respective function in <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a> would do; instead it throws an exception if an element with the given key does not exist.</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee.   </p>

</div>
</div>
<a id="afabe749de7708bdfaebfd29c460f7fc1" name="afabe749de7708bdfaebfd29c460f7fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabe749de7708bdfaebfd29c460f7fc1">&#9670;&#160;</a></span>operator[]() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (requires(<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> d) { <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a>&lt;key&gt;(d); })</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbio_1_1meta_1_1vtag__t.html">meta::vtag_t</a>&lt; key &gt;&#160;</td>
          <td class="paramname"><em>key_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_tag</td><td>A tag object wrapping the compile-time string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>get&lt;key&gt;(dict[key])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only available if <code>mapped_t_is_context_aware</code> is set to true and if <code>get&lt;key&gt;()</code> can be called on an object of type <code>mapped_t</code>.</p>
<p>Note that while <code>dict[key]</code> always returns a <code>const &amp;</code> for context-aware dictionaries, this function may return a writable <code>&amp;</code>.</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee.   </p>

</div>
</div>
<a id="a5e10b9b67478f88751e22ae1342729a7" name="a5e10b9b67478f88751e22ae1342729a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e10b9b67478f88751e22ae1342729a7">&#9670;&#160;</a></span>operator[]() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (requires(<a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a> const d) { <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34">get</a>&lt;key&gt;(d); })</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbio_1_1meta_1_1vtag__t.html">meta::vtag_t</a>&lt; key &gt;&#160;</td>
          <td class="paramname"><em>key_tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_tag</td><td>A tag object wrapping the compile-time string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>get&lt;key&gt;(dict[key])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only available if <code>mapped_t_is_context_aware</code> is set to true and if <code>get&lt;key&gt;()</code> can be called on an object of type <code>mapped_t</code>.</p>
<p>Note that while <code>dict[key]</code> always returns a <code>const &amp;</code> for context-aware dictionaries, this function may return a writable <code>&amp;</code>.</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee.   </p>

</div>
</div>
<a id="a5aef999e43ac2d3bf1e4db614d5ef41d" name="a5aef999e43ac2d3bf1e4db614d5ef41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aef999e43ac2d3bf1e4db614d5ef41d">&#9670;&#160;</a></span>operator[]() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a71c7944c8d741706cab4430820d62848">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value at position <code>i</code>.</dd></dl>
<p>Note that this function returns a key-value-pair (not the mapped value).</p>
<p>Accessing an element behind the last causes undefined behaviour. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee.   </p>

</div>
</div>
<a id="a942191042f11f41056565211dcdd12a1" name="a942191042f11f41056565211dcdd12a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942191042f11f41056565211dcdd12a1">&#9670;&#160;</a></span>operator[]() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8e76e09ed0c84063f079249f4cbadeb5">reference</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value at position <code>i</code>.</dd></dl>
<p>Note that this function returns a key-value-pair (not the mapped value).</p>
<p>Accessing an element behind the last causes undefined behaviour. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="ae227cb84b4162252bae2863aee80e358" name="ae227cb84b4162252bae2863aee80e358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae227cb84b4162252bae2863aee80e358">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. </p>
<p>Calling <a class="el" href="classbio_1_1ranges_1_1dictionary.html#ae227cb84b4162252bae2863aee80e358" title="Removes the last element of the container.">pop_back()</a> on an empty container is undefined. In debug mode an assertion will be thrown.</p>
<p>No iterators or references except for <a class="el" href="classbio_1_1ranges_1_1dictionary.html#ae88ca6e0341a3f2767c4417f8d639de9" title="Return the last element.">back()</a> and <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0ce858f7614242a5932dc2f2007c2491" title="Returns iterator past the end.">end()</a> are invalidated.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="adb3ea3ffdec23348b28912f7ec599df6" name="adb3ea3ffdec23348b28912f7ec599df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ea3ffdec23348b28912f7ec599df6">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;std::convertible_to&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a8507b5056de3944f9c765f9868622d67">value_type</a> &gt; value_type_ = value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>If an element with the key already exists in the container.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee. </p>

</div>
</div>
<a id="a8cb245d553d892fbf31ce86b22336254" name="a8cb245d553d892fbf31ce86b22336254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb245d553d892fbf31ce86b22336254">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> const&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve storage in the underlying data types to accomodate for future inserts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_cap</td><td>The desired capacity.</td></tr>
  </table>
  </dd>
</dl>
<p>This reserves the specified capacity in both internal data structures to prevent reallocation on subsequent back insertions. It never reduces the <a class="el" href="classbio_1_1ranges_1_1dictionary.html#adaa9d093428a1c028ea994af46a38324" title="Returns the number of elements that the container is able to hold without reallocating (see below).">capacity()</a>; use <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a0bbe9de92e7404b75c33b1d8fad77be8" title="Reduce capacity to current size() to free unused memory.">shrink_to_fit()</a> for that.</p>
<h3>Complexity</h3>
<p>Average case: linear in new_cap. Worst case: quadratic in new_cap.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee. </p>

</div>
</div>
<a id="a0bbe9de92e7404b75c33b1d8fad77be8" name="a0bbe9de92e7404b75c33b1d8fad77be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbe9de92e7404b75c33b1d8fad77be8">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce capacity to current <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a880b3572aa4a5f64698b1b81c6455764" title="Returns the number of elements in the container.">size()</a> to free unused memory. </p>
<p>This only reduces the capacity of the internal storage vector, not of the hash-map.</p>
<h3>Complexity</h3>
<p>Worst case: linear in <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a880b3572aa4a5f64698b1b81c6455764" title="Returns the number of elements in the container.">size()</a>.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee. </p>

</div>
</div>
<a id="a880b3572aa4a5f64698b1b81c6455764" name="a880b3572aa4a5f64698b1b81c6455764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880b3572aa4a5f64698b1b81c6455764">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1dictionary.html#ad13b36964d579d6258a2699003787047">size_type</a> <a class="el" href="classbio_1_1ranges_1_1dictionary.html">bio::ranges::dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a579c40970768d2a1bf942f01df2e9a34" name="a579c40970768d2a1bf942f01df2e9a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579c40970768d2a1bf942f01df2e9a34">&#9670;&#160;</a></span>get</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename mapped_t , bool mapped_t_is_context_aware = false&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classbio_1_1ranges_1_1small__string.html">small_string</a> key&gt; <br />
requires (mapped_t_is_context_aware &amp;&amp; requires { get&lt;key&gt;(get&lt;1&gt;(dict.storage[0])); })</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) get </td>
          <td>(</td>
          <td class="paramtype">meta::decays_to&lt; <a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a>&lt; key_t, mapped_t, mapped_t_is_context_aware &gt; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element by compile-time string and implicitly call <a class="el" href="classbio_1_1ranges_1_1dictionary.html#a579c40970768d2a1bf942f01df2e9a34" title="Access element by compile-time string and implicitly call get() on it.">get()</a> on it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dict</td><td>An object of this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>get&lt;key&gt;(dict[key])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>if no element is associated with the key.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only available if <code>mapped_t_is_context_aware</code> is set to true and if <code>get&lt;key&gt;()</code> can be called on an object of type <code>mapped_t</code>.</p>
<p>Note that while <code>dict[key]</code> always returns a <code>const &amp;</code> for context-aware dictionaries, this function may return a writable <code>&amp;</code>.</p>
<h3>Complexity</h3>
<p>Amortized constant.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bio/ranges/container/<a class="el" href="dictionary_8hpp_source.html">dictionary.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="navelem"><a class="el" href="namespacebio.html">bio</a></li><li class="navelem"><a class="el" href="namespacebio_1_1ranges.html">ranges</a></li><li class="navelem"><a class="el" href="classbio_1_1ranges_1_1dictionary.html">dictionary</a></li>
    <li class="footer">Generated on Thu Mar 30 2023 15:25:52 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
