<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: Meta</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">BioC++<span id="projectnumber">&#160;core-0.7.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__meta.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Meta</div></div>
</div><!--header-->
<div class="contents">

<p>Provides metaprogramming utilities, concepts and some helper classes.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Meta:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__meta.svg" width="196" height="184"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__concept"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concept.html">Concept</a></td></tr>
<tr class="memdesc:group__concept"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional concepts that are not specific to a BioC++ module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__meta__tag"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta__tag.html">Tag</a></td></tr>
<tr class="memdesc:group__meta__tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides tagging utilities (often used in tag-dispatching). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__meta__type__list"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta__type__list.html">Type List</a></td></tr>
<tr class="memdesc:group__meta__type__list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="structbio_1_1meta_1_1type__list.html" title="Type that contains multiple types.">bio::meta::type_list</a> and metaprogramming utilities for working on type lists. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__type__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__traits.html">Type Traits</a></td></tr>
<tr class="memdesc:group__type__traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides various type traits and their shortcuts. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacebio_1_1meta"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio_1_1meta.html">bio::meta</a></td></tr>
<tr class="memdesc:namespacebio_1_1meta"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Meta module's namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacebio_1_1meta_1_1literals"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio_1_1meta_1_1literals.html">bio::meta::literals</a></td></tr>
<tr class="memdesc:namespacebio_1_1meta_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline namespace for meta literals. It exists to safely allow <code>using namespace</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1meta_1_1overloaded.html">bio::meta::overloaded&lt; functors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to create an overload set of multiple functors.  <a href="structbio_1_1meta_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1meta_1_1pod__tuple_3_01type0_01_4.html">bio::meta::pod_tuple&lt; type0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion anchor for <a class="el" href="structbio_1_1meta_1_1pod__tuple.html" title="Behaves like std::tuple but is an aggregate PODType.">pod_tuple</a>.  <a href="structbio_1_1meta_1_1pod__tuple_3_01type0_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1meta_1_1pod__tuple_3_01type0_00_01types_8_8_8_01_4.html">bio::meta::pod_tuple&lt; type0, types... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behaves like <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> but is an aggregate <a href="https://en.cppreference.com/w/cpp/concept/PODType" target="_blank">PODType</a>.  <a href="structbio_1_1meta_1_1pod__tuple_3_01type0_00_01types_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga30e22b8e28ec8e4c587b4403a4e76075"><td class="memTemplParams" colspan="2"><a id="ga30e22b8e28ec8e4c587b4403a4e76075" name="ga30e22b8e28ec8e4c587b4403a4e76075"></a>
template&lt;typename... functors&gt; </td></tr>
<tr class="memitem:ga30e22b8e28ec8e4c587b4403a4e76075"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>overloaded</b> (functors...) -&gt; <a class="el" href="structbio_1_1meta_1_1overloaded.html">overloaded</a>&lt; functors... &gt;</td></tr>
<tr class="memdesc:ga30e22b8e28ec8e4c587b4403a4e76075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for <a class="el" href="structbio_1_1meta_1_1overloaded.html" title="Wrapper to create an overload set of multiple functors.">bio::meta::overloaded</a>. <br /></td></tr>
<tr class="separator:ga30e22b8e28ec8e4c587b4403a4e76075"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tuple utility functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Helper functions for tuple like objects. </p>
</td></tr>
<tr class="memitem:ga102d29d8c2ddb2f663ec52c7305d695f"><td class="memTemplParams" colspan="2">template&lt;size_t pivot_c, template&lt; typename... &gt; typename tuple_t, typename... ts&gt; <br />
requires tuple_like&lt;tuple_t&lt;ts...&gt;&gt;</td></tr>
<tr class="memitem:ga102d29d8c2ddb2f663ec52c7305d695f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__meta.html#ga102d29d8c2ddb2f663ec52c7305d695f">bio::meta::tuple_split</a> (tuple_t&lt; ts... &gt; const &amp;t)</td></tr>
<tr class="memdesc:ga102d29d8c2ddb2f663ec52c7305d695f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a tuple like data structure at the given position.  <br /></td></tr>
<tr class="separator:ga102d29d8c2ddb2f663ec52c7305d695f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ccf2aa446ef36d6eec380be75d1b324"><td class="memTemplParams" colspan="2">template&lt;typename pivot_t , tuple_like tuple_t&gt; </td></tr>
<tr class="memitem:ga9ccf2aa446ef36d6eec380be75d1b324"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__meta.html#ga9ccf2aa446ef36d6eec380be75d1b324">bio::meta::tuple_split</a> (tuple_t &amp;&amp;t)</td></tr>
<tr class="memdesc:ga9ccf2aa446ef36d6eec380be75d1b324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a tuple like data structure at the first position of the given type.  <br /></td></tr>
<tr class="separator:ga9ccf2aa446ef36d6eec380be75d1b324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad867e41f39123fe91238cc0740c4e92b"><td class="memTemplParams" colspan="2">template&lt;tuple_like tuple_t&gt; </td></tr>
<tr class="memitem:gad867e41f39123fe91238cc0740c4e92b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__meta.html#gad867e41f39123fe91238cc0740c4e92b">bio::meta::tuple_pop_front</a> (tuple_t &amp;&amp;t)</td></tr>
<tr class="memdesc:gad867e41f39123fe91238cc0740c4e92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of a tuple.  <br /></td></tr>
<tr class="separator:gad867e41f39123fe91238cc0740c4e92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f36a5ce661c145350e1ded1a5a8884"><td class="memTemplParams" colspan="2">template&lt;size_t pivot_c, template&lt; typename... &gt; typename tuple_t, typename... ts&gt; <br />
requires tuple_like&lt;tuple_t&lt;ts...&gt;&gt;</td></tr>
<tr class="memitem:ga54f36a5ce661c145350e1ded1a5a8884"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__meta.html#ga54f36a5ce661c145350e1ded1a5a8884">bio::meta::tuple_split</a> (tuple_t&lt; ts... &gt; &amp;&amp;t)</td></tr>
<tr class="memdesc:ga54f36a5ce661c145350e1ded1a5a8884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a tuple like data structure at the given position.    <br /></td></tr>
<tr class="separator:ga54f36a5ce661c145350e1ded1a5a8884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides metaprogramming utilities, concepts and some helper classes. </p>
<p>The meta module is used strongly by other modules, but the content is usually not relevant to most users of the library. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad867e41f39123fe91238cc0740c4e92b" name="gad867e41f39123fe91238cc0740c4e92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad867e41f39123fe91238cc0740c4e92b">&#9670;&#160;</a></span>tuple_pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;tuple_like tuple_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::meta::tuple_pop_front </td>
          <td>(</td>
          <td class="paramtype">tuple_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element of a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The original tuple.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tuple without the first element of <code>t</code>.</dd></dl>
<p>Note, that the tuple must contain at least one element and must support empty tuple types, i.e. <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a> cannot be used.</p>
<h3>Complexity</h3>
<p>Linear in the number of elements.</p>
<h3>Thread safety</h3>
<p>Concurrent invocations of this functions are thread safe. </p>

</div>
</div>
<a id="ga9ccf2aa446ef36d6eec380be75d1b324" name="ga9ccf2aa446ef36d6eec380be75d1b324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ccf2aa446ef36d6eec380be75d1b324">&#9670;&#160;</a></span>tuple_split() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename pivot_t , tuple_like tuple_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::meta::tuple_split </td>
          <td>(</td>
          <td class="paramtype">tuple_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a tuple like data structure at the first position of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pivot_t</td><td>A template type specifying the split position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The original tuple to split.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tuple of tuples with the left side of the split and the right side of the split.</dd></dl>
<p>Splits a tuple into two tuples, while the element at the split position will be contained in the second tuple. Note, that the returned tuples can be empty. For this reason it is not possible to use tuple like objects, that cannot be empty, i.e. <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>. Using such an object will emit an compiler error.</p>
<h3>example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/string.html">string</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple__utility_8hpp.html">bio/meta/tuple_utility.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Split at position 2.</span></div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, char, float, std::string&gt;</a> t{1, <span class="charliteral">&#39;c&#39;</span>, 0.3, <span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line">    <span class="keyword">auto</span> [left, right] = bio::meta::tuple_split&lt;2&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left) -&gt; std::tuple&lt;int, char&gt;; decltype(right) -&gt; std::tuple&lt;float, std::string&gt;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Split at position 0.</span></div>
<div class="line">    <span class="keyword">auto</span> [left1, right1] = bio::meta::tuple_split&lt;0&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left1) -&gt; std::tuple&lt;&gt;; decltype(right1) -&gt; std::tuple&lt;int, char, float, std::string&gt;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Split at position 4.</span></div>
<div class="line">    <span class="keyword">auto</span> [left2, right2] = bio::meta::tuple_split&lt;4&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left2) -&gt; std::tuple&lt;int, char, float, std::string&gt;; decltype(right2) -&gt; std::tuple&lt;&gt;;</span></div>
<div class="line">}</div>
<div class="ttc" id="astring_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/string.html">string</a></div></div>
<div class="ttc" id="atuple__utility_8hpp_html"><div class="ttname"><a href="tuple__utility_8hpp.html">tuple_utility.hpp</a></div><div class="ttdoc">Provides utility functions for tuple like interfaces.</div></div>
<div class="ttc" id="atuple_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></div></div>
</div><!-- fragment --><h3>Complexity</h3>
<p>Linear in the number of elements.</p>
<h3>Thread safety</h3>
<p>Concurrent invocations of this functions are thread safe. </p>

</div>
</div>
<a id="ga54f36a5ce661c145350e1ded1a5a8884" name="ga54f36a5ce661c145350e1ded1a5a8884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f36a5ce661c145350e1ded1a5a8884">&#9670;&#160;</a></span>tuple_split() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t pivot_c, template&lt; typename... &gt; typename tuple_t, typename... ts&gt; <br />
requires tuple_like&lt;tuple_t&lt;ts...&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::meta::tuple_split </td>
          <td>(</td>
          <td class="paramtype">tuple_t&lt; ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a tuple like data structure at the given position.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pivot_c</td><td>A template value specifying the split position. </td></tr>
    <tr><td class="paramname">tuple_t</td><td>A template alias for a tuple like object. </td></tr>
    <tr><td class="paramname">...ts</td><td>Types <code>tuple_t</code> is specified with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The original tuple to split.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tuple of tuples with the left side of the split and the right side of the split.</dd></dl>
<p>Splits a tuple into two tuples, while the element at the split position will be contained in the second tuple. Note, that the returned tuples can be empty. For this reason it is not possible to use tuple like objects, that cannot be empty, i.e. <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>. Using such an object will emit an compiler error.</p>
<h3>example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/string.html">string</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple__utility_8hpp.html">bio/meta/tuple_utility.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Split at position 2.</span></div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, char, float, std::string&gt;</a> t{1, <span class="charliteral">&#39;c&#39;</span>, 0.3, <span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line">    <span class="keyword">auto</span> [left, right] = bio::meta::tuple_split&lt;2&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left) -&gt; std::tuple&lt;int, char&gt;; decltype(right) -&gt; std::tuple&lt;float, std::string&gt;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Split at position 0.</span></div>
<div class="line">    <span class="keyword">auto</span> [left1, right1] = bio::meta::tuple_split&lt;0&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left1) -&gt; std::tuple&lt;&gt;; decltype(right1) -&gt; std::tuple&lt;int, char, float, std::string&gt;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Split at position 4.</span></div>
<div class="line">    <span class="keyword">auto</span> [left2, right2] = bio::meta::tuple_split&lt;4&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left2) -&gt; std::tuple&lt;int, char, float, std::string&gt;; decltype(right2) -&gt; std::tuple&lt;&gt;;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Complexity</h3>
<p>Linear in the number of elements.</p>
<h3>Thread safety</h3>
<p>Concurrent invocations of this functions are thread safe.   </p>

</div>
</div>
<a id="ga102d29d8c2ddb2f663ec52c7305d695f" name="ga102d29d8c2ddb2f663ec52c7305d695f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga102d29d8c2ddb2f663ec52c7305d695f">&#9670;&#160;</a></span>tuple_split() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t pivot_c, template&lt; typename... &gt; typename tuple_t, typename... ts&gt; <br />
requires tuple_like&lt;tuple_t&lt;ts...&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::meta::tuple_split </td>
          <td>(</td>
          <td class="paramtype">tuple_t&lt; ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a tuple like data structure at the given position. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pivot_c</td><td>A template value specifying the split position. </td></tr>
    <tr><td class="paramname">tuple_t</td><td>A template alias for a tuple like object. </td></tr>
    <tr><td class="paramname">...ts</td><td>Types <code>tuple_t</code> is specified with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The original tuple to split.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tuple of tuples with the left side of the split and the right side of the split.</dd></dl>
<p>Splits a tuple into two tuples, while the element at the split position will be contained in the second tuple. Note, that the returned tuples can be empty. For this reason it is not possible to use tuple like objects, that cannot be empty, i.e. <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>. Using such an object will emit an compiler error.</p>
<h3>example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/string.html">string</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple__utility_8hpp.html">bio/meta/tuple_utility.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Split at position 2.</span></div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, char, float, std::string&gt;</a> t{1, <span class="charliteral">&#39;c&#39;</span>, 0.3, <span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line">    <span class="keyword">auto</span> [left, right] = bio::meta::tuple_split&lt;2&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left) -&gt; std::tuple&lt;int, char&gt;; decltype(right) -&gt; std::tuple&lt;float, std::string&gt;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Split at position 0.</span></div>
<div class="line">    <span class="keyword">auto</span> [left1, right1] = bio::meta::tuple_split&lt;0&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left1) -&gt; std::tuple&lt;&gt;; decltype(right1) -&gt; std::tuple&lt;int, char, float, std::string&gt;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Split at position 4.</span></div>
<div class="line">    <span class="keyword">auto</span> [left2, right2] = bio::meta::tuple_split&lt;4&gt;(t);</div>
<div class="line">    <span class="comment">// decltype(left2) -&gt; std::tuple&lt;int, char, float, std::string&gt;; decltype(right2) -&gt; std::tuple&lt;&gt;;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Complexity</h3>
<p>Linear in the number of elements.</p>
<h3>Thread safety</h3>
<p>Concurrent invocations of this functions are thread safe. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Thu Mar 30 2023 15:25:52 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
