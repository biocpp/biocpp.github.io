<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: How to write a view</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">BioC++<span id="projectnumber">&#160;0.5.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('core_custom_view.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">How to write a view </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md53">Motivation</a></li>
<li class="level1"><a href="#autotoc_md54">What makes a view?</a></li>
<li class="level1"><a href="#autotoc_md55">Custom range adaptor objects</a></li>
<li class="level1"><a href="#autotoc_md56">A full custom view implementation</a><ul><li class="level2"><a href="#autotoc_md57">1. The view class template</a></li>
<li class="level2"><a href="#autotoc_md58">2. The adaptor object</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md__usr_home_hannes_devel_biocpp_core_doc_core_write_a_view_index"></a></p>
<p >This HowTo documents how to write a view using the standard library and some helpers from BioC++.</p>
<table class="doxtable">
<tr>
<th>Difficulty</th><td>Difficult</td></tr>
<tr>
<th>Duration</th><td>120 min</td></tr>
<tr>
<th>Prerequisite tutorials</th><td><a class="el" href="core_concepts.html">C++ Concepts</a>,<a class="el" href="core_ranges.html">Ranges</a></td></tr>
<tr>
<th>Recommended reading</th><td></td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Some of the links from this HowTo only resolve in the developer documentation because they refer to entities from the bio::alphabet::detail namespace. We recommend you open this tutorial from <a href="https://docs.seqan.de/seqan/3-master-dev/" target="_blank">the developer documentation</a>.</dd></dl>
<p>//TODO update this regarding use of {fmt}</p>
<h1><a class="anchor" id="autotoc_md53"></a>
Motivation</h1>
<p >We have introduced "views" in <a class="el" href="core_ranges.html">Ranges</a>. You can do many things with the views provided by the standard library and those shipped with BioC++, but in certain situations you will want to define your own view. This page will teach you the basics of defining your own view.</p>
<h1><a class="anchor" id="autotoc_md54"></a>
What makes a view?</h1>
<p >A view is a type of <code>std::ranges::range</code> that also models <code>std::ranges::view</code>. The additional requirements of <code>std::ranges::view</code> can be vaguely summarised as "not holding any own data" or at least not holding data that is relative in size to the number of elements in the view (e.g. a vector cannot be a view, because its size in memory depends on the number of elements it represents).</p>
<p >A simple example of a view is <code>std::ranges::subrange</code>. It can be constructed from a pair of iterators or more precisely an <em>iterator</em> and a <em>sentinel</em>. <code>begin()</code> always returns an iterator, but the type returned by <code>end()</code> (the "sentinel") does not need to be of the same type as the iterator â€“ as long as they are comparable. This view then holds exactly the iterator-sentinel-pair as its state and nothing else.</p>
<p >But <code>std::ranges::subrange</code> does not yet facilitate any "composing-behaviour" that you have seen in <a class="el" href="core_ranges.html">Ranges</a> tutorial, <code>std::ranges::subrange</code> is simply a type that can be constructed from an iterator-sentinel-pair, you cannot "pipe" anything into it. Most views are adaptors on other views, e.g. <code>std::ranges::transform_view</code> wraps an existing view and applies an element-wise transformation on-demand. You can directly construct <code>std::ranges::transform_view</code> from another view or from non-view ranges that can be wrapped into a view (e.g. references to containers):</p>
<div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> l = [] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; };</div>
<div class="line"> </div>
<div class="line">std::ranges::transform_view v{vec, l};</div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><p >But this syntax gets difficult to read when you create "a view(from a view(from a view()))". That's why for every view that adapts an existing view we have an additional <em>adaptor object</em>, usually available in a <code>views::</code> sub-namespace:</p>
<div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> l = [] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> v = vec | <a class="code hl_typedef" href="group__meta__type__list.html#gaa8a3a9526cdff1ea81ae45c8209eb592">std::views::transform</a>(l);</div>
<div class="ttc" id="agroup__meta__type__list_html_gaa8a3a9526cdff1ea81ae45c8209eb592"><div class="ttname"><a href="group__meta__type__list.html#gaa8a3a9526cdff1ea81ae45c8209eb592">bio::meta::list_traits::transform</a></div><div class="ttdeci">decltype(detail::transform&lt; trait_t &gt;(list_t{})) transform</div><div class="ttdoc">Apply a transformation trait to every type in the list and return a meta::type_list of the results.</div><div class="ttdef"><b>Definition:</b> traits.hpp:524</div></div>
</div><!-- fragment --><p >This adaptor object (<code>std::views::transform</code>) provides the pipe operator and returns an object of the actual view type (<code>std::ranges::transform_view</code>). The pipe operator allows us to chain multiple adaptors similar to the unix command line. We will discuss the details of these adaptor objects in the following sections.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Custom range adaptor objects</h1>
<p >Read <a href="https://eel.is/c++draft/range.adaptors" target="_blank">section 24.7 and 24.7.1 of the C++ standard</a>.</p>
<p >The wording of the standard needs some getting used to, but some important notes for us are:</p><ol type="1">
<li>You can pipe a viewable range into series of <em>adaptor closure objects</em> and will get back a view (this is also what we did above): <div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> v = vec | <a class="code hl_typedef" href="group__meta__type__list.html#gaa8a3a9526cdff1ea81ae45c8209eb592">std::views::transform</a>([] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; })</div>
<div class="line">             | std::views::filter([] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line"><span class="comment">// v is a view, you can iterate over it!</span></div>
</div><!-- fragment --></li>
<li>The adaptor objects support function-style usage, too, although it only reduces readability: <div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> v = std::views::filter(<a class="code hl_typedef" href="group__meta__type__list.html#gaa8a3a9526cdff1ea81ae45c8209eb592">std::views::transform</a>(vec, [] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; }), [] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line"><span class="comment">// v is a view, you can iterate over it!</span></div>
</div><!-- fragment --></li>
<li>You can create a new <em>adaptor closure object</em> from an adaptor object that requires parameters by providing those: <div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> a = <a class="code hl_typedef" href="group__meta__type__list.html#gaa8a3a9526cdff1ea81ae45c8209eb592">std::views::transform</a>([] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; });</div>
<div class="line"><span class="comment">// a is an adaptor and can be used as such:</span></div>
<div class="line"><span class="keyword">auto</span> v = vec | a;</div>
</div><!-- fragment --></li>
<li>You can create a new <em>adaptor closure object</em> from existing adaptor closure objects via <code>|</code> but without providing a range: <div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> a = <a class="code hl_typedef" href="group__meta__type__list.html#gaa8a3a9526cdff1ea81ae45c8209eb592">std::views::transform</a>([] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; })</div>
<div class="line">       | std::views::filter([] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line"><span class="comment">// a is an adaptor and can be used as such:</span></div>
<div class="line"><span class="keyword">auto</span> v = vec | a;</div>
</div><!-- fragment --></li>
</ol>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Terminology   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Example    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"view"   </td><td class="markdownTableBodyNone">A type that models std::ranges::view.   </td><td class="markdownTableBodyNone"><code>std::ranges::filter_view&lt;std::subrange&lt;int const *, int const *&gt;&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"view adaptor object"   </td><td class="markdownTableBodyNone">Creates a view; can be combined with other adaptors.   </td><td class="markdownTableBodyNone"><code>std::views::reverse</code> and <br  />
 <code>std::views::filter</code> and <br  />
 <code>(std::views::filter([] (int) { return true; }))</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"view adaptor closure object"   </td><td class="markdownTableBodyNone">A "view adaptor object" that requires no paramaters other than the range.   </td><td class="markdownTableBodyNone"><code>std::views::reverse</code> and  <div style='color:red;text-decoration:line-through'><tt>std::views::filter</tt> and</div> <code>(std::views::filter([] (int) { return true; }))</code>   </td></tr>
</table>
<p >In many cases where you are planning on creating "a new view", it will be sufficient to use the previously mentioned techniques to just create "a new adaptor object" and not having to specify the actual view type yourself.</p>
<p >Let's look at some examples!</p>
<p > <div class="assignemnt"><h4>Exercise 1: Your first custom adaptor object</h4><div class="assignment_content"> In the alphabet module you learned that ranges of alphabets are not implicitly convertible to <code>char</code> so you <b>cannot</b> print a <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="classbio_1_1alphabet_1_1dna5.html" title="The five letter DNA alphabet of A,C,G,T and the unknown character N..">bio::alphabet::dna5</a>&gt;</code> via <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a></code>Â¹. You also know that you can call <code><a class="el" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0" title="Return the char representation of an alphabet object.">bio::alphabet::to_char</a></code> on every object that models <code><a class="el" href="interfacebio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a></code> which will convert it to <code>char</code> or a similar type.</p>
<p >We want to do the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="ttc" id="aalphabet_2nucleotide_2all_8hpp_html"><div class="ttname"><a href="alphabet_2nucleotide_2all_8hpp.html">all.hpp</a></div><div class="ttdoc">Meta-header for the nucleotide submodule; includes all headers from alphabet/nucleotide/.</div></div>
<div class="ttc" id="aiostream_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a></div></div>
<div class="ttc" id="anamespacebio_1_1alphabet_1_1literals_html"><div class="ttname"><a href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a></div><div class="ttdoc">An inline namespace for alphabet literals. It exists to safely allow using namespace.</div><div class="ttdef"><b>Definition:</b> aa10li.hpp:196</div></div>
<div class="ttc" id="aranges_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// your implementation goes here</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;ATTAGATTA&quot;</span>_dna5};</div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; vec[0] &lt;&lt; &#39;\n&#39;;                 // won&#39;t work</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> v = vec | my_convert_to_char_view;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; v[0] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;                      <span class="comment">// prints &quot;A&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="acout_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a></div></div>
</div><!-- fragment --><p >Define a <em>range adaptor object</em> using an existing adaptor which applies a concrete transformation (calling <a class="el" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0" title="Return the char representation of an alphabet object.">bio::alphabet::to_char</a>) on every element.</p>
<p > <div class="assignment"> <details><summary><b>Hint</b></summary>  You need to need use <code>std::views::transform</code> and you need to set a fixed transformation function. <code>std::views::transform</code> takes an object that models <code>std::regular_invocable</code>, e.g. a lambda function with empty capture <code>[]</code>.  </details> </div> </p>
<p ><small>Â¹ You <em>can</em> print via <code>bio::alphabet::debug_stream</code>, but let's ignore that for now. </small>  </div></div></p>
<p > <div class="solution"> <details><summary><b>Solution</b></summary> </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> my_convert_to_char_view = <a class="code hl_typedef" href="group__meta__type__list.html#gaa8a3a9526cdff1ea81ae45c8209eb592">std::views::transform</a>([] (<span class="keyword">auto</span> <span class="keyword">const</span> alph)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(alph);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;ATTAGATTA&quot;</span>_dna5};</div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; vec[0] &lt;&lt; &#39;\n&#39;;                 // won&#39;t work</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> v = vec | my_convert_to_char_view;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; v[0] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;                      <span class="comment">// prints &quot;A&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__alphabet_html_ga064e386f9360cca0fd3702b4957a27a0"><div class="ttname"><a href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a></div><div class="ttdeci">constexpr auto to_char</div><div class="ttdoc">Return the char representation of an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:245</div></div>
</div><!-- fragment --><p >You simply define your adaptor type as <code>auto</code> and make it behave like <code>std::views::transform</code>, except that you<br  />
"hard-code" the lambda function that is applied to each element. Since your adaptor object now takes a range as the only parameter, it is an adaptor closure object.</p>
<p >The object is marked as <code>constexpr</code> because the adaptor object itself never changes, it only provides <code>operator()</code> and <code>operator|</code> that each return a specialisation of <code>std::ranges::transformation_view</code>.  </details> </div> </p>
<p > <div class="assignemnt"><h4>Exercise 2: Combining two existing adaptor objects</h4><div class="assignment_content"></p>
<p >Study the <code><a class="el" href="interfacebio_1_1alphabet_1_1nucleotide__alphabet.html" title="A concept that indicates whether an alphabet represents nucleotides.">bio::alphabet::nucleotide_alphabet</a></code>. It states that you can call <code><a class="el" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48" title="Return the complement of a nucleotide object.">bio::alphabet::complement</a></code> on all nucleotides which will give you <code>'A'_dna5</code> for <code>'T'_dna5</code> a.s.o. Think about how you can adapt the previous solution to write a view that transforms ranges of nucleotides into their complement.</p>
<p >BUT, we are also interested in <em>reversing</em> the range which is possible with <code>std::views::reverse</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="ttc" id="afmt_8hpp_html"><div class="ttname"><a href="fmt_8hpp.html">fmt.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// your implementation goes here</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;ACCAGATTA&quot;</span>_dna5};</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, vec);                     <span class="comment">// prints &quot;ACCAGATTA&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> v = vec | my_reverse_complement;</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, v);                       <span class="comment">// prints &quot;TAATCTGGT&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Define a <em>range adaptor object</em> that presents a view of the reverse complement of whatever you pipe into it.  </div></div></p>
<p > <div class="solution"> <details><summary><b>Solution</b></summary> </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> my_reverse_complement = std::views::reverse | <a class="code hl_typedef" href="group__meta__type__list.html#gaa8a3a9526cdff1ea81ae45c8209eb592">std::views::transform</a>(<a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;ACCAGATTA&quot;</span>_dna5};</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, vec);                     <span class="comment">// prints &quot;ACCAGATTA&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> v = vec | my_reverse_complement;</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, v);                       <span class="comment">// prints &quot;TAATCTGGT&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__nucleotide_html_ga174261f8f888bbce628ffe01097a9b48"><div class="ttname"><a href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a></div><div class="ttdeci">constexpr auto complement</div><div class="ttdoc">Return the complement of a nucleotide object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:83</div></div>
</div><!-- fragment --><p >The adaptor consists of <code>std::views::reverse</code> combined with <code>std::views::transform</code>. This time the lambda just performs the call to <code><a class="el" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48" title="Return the complement of a nucleotide object.">bio::alphabet::complement</a></code>.  </details> </div> </p>
<h1><a class="anchor" id="autotoc_md56"></a>
A full custom view implementation</h1>
<p >Using existing adaptors only works to a certain degree, sometimes you will need to implement a full view. As we have seen above, it is easy to implement a view that presents the complement of a nucleotide range just using existing adaptors. For simplicity, we will still use this as an example and implement a non-generic transform view in the next steps.</p>
<p >A full view implementation typically consists of the following components:</p>
<ol type="1">
<li>The view class template that takes the underlying range as a template parameter.<ul>
<li>The class should be derived from <code>std::ranges::view_interface</code> which will take care of a lot of boilerplate for us.</li>
<li>The actual functionality of the view is implemented in its iterator and sentinel.</li>
</ul>
</li>
<li>The <em>adaptor object</em> which allows for the piping behaviour.</li>
</ol>
<h2><a class="anchor" id="autotoc_md57"></a>
1. The view class template</h2>
<p >A good thing to start with is to think about the iterator and the sentinel of your view. The iterator and/or its relation to the sentinel is the way we implement the behaviour that is specific to our view. We will start with implementing the iterator separately and later integrate it into the view.</p>
<h3>Iterator</h3>
<p >Since we know that in our current usecase we have exactly one element in our view for every element in the underlying range, we don't need to change the relation between iterator and sentinel, i.e. "begin == end" on our view iff "begin == end" on the underlying range. This indicates that we can use the sentinel of the underlying range as-is.</p>
<p > <div class="assignemnt"><h4>Exercise 3: Your first iterator</h4><div class="assignment_content"></p>
<p >Have a peak at the <a class="el" href="core_concepts.html">C++ Concepts</a> tutorial again and study the <code>std::forward_iterator</code> concept thoroughly. You will now have to implement your own forward iterator.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::forward_range urng_t&gt; <span class="comment">// the underlying range type</span></div>
<div class="line"><span class="keyword">struct </span>my_iterator : std::ranges::iterator_t&lt;urng_t&gt;</div>
<div class="line">{</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// YOUR IMPLEMENTATION GOES HERE (OPERATORS, MEMBER TYPES...)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// verify that your type models the concept</span></div>
<div class="line"><span class="keyword">static_assert</span>(std::forward_iterator&lt;my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;GATTACA&quot;</span>_dna5};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// instantiate the template over the underlying vector&#39;s iterator and sentinel</span></div>
<div class="line">    <span class="comment">// (for all standard containers the sentinel type is the same as the iterator type)</span></div>
<div class="line">    <span class="keyword">using </span>my_it_concrete = my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create an iterator that is constructed with vec.begin() as the underlying iterator</span></div>
<div class="line">    my_it_concrete it{vec.<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector/begin.html">begin</a>()};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// iterate over vec, but with your custom iterator</span></div>
<div class="line">    <span class="keywordflow">while</span> (it != vec.end())</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(*it++) &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="abegin_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/container/vector/begin.html">std::vector::begin</a></div><div class="ttdeci">T begin(T... args)</div></div>
</div><!-- fragment --><p >In order to re-use functionality of the underlying range's iterator type you can inherit from it (<code>std::ranges::iterator_t</code> returns the iterator type).Â¹ In the end, you should be able to iterate over the underlying range and print elements like you would with the original iterator, i.e. your iterator shall behave exactly as the original in this regard (no transformation, yet).</p>
<p >Some things to keep in mind for the implementation:</p><ul>
<li>When defining a type template (like above), member <b>types</b> are not inherited implicitly (member functions are).</li>
<li>Another reason "just inheriting" is not sufficient, is that some inherited functions return objects or references to the base type, not your type (which is required by the <code>std::forward_iterator</code> concept).</li>
<li>If you choose to wrap the underlying iterator instead of inheriting, you will need to define and "forward" a few more member functions, but it's good practice and will help you understand the concept.</li>
<li>The <code>static_assert</code> will just return <code>true</code> or <code>false</code>, to get more detailed information on why your type does not (yet) model the concept, implement a constrained function template and pass an object of your type to that template.</li>
<li>Your iterator needs to be comparable to the sentinel of the underlying range, you can access that type via <code>std::ranges::sentinel_t&lt;urng_t&gt;</code>.</li>
</ul>
<p ><small>Â¹ In some situations it might be better to wrap the underlying iterator instead of inheriting it, i.e. save a copy of the underlying iterator as a data member of your iterator. A reason could be that you <em>don't</em> want to inherit some members or want to prevent implicit convertibility.</small></p>
<p > </div></div></p>
<p > <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::forward_range urng_t&gt; <span class="comment">// the underlying range type</span></div>
<div class="line"><span class="keyword">struct </span>my_iterator : std::ranges::iterator_t&lt;urng_t&gt;</div>
<div class="line">{</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">using </span>base_t = std::ranges::iterator_t&lt;urng_t&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// these member types are just exposed from the base type</span></div>
<div class="line">    <span class="keyword">using </span>value_type            = <span class="keyword">typename</span> <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iterator_traits.html">std::iterator_traits&lt;base_t&gt;::value_type</a>;</div>
<div class="line">    <span class="keyword">using </span>pointer               = <span class="keyword">typename</span> <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iterator_traits.html">std::iterator_traits&lt;base_t&gt;::pointer</a>;</div>
<div class="ttc" id="aiterator_traits_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/iterator/iterator_traits.html">std::iterator_traits</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">using </span>reference             = <span class="keyword">typename</span> <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iterator_traits.html">std::iterator_traits&lt;base_t&gt;::reference</a>;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// this member type is explicitly set to forward_iterator_tag because we are not</span></div>
<div class="line">    <span class="comment">// implementing the remaining requirements</span></div>
<div class="line">    <span class="keyword">using </span>iterator_category     = <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iterator_tags.html">std::forward_iterator_tag</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the following operators need to be explicitly defined, because the inherited</span></div>
<div class="line">    <span class="comment">// version has wrong return types (base_t instead of my_iterator)</span></div>
<div class="line">    my_iterator &amp; operator++()</div>
<div class="line">    {</div>
<div class="line">        base_t::operator++();       <span class="comment">// call the implementation of the base type</span></div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    my_iterator operator++(<span class="keywordtype">int</span>)</div>
<div class="line">    {</div>
<div class="line">        my_iterator cpy{*<span class="keyword">this</span>};</div>
<div class="line">        ++(*this);</div>
<div class="line">        <span class="keywordflow">return</span> cpy;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we do not need to define constructors, because {}-initialising this with one argument</span></div>
<div class="line">    <span class="comment">// calls the base-class&#39;s constructor which is what we want</span></div>
<div class="line">    <span class="comment">// NOTE: depending on your view/iterator, you might need/want to define your own</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we do not need to define comparison operators, because there are comparison operators</span></div>
<div class="line">    <span class="comment">// for the base class and our type is implicitly convertible to the base type</span></div>
<div class="line">    <span class="comment">// NOTE: in our case comparing the converted-to-base iterator with end behaves as desired,</span></div>
<div class="line">    <span class="comment">// but it strongly depends on your view/iterator whether the same holds</span></div>
<div class="ttc" id="aiterator_tags_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags.html">std::forward_iterator_tag</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// verify that your type models the concept</span></div>
<div class="line"><span class="keyword">static_assert</span>(std::forward_iterator&lt;my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;GATTACA&quot;</span>_dna5};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// instantiate the template over the underlying vector&#39;s iterator and sentinel</span></div>
<div class="line">    <span class="comment">// (for all standard containers the sentinel type is the same as the iterator type)</span></div>
<div class="line">    <span class="keyword">using </span>my_it_concrete = my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create an iterator that is constructed with vec.begin() as the underlying iterator</span></div>
<div class="line">    my_it_concrete it{vec.<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector/begin.html">begin</a>()};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// iterate over vec, but with your custom iterator</span></div>
<div class="line">    <span class="keywordflow">while</span> (it != vec.end())</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(*it++) &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p >The program prints "G A T T A C A ".  </details> </div> </p>
<p > <div class="assignemnt"><h4>Exercise 4: A transforming iterator</h4><div class="assignment_content"></p>
<p >In the previous assigment you have created a working â€“ but pointless â€“ iterator. It does not do anything differently from the original.</p>
<p >Your task now is to implement the "complementing" behaviour, i.e.</p><ul>
<li>your iterator should only work on ranges of <code><a class="el" href="interfacebio_1_1alphabet_1_1nucleotide__alphabet.html" title="A concept that indicates whether an alphabet represents nucleotides.">bio::alphabet::nucleotide_alphabet</a></code></li>
<li>when accessing an element through the iterator it should not return the element from the underlying range but instead its complement</li>
</ul>
<p >Think about which operator is responsible for returning the element and be careful with the return type of that operator as your transformation might make a change necessary.  </div></div></p>
<p > <div class="solution"> <details><summary><b>Solution</b></summary> </p>
<ol type="1">
<li>The restriction on the alphabet type is done via a <code>static_assert</code>: <div class="fragment"><div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_interface" href="interfacebio_1_1alphabet_1_1nucleotide__alphabet.html">bio::alphabet::nucleotide_alphabet&lt;std::ranges::range_reference_t&lt;urng_t&gt;</a>&gt;,</div>
<div class="line">                  <span class="stringliteral">&quot;You can only iterate over ranges of nucleotides!&quot;</span>);</div>
<div class="ttc" id="ainterfacebio_1_1alphabet_1_1nucleotide__alphabet_html"><div class="ttname"><a href="interfacebio_1_1alphabet_1_1nucleotide__alphabet.html">nucleotide_alphabet</a></div><div class="ttdoc">A concept that indicates whether an alphabet represents nucleotides.</div></div>
</div><!-- fragment --> You could have done this via an additional template constraint, too, but <code>static_assert</code> gives you the opportunity to give a readable message in case of an error.Â¹</li>
<li>The operator that needs to call the <code><a class="el" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48" title="Return the complement of a nucleotide object.">bio::alphabet::complement</a></code> function is <code>operator*</code>: <div class="fragment"><div class="line">    <span class="comment">// The operator* facilitates the access to the element.</span></div>
<div class="line">    <span class="comment">// This implementation calls the base class&#39;s implementation but passes the return value</span></div>
<div class="line">    <span class="comment">// through the bio::alphabet::complement() function before returning it.</span></div>
<div class="line">    reference operator*()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>(base_t::operator*());</div>
<div class="line">    }</div>
</div><!-- fragment --></li>
<li>As previously noted, care needs to be taken with this function's return type: <div class="fragment"><div class="line">    <span class="comment">// If the value_type is bio::alphabet::dna5, the reference type of the vector is</span></div>
<div class="line">    <span class="comment">// bio::alphabet::dna5 &amp; and operator* returns this so you can change the values</span></div>
<div class="line">    <span class="comment">// in the vector through it&#39;s iterator.</span></div>
<div class="line">    <span class="comment">// This won&#39;t work anymore, because now we are creating new values on access</span></div>
<div class="line">    <span class="comment">// so we now need to change this type to reflect that:</span></div>
<div class="line">    <span class="keyword">using </span>reference             = value_type;</div>
</div><!-- fragment --></li>
</ol>
<p >Here is the full solution:  <div class="assignment"> <details><summary><b>Hint</b></summary>  </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::forward_range urng_t&gt; <span class="comment">// the underlying range type</span></div>
<div class="line"><span class="keyword">struct </span>my_iterator : std::ranges::iterator_t&lt;urng_t&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_interface" href="interfacebio_1_1alphabet_1_1nucleotide__alphabet.html">bio::alphabet::nucleotide_alphabet&lt;std::ranges::range_reference_t&lt;urng_t&gt;</a>&gt;,</div>
<div class="line">                  <span class="stringliteral">&quot;You can only iterate over ranges of nucleotides!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>base_t = std::ranges::iterator_t&lt;urng_t&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// these member types are just exposed from the base type</span></div>
<div class="line">    <span class="keyword">using </span>value_type            = <span class="keyword">typename</span> <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iterator_traits.html">std::iterator_traits&lt;base_t&gt;::value_type</a>;</div>
<div class="line">    <span class="keyword">using </span>pointer               = <span class="keyword">typename</span> <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iterator_traits.html">std::iterator_traits&lt;base_t&gt;::pointer</a>;</div>
<div class="line">    <span class="comment">// If the value_type is bio::alphabet::dna5, the reference type of the vector is</span></div>
<div class="line">    <span class="comment">// bio::alphabet::dna5 &amp; and operator* returns this so you can change the values</span></div>
<div class="line">    <span class="comment">// in the vector through it&#39;s iterator.</span></div>
<div class="line">    <span class="comment">// This won&#39;t work anymore, because now we are creating new values on access</span></div>
<div class="line">    <span class="comment">// so we now need to change this type to reflect that:</span></div>
<div class="line">    <span class="keyword">using </span>reference             = value_type;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// this member type is explicitly set to forward_iterator_tag because we are not</span></div>
<div class="line">    <span class="comment">// implementing the remaining requirements</span></div>
<div class="line">    <span class="keyword">using </span>iterator_category     = <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/iterator_tags.html">std::forward_iterator_tag</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the following operators need to be explicitly defined, because the inherited</span></div>
<div class="line">    <span class="comment">// version has wrong return types (base_t instead of my_iterator)</span></div>
<div class="line">    my_iterator &amp; operator++()</div>
<div class="line">    {</div>
<div class="line">        base_t::operator++();       <span class="comment">// call the implementation of the base type</span></div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    my_iterator operator++(<span class="keywordtype">int</span>)</div>
<div class="line">    {</div>
<div class="line">        my_iterator cpy{*<span class="keyword">this</span>};</div>
<div class="line">        ++(*this);</div>
<div class="line">        <span class="keywordflow">return</span> cpy;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we do not need to define constructors, because {}-initialising this with one argument</span></div>
<div class="line">    <span class="comment">// calls the base-class&#39;s constructor which is what we want</span></div>
<div class="line">    <span class="comment">// NOTE: depending on your view/iterator, you might need/want to define your own</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we do not need to define comparison operators, because there are comparison operators</span></div>
<div class="line">    <span class="comment">// for the base class and our type is implicitly convertible to the base type</span></div>
<div class="line">    <span class="comment">// NOTE: in our case comparing the converted-to-base iterator with end behaves as desired,</span></div>
<div class="line">    <span class="comment">// but it strongly depends on your view/iterator whether the same holds</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    <span class="comment">// The operator* facilitates the access to the element.</span></div>
<div class="line">    <span class="comment">// This implementation calls the base class&#39;s implementation but passes the return value</span></div>
<div class="line">    <span class="comment">// through the bio::alphabet::complement() function before returning it.</span></div>
<div class="line">    reference operator*()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>(base_t::operator*());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// verify that your type models the concept</span></div>
<div class="line"><span class="keyword">static_assert</span>(std::forward_iterator&lt;my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;GATTACA&quot;</span>_dna5};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// instantiate the template over the underlying vector&#39;s iterator and sentinel</span></div>
<div class="line">    <span class="comment">// (for all standard containers the sentinel type is the same as the iterator type)</span></div>
<div class="line">    <span class="keyword">using </span>my_it_concrete = my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create an iterator that is constructed with vec.begin() as the underlying iterator</span></div>
<div class="line">    my_it_concrete it{vec.<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector/begin.html">begin</a>()};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// iterate over vec, but with your custom iterator</span></div>
<div class="line">    <span class="keywordflow">while</span> (it != vec.end())</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(*it++) &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p >The program prints "C T A A T G T "</p>
<p > </details> </div> </p>
<p ><small>Â¹ This is only recommended when you do <em>not</em> want to allow a different specialisation of the template to cover the excluded case.</small></p>
<p > </details> </div> </p>
<p >You now have a working iterator, although it still lacks the capabilities of <code>std::bidirectional_iterator</code>, <code>std::random_access_iterator</code> and <code>std::contiguous_iterator</code>. When designing views, you should always strive to preserve as much of the capabilities of the underlying range as possible.</p>
<p >Which of the mentioned concepts do you think your iterator could be made to implement? Have a look at the respective documentation.</p>
<p > <div class="assignment"> <details><summary><b>Hint</b></summary>  It could be designed to be a <code>std::random_access_iterator</code> (and thus also <code>std::bidirectional_iterator</code>) when the underlying range is, because jumping on your iterator/view can be done in constant time iff it can be done in constant time on the underlying range (you just jump to the n-th element of the underlying range and perform your transformation one that).</p>
<p >However, it can never model <code>std::contiguous_iterator</code> because that would imply that the elements are adjacent to each other in memory (the elements of our view are created on demand and are not stored in memory).  </details> </div> </p>
<p >If you have looked at the <code>std::random_access_iterator</code>, you will have seen that it is quite a bit of work to implement all the operators, many of whom just need to be overloaded to fix the return type. To make this a little bit easier BioC++ provides <code>bio::ranges::detail::inherited_iterator_base</code>, it fixes the issue with the return type via CRTP. A solution to the previous exercise looks like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="inherited__iterator__base_8hpp.html">bio/ranges/detail/inherited_iterator_base.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The iterator template */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::forward_range urng_t&gt;            <span class="comment">// CRTP derivation â†“</span></div>
<div class="line"><span class="keyword">class </span>my_iterator : <span class="keyword">public</span> bio::ranges::detail::inherited_iterator_base&lt;my_iterator&lt;urng_t&gt;,</div>
<div class="line">                                                                std::ranges::iterator_t&lt;urng_t&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_interface" href="interfacebio_1_1alphabet_1_1nucleotide__alphabet.html">bio::alphabet::nucleotide_alphabet&lt;std::ranges::range_reference_t&lt;urng_t&gt;</a>&gt;,</div>
<div class="line">                  <span class="stringliteral">&quot;You can only iterate over ranges of nucleotides!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the immediate base type is the CRTP-layer</span></div>
<div class="line">    <span class="keyword">using </span>base_t = bio::ranges::detail::inherited_iterator_base&lt;my_iterator&lt;urng_t&gt;,</div>
<div class="line">                                                        std::ranges::iterator_t&lt;urng_t&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// the member types are never imported automatically, but can be explicitly inherited:</span></div>
<div class="line">    <span class="keyword">using </span>typename base_t::value_type;</div>
<div class="line">    <span class="keyword">using </span>typename base_t::difference_type;</div>
<div class="line">    <span class="keyword">using </span>typename base_t::iterator_category;</div>
<div class="line">    <span class="comment">// this member type is overwritten as we do above:</span></div>
<div class="line">    <span class="keyword">using </span>reference = value_type;</div>
<div class="line">    <span class="comment">// Explicitly set the pointer to void as we return a temporary.</span></div>
<div class="line">    <span class="keyword">using </span>pointer = void;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// define rule-of-six:</span></div>
<div class="line">    my_iterator() = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator(my_iterator <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator(my_iterator &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator &amp; operator=(my_iterator <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator &amp; operator=(my_iterator &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    ~my_iterator() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="comment">// and a constructor that takes the base_type:</span></div>
<div class="line">    my_iterator(base_t it) : base_t{std::<a class="code hl_variable" href="group__views.html#gacc149746c0b9a2f5021709858f37de1b">move</a>(it)} {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we don&#39;t need to implement the ++ operators anymore!</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// only overload the operators that you actually wish to change:</span></div>
<div class="line">    reference operator*() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>(base_t::operator*());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since the reference type changed we might as well need to override the subscript-operator.</span></div>
<div class="line">    reference operator[](difference_type <span class="keyword">const</span> n) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line">        <span class="keyword">requires</span> std::random_access_iterator&lt;std::ranges::iterator_t&lt;urng_t&gt;&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>(base_t::operator[](n));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We delete arrow operator because of the temporary. An alternative could be to return the temporary</span></div>
<div class="line">    <span class="comment">// wrapped in a std::unique_ptr.</span></div>
<div class="line">    pointer operator-&gt;() const noexcept = delete;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The inherited_iterator_base creates the necessary code so we also model RandomAccess now!</span></div>
<div class="line">static_assert(std::random_access_iterator&lt;my_iterator&lt;std::vector&lt;<a class="code hl_namespace" href="namespacebio.html">bio</a>::<a class="code hl_interface" href="interfacebio_1_1alphabet_1_1alphabet.html">alphabet</a>::<a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">dna5</a>&gt;&gt;&gt;);</div>
<div class="ttc" id="aclassbio_1_1alphabet_1_1dna5_html"><div class="ttname"><a href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a></div><div class="ttdoc">The five letter DNA alphabet of A,C,G,T and the unknown character N..</div><div class="ttdef"><b>Definition:</b> dna5.hpp:50</div></div>
<div class="ttc" id="agroup__views_html_gacc149746c0b9a2f5021709858f37de1b"><div class="ttname"><a href="group__views.html#gacc149746c0b9a2f5021709858f37de1b">bio::ranges::views::move</a></div><div class="ttdeci">auto const move</div><div class="ttdoc">A view that turns lvalue-references into rvalue-references.</div><div class="ttdef"><b>Definition:</b> move.hpp:70</div></div>
<div class="ttc" id="ainherited__iterator__base_8hpp_html"><div class="ttname"><a href="inherited__iterator__base_8hpp.html">inherited_iterator_base.hpp</a></div><div class="ttdoc">Provides the bio::ranges::detail::inherited_iterator_base template.</div></div>
<div class="ttc" id="ainterfacebio_1_1alphabet_1_1alphabet_html"><div class="ttname"><a href="interfacebio_1_1alphabet_1_1alphabet.html">alphabet</a></div><div class="ttdoc">The generic alphabet concept that covers most data types used in ranges.</div></div>
<div class="ttc" id="anamespacebio_html"><div class="ttname"><a href="namespacebio.html">bio</a></div><div class="ttdoc">The main BioC++ namespace.</div><div class="ttdef"><b>Definition:</b> char.hpp:33</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;GATTACA&quot;</span>_dna5};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* try the iterator */</span></div>
<div class="line">    <span class="keyword">using </span>my_it_concrete = my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    my_it_concrete it{vec.<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector/begin.html">begin</a>()};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// now you can use operator[] on the iterator</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 7; ++i)</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(it[i]) &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">}</div>
</div><!-- fragment --><h3>The view class</h3>
<p >We now implement the view in several steps:</p>
<div class="fragment"><div class="line"><span class="comment">/* The view class template */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::view urng_t&gt;  <span class="comment">// CRTP derivation â†“</span></div>
<div class="line"><span class="keyword">class </span>my_view : <span class="keyword">public</span> std::ranges::view_interface&lt;my_view&lt;urng_t&gt;&gt;</div>
<div class="line">{</div>
</div><!-- fragment --><p >Like the iterator, the view is derived from a CRTP base class that takes care of defining many members for us, e.g. <code>.<a class="el" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d" title="A type trait that holds the size of a (semi-)alphabet.">size()</a></code>, <code>.operator[]</code> and a few others.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// this is the underlying range</span></div>
<div class="line">    urng_t urange;</div>
</div><!-- fragment --><p >The only data member the class holds is a copy of the underlying range. As you may have noted above, our class only takes underlying ranges that model std::ranges::view. This might seem strange; after all we want to apply the view to a vector of which we know that it is not a view, but we will clear this up later.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Types of the iterators</span></div>
<div class="line">    <span class="keyword">using </span>iterator = my_iterator&lt;urng_t&gt;;</div>
<div class="line">    <span class="keyword">using </span>const_iterator = my_iterator&lt;urng_t const&gt;;</div>
</div><!-- fragment --><p >The only member types that we define here are the definitions of the iterators which are just the iterator we have defined before. Note that we have <code>const_iterator</code> in addition to <code>iterator</code> which const-qualified member functions return, because in a const-context the <code>urange</code> data member will be const so we cannot return the mutable <code>iterator</code> from it.</p>
<p >Many ranges like the standard library containers also present the member types of the iterator, i.e. <code>value_type</code>, <code>reference</code> a.s.o, but this is not required to model any of the range concepts.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> begin() noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/begin.html">begin</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> const_iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/begin.html">cbegin</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> const_iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
</div><!-- fragment --><p >These functions are the same member functions you know from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code>, they return objects of the previously defined iterator types that are initialised with the begin iterator from the underlying range.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> end() noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> end() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/end.html">cend</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
<div class="ttc" id="aend_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/iterator/end.html">std::cend</a></div><div class="ttdeci">T cend(T... args)</div></div>
</div><!-- fragment --><p >The implementation for <code>end()</code> is similar except that for our range the sentinel type (the return type of <code>end()</code>) is the same as of the underlying range, we just pass it through.</p>
<p >For many more complex views you will have to define the sentinel type yourself or derive it from the underlying type in a similar manner to how we derived the iterator type. Often you can use <code>std::default_sentinel_t</code> as the type for your sentinel and implement the<br  />
"end-condition" in the iterator's equality comparison operator against that type.</p>
<div class="fragment"><div class="line">    my_view()                            = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view(my_view <span class="keyword">const</span> &amp;)             = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view(my_view &amp;&amp;)                  = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view &amp; operator=(my_view <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view &amp; operator=(my_view &amp;&amp;)      = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// construct from a view</span></div>
<div class="line">    my_view(urng_t urange_) : urange{std::<a class="code hl_variable" href="group__views.html#gacc149746c0b9a2f5021709858f37de1b">move</a>(urange_)}</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// construct from the underlying type (works together with the deduction guide)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;std::constructible_from&lt;urng_t&gt; orng_t&gt;</div>
<div class="line">    my_view(orng_t &amp;&amp; urange_) : urange{std::forward&lt;orng_t&gt;(urange_)}</div>
<div class="line">    {}</div>
</div><!-- fragment --><p >We have two constructors, one that takes an the underlying type by copy and moves it into the data member (remember that since it is a view, it will not be expensive to copy â€“ if it is copied).</p>
<p >The second constructor is more interesting, it takes a <code>std::ranges::viewable_range</code> which is defined as being either a <code>std::ranges::view</code> or a reference to <code>std::ranges::range</code> that is not a view (e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;char&gt; &amp;</code>). Since we have a constructor for <code>std::ranges::view</code> already, this one explicitly handles the second case and goes through <code>std::views::all</code> which wraps the reference in a thin view-layer. Storing only a view member guarantess that our type itself is also cheap to copy among other things.</p>
<p >Note that both of these constructors seem like generic functions, but they just handle the underlying type or a type that turns into the underlying when wrapped in <code>std::views::all</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// A deduction guide for the view class template</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::viewable_range orng_t&gt;</div>
<div class="line">my_view(orng_t &amp;&amp;) -&gt; my_view&lt;std::views::all_t&lt;orng_t&gt;&gt;;</div>
</div><!-- fragment --><p >To easily use the second constructor we need to provide a type deduction guide.</p>
<p >Here is the full solution:  <div class="assignment"> <details><summary><b>Hint</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="inherited__iterator__base_8hpp.html">bio/ranges/detail/inherited_iterator_base.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The iterator template */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::forward_range urng_t&gt;            <span class="comment">// CRTP derivation â†“</span></div>
<div class="line"><span class="keyword">class </span>my_iterator : <span class="keyword">public</span> bio::ranges::detail::inherited_iterator_base&lt;my_iterator&lt;urng_t&gt;,</div>
<div class="line">                                                                std::ranges::iterator_t&lt;urng_t&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_interface" href="interfacebio_1_1alphabet_1_1nucleotide__alphabet.html">bio::alphabet::nucleotide_alphabet&lt;std::ranges::range_reference_t&lt;urng_t&gt;</a>&gt;,</div>
<div class="line">                  <span class="stringliteral">&quot;You can only iterate over ranges of nucleotides!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the immediate base type is the CRTP-layer</span></div>
<div class="line">    <span class="keyword">using </span>base_t = bio::ranges::detail::inherited_iterator_base&lt;my_iterator&lt;urng_t&gt;,</div>
<div class="line">                                                        std::ranges::iterator_t&lt;urng_t&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// the member types are never imported automatically, but can be explicitly inherited:</span></div>
<div class="line">    <span class="keyword">using </span>typename base_t::value_type;</div>
<div class="line">    <span class="keyword">using </span>typename base_t::difference_type;</div>
<div class="line">    <span class="keyword">using </span>typename base_t::iterator_category;</div>
<div class="line">    <span class="comment">// this member type is overwritten as we do above:</span></div>
<div class="line">    <span class="keyword">using </span>reference = value_type;</div>
<div class="line">    <span class="comment">// Explicitly set the pointer to void as we return a temporary.</span></div>
<div class="line">    <span class="keyword">using </span>pointer = void;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// define rule-of-six:</span></div>
<div class="line">    my_iterator() = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator(my_iterator <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator(my_iterator &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator &amp; operator=(my_iterator <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator &amp; operator=(my_iterator &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    ~my_iterator() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="comment">// and a constructor that takes the base_type:</span></div>
<div class="line">    my_iterator(base_t it) : base_t{std::<a class="code hl_variable" href="group__views.html#gacc149746c0b9a2f5021709858f37de1b">move</a>(it)} {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we don&#39;t need to implement the ++ operators anymore!</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// only overload the operators that you actually wish to change:</span></div>
<div class="line">    reference operator*() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>(base_t::operator*());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since the reference type changed we might as well need to override the subscript-operator.</span></div>
<div class="line">    reference operator[](difference_type <span class="keyword">const</span> n) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line">        <span class="keyword">requires</span> std::random_access_iterator&lt;std::ranges::iterator_t&lt;urng_t&gt;&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>(base_t::operator[](n));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We delete arrow operator because of the temporary. An alternative could be to return the temporary</span></div>
<div class="line">    <span class="comment">// wrapped in a std::unique_ptr.</span></div>
<div class="line">    pointer operator-&gt;() const noexcept = delete;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The inherited_iterator_base creates the necessary code so we also model RandomAccess now!</span></div>
<div class="line">static_assert(std::random_access_iterator&lt;my_iterator&lt;std::vector&lt;<a class="code hl_namespace" href="namespacebio.html">bio</a>::<a class="code hl_interface" href="interfacebio_1_1alphabet_1_1alphabet.html">alphabet</a>::<a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">dna5</a>&gt;&gt;&gt;);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* The view class template */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::view urng_t&gt;  <span class="comment">// CRTP derivation â†“</span></div>
<div class="line"><span class="keyword">class </span>my_view : <span class="keyword">public</span> std::ranges::view_interface&lt;my_view&lt;urng_t&gt;&gt;</div>
<div class="line">{</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// this is the underlying range</span></div>
<div class="line">    urng_t urange;</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Types of the iterators</span></div>
<div class="line">    <span class="keyword">using </span>iterator = my_iterator&lt;urng_t&gt;;</div>
<div class="line">    <span class="keyword">using </span>const_iterator = my_iterator&lt;urng_t const&gt;;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    my_view()                            = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view(my_view <span class="keyword">const</span> &amp;)             = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view(my_view &amp;&amp;)                  = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view &amp; operator=(my_view <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view &amp; operator=(my_view &amp;&amp;)      = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// construct from a view</span></div>
<div class="line">    my_view(urng_t urange_) : urange{std::<a class="code hl_variable" href="group__views.html#gacc149746c0b9a2f5021709858f37de1b">move</a>(urange_)}</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// construct from the underlying type (works together with the deduction guide)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;std::constructible_from&lt;urng_t&gt; orng_t&gt;</div>
<div class="line">    my_view(orng_t &amp;&amp; urange_) : urange{std::forward&lt;orng_t&gt;(urange_)}</div>
<div class="line">    {}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> begin() noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/begin.html">begin</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> const_iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/begin.html">cbegin</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> const_iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> end() noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> end() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/end.html">cend</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
</div><!-- fragment --> <div class="fragment"><div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// A deduction guide for the view class template</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::viewable_range orng_t&gt;</div>
<div class="line">my_view(orng_t &amp;&amp;) -&gt; my_view&lt;std::views::all_t&lt;orng_t&gt;&gt;;</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;GATTACA&quot;</span>_dna5};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* try the iterator */</span></div>
<div class="line">    <span class="keyword">using </span>my_it_concrete = my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    my_it_concrete it{vec.<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector/begin.html">begin</a>()};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// now you can use operator[] on the iterator</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 7; ++i)</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(it[i]) &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">/* try the range */</span></div>
<div class="line">    my_view v{vec};</div>
<div class="line">    <span class="keyword">static_assert</span>(std::ranges::random_access_range&lt;<span class="keyword">decltype</span>(v)&gt;);</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;\n{}\n&quot;</span>, v);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">}</div>
</div><!-- fragment --><p >The program prints </p><div class="fragment"><div class="line">C T A A T G T</div>
<div class="line">CTAATGT</div>
</div><!-- fragment --><p>  </details> </div> </p>
<h2><a class="anchor" id="autotoc_md58"></a>
2. The adaptor object</h2>
<p >The <em>adaptor object</em> is a <em>function object</em> also called functor. This means we define a type with the respective operators and then create a global instance of that type which can be used to invoke the actual functionality.</p>
<h3>Adaptor type definition</h3>
<p >The adaptor has the primary purpose of facilitating the piping behaviour, but it shall also allow for function/constructor-style creation of view objects, therefore it defines two operators:</p>
<div class="fragment"><div class="line"><span class="comment">/* The adaptor object&#39;s type definition */</span></div>
<div class="line"><span class="keyword">struct </span>my_view_fn</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;std::ranges::input_range urng_t&gt;</div>
<div class="line">    <span class="keyword">auto</span> operator()(urng_t &amp;&amp; urange)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> my_view{std::forward&lt;urng_t&gt;(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;std::ranges::input_range urng_t&gt;</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> <a class="code hl_function" href="namespacebio_1_1alphabet.html#aeb4e6ec76811b98d61d0eeddb113b004">operator|</a>(urng_t &amp;&amp; urange, my_view_fn <span class="keyword">const</span> &amp;)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> my_view{std::forward&lt;urng_t&gt;(urange)};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="anamespacebio_1_1alphabet_html_aeb4e6ec76811b98d61d0eeddb113b004"><div class="ttname"><a href="namespacebio_1_1alphabet.html#aeb4e6ec76811b98d61d0eeddb113b004">bio::alphabet::operator|</a></div><div class="ttdeci">constexpr translation_frames operator|(translation_frames lhs, translation_frames rhs) noexcept</div><div class="ttdoc">Binary operators for bio::alphabet::translation_frames.</div><div class="ttdef"><b>Definition:</b> translation.hpp:111</div></div>
</div><!-- fragment --><p >The first operator is very straight-forward, it simply delegates to the constructor of our view so that <code>views::my(FOO)</code> is identical to <code>my_view{FOO}</code>.</p>
<p >The second operator is declared as friend, because the left-hand-side of the <code>operator|</code> is generic, it's how the range is handled in snippets like <code>auto v = vec | views::my</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This adaptor type does not yet provide the ability to combine multiple adaptors into a new adaptor, it only handles ranges as left-hand-side input to <code>operator|</code>.</dd></dl>
<p>Our example adaptor type definition is rather simple, but for views/adaptors that take more parameters it gets quite complicated quickly. Therefore BioC++ provides some convenience templates for you: </p><div class="fragment"><div class="line"><span class="comment">// in our example, this is all you need:</span></div>
<div class="line"><span class="comment">//                                      your view type goes here â†“</span></div>
<div class="line"><span class="keyword">using </span>my_view_fn = bio::ranges::detail::adaptor_for_view_without_args&lt;my_view&gt;;</div>
</div><!-- fragment --><p >See <code>bio::ranges::detail::adaptor_base</code>, <code>bio::ranges::detail::adaptor_for_view_without_args</code> and <code>bio::ranges::detail::adaptor_from_functor</code> for more details.</p>
<h3>Adaptor object definition</h3>
<p >The adaptor object is simply an instance of the previously defined type:</p>
<div class="fragment"><div class="line"><span class="comment">/* The adaptor object&#39;s definition */</span></div>
<div class="line"><span class="keyword">namespace </span>views</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> my_view_fn my{};</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p >As noted above, we place this object in a <code>views::</code> sub-namespace by convention. Since the object holds no state, we mark it as <code>constexpr</code> and since it's a global variable we also mark it as <code>inline</code> to prevent linkage issues.</p>
<p >Finally we can use our view with pipes and combine it with others:</p>
<div class="fragment"><div class="line">    <span class="comment">/* try the adaptor */</span></div>
<div class="line">    <span class="keyword">auto</span> v2 = vec | std::views::reverse | ::views::my;</div>
<div class="line">    <span class="keyword">static_assert</span>(std::ranges::random_access_range&lt;<span class="keyword">decltype</span>(v2)&gt;);</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, v2);</div>
</div><!-- fragment --><p >Here is the full, final solution:  <div class="assignment"> <details><summary><b>Hint</b></summary>  </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2nucleotide_2all_8hpp.html">bio/alphabet/nucleotide/all.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="inherited__iterator__base_8hpp.html">bio/ranges/detail/inherited_iterator_base.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The iterator template */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::forward_range urng_t&gt;            <span class="comment">// CRTP derivation â†“</span></div>
<div class="line"><span class="keyword">class </span>my_iterator : <span class="keyword">public</span> bio::ranges::detail::inherited_iterator_base&lt;my_iterator&lt;urng_t&gt;,</div>
<div class="line">                                                                std::ranges::iterator_t&lt;urng_t&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_interface" href="interfacebio_1_1alphabet_1_1nucleotide__alphabet.html">bio::alphabet::nucleotide_alphabet&lt;std::ranges::range_reference_t&lt;urng_t&gt;</a>&gt;,</div>
<div class="line">                  <span class="stringliteral">&quot;You can only iterate over ranges of nucleotides!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the immediate base type is the CRTP-layer</span></div>
<div class="line">    <span class="keyword">using </span>base_t = bio::ranges::detail::inherited_iterator_base&lt;my_iterator&lt;urng_t&gt;,</div>
<div class="line">                                                        std::ranges::iterator_t&lt;urng_t&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// the member types are never imported automatically, but can be explicitly inherited:</span></div>
<div class="line">    <span class="keyword">using </span>typename base_t::value_type;</div>
<div class="line">    <span class="keyword">using </span>typename base_t::difference_type;</div>
<div class="line">    <span class="keyword">using </span>typename base_t::iterator_category;</div>
<div class="line">    <span class="comment">// this member type is overwritten as we do above:</span></div>
<div class="line">    <span class="keyword">using </span>reference = value_type;</div>
<div class="line">    <span class="comment">// Explicitly set the pointer to void as we return a temporary.</span></div>
<div class="line">    <span class="keyword">using </span>pointer = void;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// define rule-of-six:</span></div>
<div class="line">    my_iterator() = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator(my_iterator <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator(my_iterator &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator &amp; operator=(my_iterator <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_iterator &amp; operator=(my_iterator &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    ~my_iterator() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="comment">// and a constructor that takes the base_type:</span></div>
<div class="line">    my_iterator(base_t it) : base_t{std::<a class="code hl_variable" href="group__views.html#gacc149746c0b9a2f5021709858f37de1b">move</a>(it)} {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we don&#39;t need to implement the ++ operators anymore!</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// only overload the operators that you actually wish to change:</span></div>
<div class="line">    reference operator*() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>(base_t::operator*());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since the reference type changed we might as well need to override the subscript-operator.</span></div>
<div class="line">    reference operator[](difference_type <span class="keyword">const</span> n) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line">        <span class="keyword">requires</span> std::random_access_iterator&lt;std::ranges::iterator_t&lt;urng_t&gt;&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__nucleotide.html#ga174261f8f888bbce628ffe01097a9b48">bio::alphabet::complement</a>(base_t::operator[](n));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We delete arrow operator because of the temporary. An alternative could be to return the temporary</span></div>
<div class="line">    <span class="comment">// wrapped in a std::unique_ptr.</span></div>
<div class="line">    pointer operator-&gt;() const noexcept = delete;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The inherited_iterator_base creates the necessary code so we also model RandomAccess now!</span></div>
<div class="line">static_assert(std::random_access_iterator&lt;my_iterator&lt;std::vector&lt;<a class="code hl_namespace" href="namespacebio.html">bio</a>::<a class="code hl_interface" href="interfacebio_1_1alphabet_1_1alphabet.html">alphabet</a>::<a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">dna5</a>&gt;&gt;&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The view class template */</span></div>
<div class="line">template &lt;std::ranges::view urng_t&gt;  <span class="comment">// CRTP derivation â†“</span></div>
<div class="line">class my_view : public std::ranges::view_interface&lt;my_view&lt;urng_t&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// this is the underlying range</span></div>
<div class="line">    urng_t urange;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Types of the iterators</span></div>
<div class="line">    <span class="keyword">using </span>iterator = my_iterator&lt;urng_t&gt;;</div>
<div class="line">    <span class="keyword">using </span>const_iterator = my_iterator&lt;urng_t const&gt;;</div>
<div class="line"> </div>
<div class="line">    my_view()                            = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view(my_view <span class="keyword">const</span> &amp;)             = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view(my_view &amp;&amp;)                  = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view &amp; operator=(my_view <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    my_view &amp; operator=(my_view &amp;&amp;)      = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// construct from a view</span></div>
<div class="line">    my_view(urng_t urange_) : urange{std::<a class="code hl_variable" href="group__views.html#gacc149746c0b9a2f5021709858f37de1b">move</a>(urange_)}</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// construct from the underlying type (works together with the deduction guide)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;std::constructible_from&lt;urng_t&gt; orng_t&gt;</div>
<div class="line">    my_view(orng_t &amp;&amp; urange_) : urange{std::<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/forward.html">forward</a>&lt;orng_t&gt;(urange_)}</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/begin.html">begin</a>() noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/begin.html">begin</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> const_iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/begin.html">cbegin</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> const_iterator{<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/ranges/begin.html">std::ranges::begin</a>(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/end.html">end</a>() noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/end.html">end</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/iterator/end.html">cend</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::ranges::end(urange);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A deduction guide for the view class template</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::viewable_range orng_t&gt;</div>
<div class="line">my_view(orng_t &amp;&amp;) -&gt; my_view&lt;std::views::all_t&lt;orng_t&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The adaptor object&#39;s type definition */</span></div>
<div class="line"><span class="keyword">struct </span>my_view_fn</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;std::ranges::input_range urng_t&gt;</div>
<div class="line">    <span class="keyword">auto</span> operator()(urng_t &amp;&amp; urange)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> my_view{std::forward&lt;urng_t&gt;(urange)};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;std::ranges::input_range urng_t&gt;</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> <a class="code hl_function" href="namespacebio_1_1alphabet.html#aeb4e6ec76811b98d61d0eeddb113b004">operator|</a>(urng_t &amp;&amp; urange, my_view_fn <span class="keyword">const</span> &amp;)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> my_view{std::forward&lt;urng_t&gt;(urange)};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The adaptor object&#39;s definition */</span></div>
<div class="line"><span class="keyword">namespace </span>views</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> my_view_fn my{};</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna5&gt;</a> vec{<span class="stringliteral">&quot;GATTACA&quot;</span>_dna5};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* try the iterator */</span></div>
<div class="line">    <span class="keyword">using </span>my_it_concrete = my_iterator&lt;std::vector&lt;bio::alphabet::dna5&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    my_it_concrete it{vec.<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector/begin.html">begin</a>()};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// now you can use operator[] on the iterator</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 7; ++i)</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(it[i]) &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* try the range */</span></div>
<div class="line">    my_view v{vec};</div>
<div class="line">    <span class="keyword">static_assert</span>(std::ranges::random_access_range&lt;<span class="keyword">decltype</span>(v)&gt;);</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;\n{}\n&quot;</span>, v);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* try the adaptor */</span></div>
<div class="line">    <span class="keyword">auto</span> v2 = vec | std::views::reverse | ::views::my;</div>
<div class="line">    <span class="keyword">static_assert</span>(std::ranges::random_access_range&lt;<span class="keyword">decltype</span>(v2)&gt;);</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, v2);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aforward_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/utility/forward.html">std::forward</a></div><div class="ttdeci">T forward(T... args)</div></div>
</div><!-- fragment --><p >The program prints: </p><div class="fragment"><div class="line">C T A A T G T</div>
<div class="line">CTAATGT</div>
<div class="line">TGTAATC</div>
</div><!-- fragment --><p > </details> </div>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Mon Jul 25 2022 14:00:35 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
