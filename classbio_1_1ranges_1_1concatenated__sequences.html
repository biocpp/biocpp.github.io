<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: bio::ranges::concatenated_sequences&lt; underlying_container_type, data_delimiters_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">BioC++<span id="projectnumber">&#160;0.5.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classbio_1_1ranges_1_1concatenated__sequences.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classbio_1_1ranges_1_1concatenated__sequences-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bio::ranges::concatenated_sequences&lt; underlying_container_type, data_delimiters_type &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__range.html">Ranges</a> &raquo; <a class="el" href="group__container.html">Container</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Container that stores sequences concatenated internally.  
 <a href="classbio_1_1ranges_1_1concatenated__sequences.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="concatenated__sequences_8hpp_source.html">bio/ranges/container/concatenated_sequences.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for bio::ranges::concatenated_sequences&lt; underlying_container_type, data_delimiters_type &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classbio_1_1ranges_1_1concatenated__sequences__inherit__graph.svg" width="100%" height="476"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member types</div></td></tr>
<tr class="memitem:a7ff6558bbf2e8e3be105df2f8befa53d"><td class="memItemLeft" align="right" valign="top"><a id="a7ff6558bbf2e8e3be105df2f8befa53d" name="a7ff6558bbf2e8e3be105df2f8befa53d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = decltype(std::declval&lt; <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; underlying_container_type &gt; &amp; &gt;()|<a class="el" href="group__views.html#ga5c52d6b4c32c024f6974ebae155aa4ab">views::slice</a>(0, 1))</td></tr>
<tr class="memdesc:a7ff6558bbf2e8e3be105df2f8befa53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="group__views.html#ga5c52d6b4c32c024f6974ebae155aa4ab" title="A view adaptor that returns a half-open interval on the underlying range.">views::slice</a> that represents "one element", typically a <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/span.html">std::span</a>. <br /></td></tr>
<tr class="separator:a7ff6558bbf2e8e3be105df2f8befa53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade58ffa47c048d0d75bb0607246e4913"><td class="memItemLeft" align="right" valign="top"><a id="ade58ffa47c048d0d75bb0607246e4913" name="ade58ffa47c048d0d75bb0607246e4913"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a7ff6558bbf2e8e3be105df2f8befa53d">value_type</a></td></tr>
<tr class="memdesc:ade58ffa47c048d0d75bb0607246e4913"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy of type <a class="el" href="group__views.html#ga5c52d6b4c32c024f6974ebae155aa4ab" title="A view adaptor that returns a half-open interval on the underlying range.">views::slice</a> that represents the range on the concatenated vector. <br /></td></tr>
<tr class="separator:ade58ffa47c048d0d75bb0607246e4913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99379ad28d44f3a4c12d78556fa94e57"><td class="memItemLeft" align="right" valign="top"><a id="a99379ad28d44f3a4c12d78556fa94e57" name="a99379ad28d44f3a4c12d78556fa94e57"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = decltype(std::as_const(data_values)|<a class="el" href="group__views.html#ga5c52d6b4c32c024f6974ebae155aa4ab">views::slice</a>(0, 1))</td></tr>
<tr class="memdesc:a99379ad28d44f3a4c12d78556fa94e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable proxy of type <a class="el" href="group__views.html#ga5c52d6b4c32c024f6974ebae155aa4ab" title="A view adaptor that returns a half-open interval on the underlying range.">views::slice</a> that represents the range on the concatenated vector. <br /></td></tr>
<tr class="separator:a99379ad28d44f3a4c12d78556fa94e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a3f2fb0ead878373d8f82c3a82429c"><td class="memItemLeft" align="right" valign="top"><a id="ae1a3f2fb0ead878373d8f82c3a82429c" name="ae1a3f2fb0ead878373d8f82c3a82429c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = detail::random_access_iterator&lt; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &gt;</td></tr>
<tr class="memdesc:ae1a3f2fb0ead878373d8f82c3a82429c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type of this container (a random access iterator). <br /></td></tr>
<tr class="separator:ae1a3f2fb0ead878373d8f82c3a82429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9570fa4466c9cd3fa8b083f30c745c34"><td class="memItemLeft" align="right" valign="top"><a id="a9570fa4466c9cd3fa8b083f30c745c34" name="a9570fa4466c9cd3fa8b083f30c745c34"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = detail::random_access_iterator&lt; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const  &gt;</td></tr>
<tr class="memdesc:a9570fa4466c9cd3fa8b083f30c745c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const iterator type of this container (a random access iterator). <br /></td></tr>
<tr class="separator:a9570fa4466c9cd3fa8b083f30c745c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f32552bde4625971799e429def369d"><td class="memItemLeft" align="right" valign="top"><a id="a51f32552bde4625971799e429def369d" name="a51f32552bde4625971799e429def369d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ranges::range_difference_t&lt; data_delimiters_type &gt;</td></tr>
<tr class="memdesc:a51f32552bde4625971799e429def369d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integer type (usually <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/ptrdiff_t.html">std::ptrdiff_t</a>) <br /></td></tr>
<tr class="separator:a51f32552bde4625971799e429def369d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5898489c8cec16d613ae365574bb7c27"><td class="memItemLeft" align="right" valign="top"><a id="a5898489c8cec16d613ae365574bb7c27" name="a5898489c8cec16d613ae365574bb7c27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::ranges::range_size_t&lt; data_delimiters_type &gt;</td></tr>
<tr class="memdesc:a5898489c8cec16d613ae365574bb7c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type (usually <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a>) <br /></td></tr>
<tr class="separator:a5898489c8cec16d613ae365574bb7c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor and assignment</div></td></tr>
<tr class="memitem:a5bf9350f5ebe314ed481c50d981bfb37"><td class="memItemLeft" align="right" valign="top"><a id="a5bf9350f5ebe314ed481c50d981bfb37" name="a5bf9350f5ebe314ed481c50d981bfb37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>concatenated_sequences</b> ()=default</td></tr>
<tr class="memdesc:a5bf9350f5ebe314ed481c50d981bfb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructors. <br /></td></tr>
<tr class="separator:a5bf9350f5ebe314ed481c50d981bfb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635d5e0ff8a28b57620e7889d6060cf0"><td class="memItemLeft" align="right" valign="top"><a id="a635d5e0ff8a28b57620e7889d6060cf0" name="a635d5e0ff8a28b57620e7889d6060cf0"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>concatenated_sequences</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const &amp;)=default</td></tr>
<tr class="memdesc:a635d5e0ff8a28b57620e7889d6060cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructors. <br /></td></tr>
<tr class="separator:a635d5e0ff8a28b57620e7889d6060cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140427d1cb3c5b732cdc197db48aac2c"><td class="memItemLeft" align="right" valign="top"><a id="a140427d1cb3c5b732cdc197db48aac2c" name="a140427d1cb3c5b732cdc197db48aac2c"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>concatenated_sequences</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a140427d1cb3c5b732cdc197db48aac2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructors. <br /></td></tr>
<tr class="separator:a140427d1cb3c5b732cdc197db48aac2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d6e0e54218ab921195bf91d3eeb45e"><td class="memItemLeft" align="right" valign="top"><a id="a33d6e0e54218ab921195bf91d3eeb45e" name="a33d6e0e54218ab921195bf91d3eeb45e"></a>
constexpr <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const &amp;)=default</td></tr>
<tr class="memdesc:a33d6e0e54218ab921195bf91d3eeb45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructors. <br /></td></tr>
<tr class="separator:a33d6e0e54218ab921195bf91d3eeb45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae2e76c319938ed740114226cfeef2c"><td class="memItemLeft" align="right" valign="top"><a id="a9ae2e76c319938ed740114226cfeef2c" name="a9ae2e76c319938ed740114226cfeef2c"></a>
constexpr <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a9ae2e76c319938ed740114226cfeef2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructors. <br /></td></tr>
<tr class="separator:a9ae2e76c319938ed740114226cfeef2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b045ae5102cd8082e1f087766e2601"><td class="memItemLeft" align="right" valign="top"><a id="aa9b045ae5102cd8082e1f087766e2601" name="aa9b045ae5102cd8082e1f087766e2601"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~concatenated_sequences</b> ()=default</td></tr>
<tr class="memdesc:aa9b045ae5102cd8082e1f087766e2601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructors. <br /></td></tr>
<tr class="separator:aa9b045ae5102cd8082e1f087766e2601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ba6d0707085a4ff179843cf744ec9e"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range rng_of_rng_type&gt; </td></tr>
<tr class="memitem:a41ba6d0707085a4ff179843cf744ec9e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a41ba6d0707085a4ff179843cf744ec9e">concatenated_sequences</a> (rng_of_rng_type &amp;&amp;rng_of_rng)</td></tr>
<tr class="memdesc:a41ba6d0707085a4ff179843cf744ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign from a different range.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a41ba6d0707085a4ff179843cf744ec9e">More...</a><br /></td></tr>
<tr class="separator:a41ba6d0707085a4ff179843cf744ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29814b938516f98a47b873ede8dc4ea1"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type&gt; </td></tr>
<tr class="memitem:a29814b938516f98a47b873ede8dc4ea1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a29814b938516f98a47b873ede8dc4ea1">concatenated_sequences</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const count, rng_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a29814b938516f98a47b873ede8dc4ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign with <code>count</code> times <code>value</code>.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a29814b938516f98a47b873ede8dc4ea1">More...</a><br /></td></tr>
<tr class="separator:a29814b938516f98a47b873ede8dc4ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad4b59f79223f61587890e43266b34b"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </td></tr>
<tr class="memitem:a0ad4b59f79223f61587890e43266b34b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0ad4b59f79223f61587890e43266b34b">concatenated_sequences</a> (begin_iterator_type begin_it, end_iterator_type end_it)</td></tr>
<tr class="memdesc:a0ad4b59f79223f61587890e43266b34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign from pair of iterators.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a0ad4b59f79223f61587890e43266b34b">More...</a><br /></td></tr>
<tr class="separator:a0ad4b59f79223f61587890e43266b34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2834662378cb1a5357570945c3981d"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range value_type_t = value_type&gt; </td></tr>
<tr class="memitem:a5d2834662378cb1a5357570945c3981d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5d2834662378cb1a5357570945c3981d">concatenated_sequences</a> (<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type_t &gt; ilist)</td></tr>
<tr class="memdesc:a5d2834662378cb1a5357570945c3981d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a5d2834662378cb1a5357570945c3981d">More...</a><br /></td></tr>
<tr class="separator:a5d2834662378cb1a5357570945c3981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89023678e7c85d80d140de47939c4db6"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range value_type_t&gt; </td></tr>
<tr class="memitem:a89023678e7c85d80d140de47939c4db6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a89023678e7c85d80d140de47939c4db6">operator=</a> (<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type_t &gt; ilist)</td></tr>
<tr class="memdesc:a89023678e7c85d80d140de47939c4db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a89023678e7c85d80d140de47939c4db6">More...</a><br /></td></tr>
<tr class="separator:a89023678e7c85d80d140de47939c4db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1300e0e6682524d4e84420df31edf712"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range rng_of_rng_type&gt; </td></tr>
<tr class="memitem:a1300e0e6682524d4e84420df31edf712"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a1300e0e6682524d4e84420df31edf712">assign</a> (rng_of_rng_type &amp;&amp;rng_of_rng)</td></tr>
<tr class="memdesc:a1300e0e6682524d4e84420df31edf712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign from a different range.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a1300e0e6682524d4e84420df31edf712">More...</a><br /></td></tr>
<tr class="separator:a1300e0e6682524d4e84420df31edf712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87a2f924c1dfc7d56833742f7fac278"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type&gt; </td></tr>
<tr class="memitem:af87a2f924c1dfc7d56833742f7fac278"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#af87a2f924c1dfc7d56833742f7fac278">assign</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const count, rng_type &amp;&amp;value)</td></tr>
<tr class="memdesc:af87a2f924c1dfc7d56833742f7fac278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign with <code>count</code> times <code>value</code>.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#af87a2f924c1dfc7d56833742f7fac278">More...</a><br /></td></tr>
<tr class="separator:af87a2f924c1dfc7d56833742f7fac278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9aac9d5e7a10956f69f14d06f4481c5"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </td></tr>
<tr class="memitem:ae9aac9d5e7a10956f69f14d06f4481c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae9aac9d5e7a10956f69f14d06f4481c5">assign</a> (begin_iterator_type begin_it, end_iterator_type end_it)</td></tr>
<tr class="memdesc:ae9aac9d5e7a10956f69f14d06f4481c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign from pair of iterators.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#ae9aac9d5e7a10956f69f14d06f4481c5">More...</a><br /></td></tr>
<tr class="separator:ae9aac9d5e7a10956f69f14d06f4481c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd95c1cb350466705b675216dd5e46a"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type = value_type&gt; </td></tr>
<tr class="memitem:a5fd95c1cb350466705b675216dd5e46a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5fd95c1cb350466705b675216dd5e46a">assign</a> (<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; rng_type &gt; ilist)</td></tr>
<tr class="memdesc:a5fd95c1cb350466705b675216dd5e46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct/assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a5fd95c1cb350466705b675216dd5e46a">More...</a><br /></td></tr>
<tr class="separator:a5fd95c1cb350466705b675216dd5e46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:acdc9768f3b3438caf85c5a332af8908f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#acdc9768f3b3438caf85c5a332af8908f">begin</a> () noexcept</td></tr>
<tr class="memdesc:acdc9768f3b3438caf85c5a332af8908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#acdc9768f3b3438caf85c5a332af8908f">More...</a><br /></td></tr>
<tr class="separator:acdc9768f3b3438caf85c5a332af8908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f399787dab851ea6411ea05a6cf087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a73f399787dab851ea6411ea05a6cf087">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a73f399787dab851ea6411ea05a6cf087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a73f399787dab851ea6411ea05a6cf087">More...</a><br /></td></tr>
<tr class="separator:a73f399787dab851ea6411ea05a6cf087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350904ea62c071d535423ba5cecb1958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a350904ea62c071d535423ba5cecb1958">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a350904ea62c071d535423ba5cecb1958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a350904ea62c071d535423ba5cecb1958">More...</a><br /></td></tr>
<tr class="separator:a350904ea62c071d535423ba5cecb1958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c6386b3ddaaac34cd0617c14a11440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440">end</a> () noexcept</td></tr>
<tr class="memdesc:a92c6386b3ddaaac34cd0617c14a11440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440">More...</a><br /></td></tr>
<tr class="separator:a92c6386b3ddaaac34cd0617c14a11440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad024ec1aa32a2c1a65710d1681acb215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ad024ec1aa32a2c1a65710d1681acb215">end</a> () const noexcept</td></tr>
<tr class="memdesc:ad024ec1aa32a2c1a65710d1681acb215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#ad024ec1aa32a2c1a65710d1681acb215">More...</a><br /></td></tr>
<tr class="separator:ad024ec1aa32a2c1a65710d1681acb215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff960838cf08a11eedb8296c2420bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9ff960838cf08a11eedb8296c2420bf0">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a9ff960838cf08a11eedb8296c2420bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a9ff960838cf08a11eedb8296c2420bf0">More...</a><br /></td></tr>
<tr class="separator:a9ff960838cf08a11eedb8296c2420bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr class="memitem:aad58859482a46f80420a78617510b4e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#aad58859482a46f80420a78617510b4e5">at</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const i)</td></tr>
<tr class="memdesc:aad58859482a46f80420a78617510b4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element as a view.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#aad58859482a46f80420a78617510b4e5">More...</a><br /></td></tr>
<tr class="separator:aad58859482a46f80420a78617510b4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceee97c1357cb104562559a98ca490eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#aceee97c1357cb104562559a98ca490eb">at</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const i) const</td></tr>
<tr class="memdesc:aceee97c1357cb104562559a98ca490eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element as a view.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#aceee97c1357cb104562559a98ca490eb">More...</a><br /></td></tr>
<tr class="separator:aceee97c1357cb104562559a98ca490eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcc4492613cbe9b799f49763a41e8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a7bcc4492613cbe9b799f49763a41e8a7">operator[]</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const i)</td></tr>
<tr class="memdesc:a7bcc4492613cbe9b799f49763a41e8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element as a view.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a7bcc4492613cbe9b799f49763a41e8a7">More...</a><br /></td></tr>
<tr class="separator:a7bcc4492613cbe9b799f49763a41e8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8f7ede2fc4804a2e8e5f45a707248c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a7d8f7ede2fc4804a2e8e5f45a707248c">operator[]</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const i) const</td></tr>
<tr class="memdesc:a7d8f7ede2fc4804a2e8e5f45a707248c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element as a view.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a7d8f7ede2fc4804a2e8e5f45a707248c">More...</a><br /></td></tr>
<tr class="separator:a7d8f7ede2fc4804a2e8e5f45a707248c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69eb0da29eede9634012f757c968ecb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a69eb0da29eede9634012f757c968ecb2">front</a> ()</td></tr>
<tr class="memdesc:a69eb0da29eede9634012f757c968ecb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element as a view. Calling front on an empty container is undefined.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a69eb0da29eede9634012f757c968ecb2">More...</a><br /></td></tr>
<tr class="separator:a69eb0da29eede9634012f757c968ecb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461bca9014754a68fbaeabddba424506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a461bca9014754a68fbaeabddba424506">front</a> () const</td></tr>
<tr class="memdesc:a461bca9014754a68fbaeabddba424506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element as a view. Calling front on an empty container is undefined.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a461bca9014754a68fbaeabddba424506">More...</a><br /></td></tr>
<tr class="separator:a461bca9014754a68fbaeabddba424506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af091bdbd6e31e0dc46b78bf0d3a8470c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#af091bdbd6e31e0dc46b78bf0d3a8470c">back</a> ()</td></tr>
<tr class="memdesc:af091bdbd6e31e0dc46b78bf0d3a8470c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element as a view.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#af091bdbd6e31e0dc46b78bf0d3a8470c">More...</a><br /></td></tr>
<tr class="separator:af091bdbd6e31e0dc46b78bf0d3a8470c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be82a9beaf538eaa5f35def3dfed2f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9be82a9beaf538eaa5f35def3dfed2f5">back</a> () const</td></tr>
<tr class="memdesc:a9be82a9beaf538eaa5f35def3dfed2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element as a view.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a9be82a9beaf538eaa5f35def3dfed2f5">More...</a><br /></td></tr>
<tr class="separator:a9be82a9beaf538eaa5f35def3dfed2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4678ee666dd44987efb55020cf739a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a4678ee666dd44987efb55020cf739a84">concat</a> ()</td></tr>
<tr class="memdesc:a4678ee666dd44987efb55020cf739a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of all members.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a4678ee666dd44987efb55020cf739a84">More...</a><br /></td></tr>
<tr class="separator:a4678ee666dd44987efb55020cf739a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac390322a20e99fcfe49d6d7fd439003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#aac390322a20e99fcfe49d6d7fd439003">concat</a> () const</td></tr>
<tr class="memdesc:aac390322a20e99fcfe49d6d7fd439003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of all members.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#aac390322a20e99fcfe49d6d7fd439003">More...</a><br /></td></tr>
<tr class="separator:aac390322a20e99fcfe49d6d7fd439003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcc1c5ffcafbd0a4e3cc3e1e7895514"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; decltype(data_values) &amp;, decltype(data_delimiters) &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fcc1c5ffcafbd0a4e3cc3e1e7895514">raw_data</a> ()</td></tr>
<tr class="memdesc:a0fcc1c5ffcafbd0a4e3cc3e1e7895514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct, unsafe access to underlying data structures.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fcc1c5ffcafbd0a4e3cc3e1e7895514">More...</a><br /></td></tr>
<tr class="separator:a0fcc1c5ffcafbd0a4e3cc3e1e7895514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf220abc76ac2d81cecf1b29a32656e5"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; decltype(data_values) const &amp;, decltype(data_delimiters) const &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#aaf220abc76ac2d81cecf1b29a32656e5">raw_data</a> () const</td></tr>
<tr class="memdesc:aaf220abc76ac2d81cecf1b29a32656e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct, unsafe access to underlying data structures.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#aaf220abc76ac2d81cecf1b29a32656e5">More...</a><br /></td></tr>
<tr class="separator:aaf220abc76ac2d81cecf1b29a32656e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:a2f2b8a5790c66dd42c9d0b52e044479b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a2f2b8a5790c66dd42c9d0b52e044479b">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a2f2b8a5790c66dd42c9d0b52e044479b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a2f2b8a5790c66dd42c9d0b52e044479b">More...</a><br /></td></tr>
<tr class="separator:a2f2b8a5790c66dd42c9d0b52e044479b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805aa9beca299259b7ef66b6953f21a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5">size</a> () const noexcept</td></tr>
<tr class="memdesc:a805aa9beca299259b7ef66b6953f21a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#acdc9768f3b3438caf85c5a332af8908f" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a>).  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5">More...</a><br /></td></tr>
<tr class="separator:a805aa9beca299259b7ef66b6953f21a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c2256d883b3a625dfccde922d2d25b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a02c2256d883b3a625dfccde922d2d25b">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a02c2256d883b3a625dfccde922d2d25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#acdc9768f3b3438caf85c5a332af8908f" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a>) for the largest container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a02c2256d883b3a625dfccde922d2d25b">More...</a><br /></td></tr>
<tr class="separator:a02c2256d883b3a625dfccde922d2d25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67463019572b330feaafba7bbf80b7cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a67463019572b330feaafba7bbf80b7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc">More...</a><br /></td></tr>
<tr class="separator:a67463019572b330feaafba7bbf80b7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d24f956f652e3a9e9b19ca3a88906b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a7d24f956f652e3a9e9b19ca3a88906b1">reserve</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const new_cap)</td></tr>
<tr class="memdesc:a7d24f956f652e3a9e9b19ca3a88906b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity to a value that's greater or equal to new_cap.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a7d24f956f652e3a9e9b19ca3a88906b1">More...</a><br /></td></tr>
<tr class="separator:a7d24f956f652e3a9e9b19ca3a88906b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac6ad4833ec10922c127ff819c87bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#adac6ad4833ec10922c127ff819c87bd4">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:adac6ad4833ec10922c127ff819c87bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#adac6ad4833ec10922c127ff819c87bd4">More...</a><br /></td></tr>
<tr class="separator:adac6ad4833ec10922c127ff819c87bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity (concat)</div></td></tr>
<tr class="memitem:a0fd1da21587b6d01165f24b1fc318290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290">concat_size</a> () const noexcept</td></tr>
<tr class="memdesc:a0fd1da21587b6d01165f24b1fc318290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cumulative size of all elements in the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290">More...</a><br /></td></tr>
<tr class="separator:a0fd1da21587b6d01165f24b1fc318290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cf54faf3c6e87cc6156feda6be1562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562">concat_capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a44cf54faf3c6e87cc6156feda6be1562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the concatenated size the container has currently allocated space for.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562">More...</a><br /></td></tr>
<tr class="separator:a44cf54faf3c6e87cc6156feda6be1562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01246b34e006f8150a993cadcdd02282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a01246b34e006f8150a993cadcdd02282">concat_reserve</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const new_cap)</td></tr>
<tr class="memdesc:a01246b34e006f8150a993cadcdd02282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a> to a value that's greater or equal to new_cap.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a01246b34e006f8150a993cadcdd02282">More...</a><br /></td></tr>
<tr class="separator:a01246b34e006f8150a993cadcdd02282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr class="memitem:a70ba664013a6486a88de1e0a277f7548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a70ba664013a6486a88de1e0a277f7548">clear</a> () noexcept</td></tr>
<tr class="memdesc:a70ba664013a6486a88de1e0a277f7548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a70ba664013a6486a88de1e0a277f7548">More...</a><br /></td></tr>
<tr class="separator:a70ba664013a6486a88de1e0a277f7548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7363e23fdb65c2d6114b502c854d4b"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type&gt; </td></tr>
<tr class="memitem:afe7363e23fdb65c2d6114b502c854d4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#afe7363e23fdb65c2d6114b502c854d4b">insert</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> pos, rng_type &amp;&amp;value)</td></tr>
<tr class="memdesc:afe7363e23fdb65c2d6114b502c854d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value before position in the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#afe7363e23fdb65c2d6114b502c854d4b">More...</a><br /></td></tr>
<tr class="separator:afe7363e23fdb65c2d6114b502c854d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdf497f3e7d20a18b27f662a8b2335c"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type&gt; </td></tr>
<tr class="memitem:a9bdf497f3e7d20a18b27f662a8b2335c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9bdf497f3e7d20a18b27f662a8b2335c">insert</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> pos, <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const count, rng_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a9bdf497f3e7d20a18b27f662a8b2335c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of value before position in the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a9bdf497f3e7d20a18b27f662a8b2335c">More...</a><br /></td></tr>
<tr class="separator:a9bdf497f3e7d20a18b27f662a8b2335c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecd03de0b3a83ae585a29bd34951f96"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </td></tr>
<tr class="memitem:a9ecd03de0b3a83ae585a29bd34951f96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9ecd03de0b3a83ae585a29bd34951f96">insert</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> pos, begin_iterator_type first, end_iterator_type last)</td></tr>
<tr class="memdesc:a9ecd03de0b3a83ae585a29bd34951f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range <code>[first, last)</code> before position in the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a9ecd03de0b3a83ae585a29bd34951f96">More...</a><br /></td></tr>
<tr class="separator:a9ecd03de0b3a83ae585a29bd34951f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c7eaf8c5ff9e20e79d5271ca9842ed"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type&gt; </td></tr>
<tr class="memitem:ac8c7eaf8c5ff9e20e79d5271ca9842ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ac8c7eaf8c5ff9e20e79d5271ca9842ed">insert</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> pos, <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; rng_type &gt; const &amp;ilist)</td></tr>
<tr class="memdesc:ac8c7eaf8c5ff9e20e79d5271ca9842ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list before position in the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#ac8c7eaf8c5ff9e20e79d5271ca9842ed">More...</a><br /></td></tr>
<tr class="separator:ac8c7eaf8c5ff9e20e79d5271ca9842ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e281e9ae928e3b37a9f3eb6c01ac50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a1e281e9ae928e3b37a9f3eb6c01ac50a">erase</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> first, <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> last)</td></tr>
<tr class="memdesc:a1e281e9ae928e3b37a9f3eb6c01ac50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified elements from the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a1e281e9ae928e3b37a9f3eb6c01ac50a">More...</a><br /></td></tr>
<tr class="separator:a1e281e9ae928e3b37a9f3eb6c01ac50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4bcf58efeef7baef0c7859120c5a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#acc4bcf58efeef7baef0c7859120c5a47">erase</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> pos)</td></tr>
<tr class="memdesc:acc4bcf58efeef7baef0c7859120c5a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified elements from the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#acc4bcf58efeef7baef0c7859120c5a47">More...</a><br /></td></tr>
<tr class="separator:acc4bcf58efeef7baef0c7859120c5a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238c4f65d3eb4ec027dc8f55f865db0c"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type&gt; </td></tr>
<tr class="memitem:a238c4f65d3eb4ec027dc8f55f865db0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a238c4f65d3eb4ec027dc8f55f865db0c">push_back</a> (rng_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a238c4f65d3eb4ec027dc8f55f865db0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a238c4f65d3eb4ec027dc8f55f865db0c">More...</a><br /></td></tr>
<tr class="separator:a238c4f65d3eb4ec027dc8f55f865db0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5a5172c5aa0b28070b06dffa27546f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a2a5a5172c5aa0b28070b06dffa27546f">push_back</a> ()</td></tr>
<tr class="memdesc:a2a5a5172c5aa0b28070b06dffa27546f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an empty element to the end of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a2a5a5172c5aa0b28070b06dffa27546f">More...</a><br /></td></tr>
<tr class="separator:a2a5a5172c5aa0b28070b06dffa27546f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bfec6e20aa7300ebc09ff1170d4f2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a80bfec6e20aa7300ebc09ff1170d4f2e">push_back_inner</a> (std::ranges::range_value_t&lt; underlying_container_type &gt; const value)</td></tr>
<tr class="memdesc:a80bfec6e20aa7300ebc09ff1170d4f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element-of-element value to the end of the underlying container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a80bfec6e20aa7300ebc09ff1170d4f2e">More...</a><br /></td></tr>
<tr class="separator:a80bfec6e20aa7300ebc09ff1170d4f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbb6bf60a7dbc6298b14c4ca66968b3"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type&gt; </td></tr>
<tr class="memitem:a6cbb6bf60a7dbc6298b14c4ca66968b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6cbb6bf60a7dbc6298b14c4ca66968b3">append_inner</a> (rng_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a6cbb6bf60a7dbc6298b14c4ca66968b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given elements to the end of the underlying container (increases size of last element by n).  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a6cbb6bf60a7dbc6298b14c4ca66968b3">More...</a><br /></td></tr>
<tr class="separator:a6cbb6bf60a7dbc6298b14c4ca66968b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79867e2d296a9e0512acc3341c886a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a79867e2d296a9e0512acc3341c886a68">pop_back</a> ()</td></tr>
<tr class="memdesc:a79867e2d296a9e0512acc3341c886a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a79867e2d296a9e0512acc3341c886a68">More...</a><br /></td></tr>
<tr class="separator:a79867e2d296a9e0512acc3341c886a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774fddde8d5db3bbc7975463d85a42a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a774fddde8d5db3bbc7975463d85a42a9">resize</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const count)</td></tr>
<tr class="memdesc:a774fddde8d5db3bbc7975463d85a42a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a774fddde8d5db3bbc7975463d85a42a9">More...</a><br /></td></tr>
<tr class="separator:a774fddde8d5db3bbc7975463d85a42a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ffe9d52927fb05a212e6e2d9ceb1b1"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range rng_type&gt; </td></tr>
<tr class="memitem:a92ffe9d52927fb05a212e6e2d9ceb1b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92ffe9d52927fb05a212e6e2d9ceb1b1">resize</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const count, rng_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a92ffe9d52927fb05a212e6e2d9ceb1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a92ffe9d52927fb05a212e6e2d9ceb1b1">More...</a><br /></td></tr>
<tr class="separator:a92ffe9d52927fb05a212e6e2d9ceb1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd6bcb6374a0519931ffa1eacaac0fe"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a8cd6bcb6374a0519931ffa1eacaac0fe">swap</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8cd6bcb6374a0519931ffa1eacaac0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents with another instance.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#a8cd6bcb6374a0519931ffa1eacaac0fe">More...</a><br /></td></tr>
<tr class="separator:a8cd6bcb6374a0519931ffa1eacaac0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2855754ba06c11303466d89480227de"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#aa2855754ba06c11303466d89480227de">swap</a> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa2855754ba06c11303466d89480227de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents with another instance.  <a href="classbio_1_1ranges_1_1concatenated__sequences.html#aa2855754ba06c11303466d89480227de">More...</a><br /></td></tr>
<tr class="separator:aa2855754ba06c11303466d89480227de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr class="memitem:a478f7ba10f2f612d2ac0d9af386acfcb"><td class="memItemLeft" align="right" valign="top"><a id="a478f7ba10f2f612d2ac0d9af386acfcb" name="a478f7ba10f2f612d2ac0d9af386acfcb"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a478f7ba10f2f612d2ac0d9af386acfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is equal to <code>rhs</code>. <br /></td></tr>
<tr class="separator:a478f7ba10f2f612d2ac0d9af386acfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f580e171fc2e6a069519f6df705022"><td class="memItemLeft" align="right" valign="top"><a id="a79f580e171fc2e6a069519f6df705022" name="a79f580e171fc2e6a069519f6df705022"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a79f580e171fc2e6a069519f6df705022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is not equal to <code>rhs</code>. <br /></td></tr>
<tr class="separator:a79f580e171fc2e6a069519f6df705022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3b44c201cca513c9a32826cd00928e"><td class="memItemLeft" align="right" valign="top"><a id="afc3b44c201cca513c9a32826cd00928e" name="afc3b44c201cca513c9a32826cd00928e"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:afc3b44c201cca513c9a32826cd00928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is less than <code>rhs</code>. <br /></td></tr>
<tr class="separator:afc3b44c201cca513c9a32826cd00928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac078e15e8525efec42f5b9d71bd4aa7d"><td class="memItemLeft" align="right" valign="top"><a id="ac078e15e8525efec42f5b9d71bd4aa7d" name="ac078e15e8525efec42f5b9d71bd4aa7d"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ac078e15e8525efec42f5b9d71bd4aa7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is greater than <code>rhs</code>. <br /></td></tr>
<tr class="separator:ac078e15e8525efec42f5b9d71bd4aa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b357f5f2faf1f8dd889307f0a4f1bc3"><td class="memItemLeft" align="right" valign="top"><a id="a1b357f5f2faf1f8dd889307f0a4f1bc3" name="a1b357f5f2faf1f8dd889307f0a4f1bc3"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a1b357f5f2faf1f8dd889307f0a4f1bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is less than or equal to <code>rhs</code>. <br /></td></tr>
<tr class="separator:a1b357f5f2faf1f8dd889307f0a4f1bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eccca4dd57fd135fb28d7cb4c536660"><td class="memItemLeft" align="right" valign="top"><a id="a8eccca4dd57fd135fb28d7cb4c536660" name="a8eccca4dd57fd135fb28d7cb4c536660"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a8eccca4dd57fd135fb28d7cb4c536660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is greater than or equal to <code>rhs</code>. <br /></td></tr>
<tr class="separator:a8eccca4dd57fd135fb28d7cb4c536660"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Compatibility</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Static constexpr variables that emulate/encapsulate <a class="el" href="interfacebio_1_1ranges_1_1range__compatible.html" title="Two types are &quot;compatible&quot; if their bio::ranges::range_dimension_v and their bio::ranges::range_inner...">bio::ranges::range_compatible</a> (which doesn't work for types during their definition). </p>
</div></td></tr>
<tr class="memitem:a6b14c15b62b94547dda1b0f39f5c4eb6"><td class="memTemplParams" colspan="2"><a id="a6b14c15b62b94547dda1b0f39f5c4eb6" name="a6b14c15b62b94547dda1b0f39f5c4eb6"></a>
template&lt;std::ranges::range t&gt; </td></tr>
<tr class="memitem:a6b14c15b62b94547dda1b0f39f5c4eb6"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_compatible_with_value_type</b></td></tr>
<tr class="memdesc:a6b14c15b62b94547dda1b0f39f5c4eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a type satisfies <a class="el" href="interfacebio_1_1ranges_1_1range__compatible.html" title="Two types are &quot;compatible&quot; if their bio::ranges::range_dimension_v and their bio::ranges::range_inner...">bio::ranges::range_compatible</a> with this class's <code>value_type</code> or <code>reference</code> type. <br /></td></tr>
<tr class="separator:a6b14c15b62b94547dda1b0f39f5c4eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a56f3c5956f5ac72c42ec90cb5ad8af"><td class="memTemplParams" colspan="2"><a id="a3a56f3c5956f5ac72c42ec90cb5ad8af" name="a3a56f3c5956f5ac72c42ec90cb5ad8af"></a>
template&lt;typename t &gt; </td></tr>
<tr class="memitem:a3a56f3c5956f5ac72c42ec90cb5ad8af"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iter_value_t_is_compatible_with_value_type</b></td></tr>
<tr class="memdesc:a3a56f3c5956f5ac72c42ec90cb5ad8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a type satisfies <a class="el" href="interfacebio_1_1ranges_1_1range__compatible.html" title="Two types are &quot;compatible&quot; if their bio::ranges::range_dimension_v and their bio::ranges::range_inner...">bio::ranges::range_compatible</a> with this class. <br /></td></tr>
<tr class="separator:a3a56f3c5956f5ac72c42ec90cb5ad8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fc00b34c17a179059b4f87d636ab50"><td class="memTemplParams" colspan="2"><a id="a32fc00b34c17a179059b4f87d636ab50" name="a32fc00b34c17a179059b4f87d636ab50"></a>
template&lt;std::ranges::range t&gt; </td></tr>
<tr class="memitem:a32fc00b34c17a179059b4f87d636ab50"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>range_value_t_is_compatible_with_value_type</b></td></tr>
<tr class="memdesc:a32fc00b34c17a179059b4f87d636ab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a type satisfies <a class="el" href="interfacebio_1_1ranges_1_1range__compatible.html" title="Two types are &quot;compatible&quot; if their bio::ranges::range_dimension_v and their bio::ranges::range_inner...">bio::ranges::range_compatible</a> with this class. <br /></td></tr>
<tr class="separator:a32fc00b34c17a179059b4f87d636ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename underlying_container_type, typename data_delimiters_type = std::vector&lt;typename underlying_container_type::size_type&gt;&gt;<br />
class bio::ranges::concatenated_sequences&lt; underlying_container_type, data_delimiters_type &gt;</div><p >Container that stores sequences concatenated internally. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">underlying_container_type</td><td>Type of the underlying container. Must satisfy bio::reservible_container. </td></tr>
    <tr><td class="paramname">data_delimiters_type</td><td>A container that stores the begin/end positions in the underlying_container_type. Must satifsy bio::reservible_container and have underlying_container_type's size_type as value_type.</td></tr>
  </table>
  </dd>
</dl>
<p>This class may be used whenever you would usually use <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;some_alphabet&gt;&gt;</code> or <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;</code>, i.e. whenever you have a collection of sequences. It is the spiritual successor of the <code>StringSet&lt;TString, Owner&lt;ConcatDirect&gt;&gt;</code> from SeqAn2.</p>
<p >It saves all of the member sequences inside one concatenated sequence internally. If you access an element, you instead get a view on the internal sequence. This has the following advantages:</p>
<ul>
<li>Better cache locality when parsing the sequences linearly (and often also on random access).</li>
<li>Constant time access to the concatenation of the sequences via <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a4678ee666dd44987efb55020cf739a84" title="Return the concatenation of all members.">concat()</a>.</li>
<li>This access is also writable so that certain transformations can be done globally, instead of element-wise.</li>
<li>Also direct access to the delimiters via <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fcc1c5ffcafbd0a4e3cc3e1e7895514" title="Provides direct, unsafe access to underlying data structures.">raw_data()</a> [this is used by some algorithms].</li>
</ul>
<p >Note that the "value type" of <code>bio::concatenated_sequences&lt;T&gt;</code> is <b>not</b> <code>T</code>. It is a view  typically a <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/span.html">std::span</a> or a <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string_view.html">std::string_view</a>. This view becomes invalid when the container is destroyed or any operation is performed on the container that invalidates its iterators, e.g. <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a2a5a5172c5aa0b28070b06dffa27546f" title="Appends an empty element to the end of the container.">push_back()</a>.</p>
<p >The disadvantages are:</p>
<ul>
<li>Slower inserts and erases because the entire concatenation might have to be copied.</li>
<li>No emplace operations.</li>
<li>Modifying elements is limited to operations on elements of that element, i.e. you can change a character, but you can't assign a new member sequence to an existing position.</li>
</ul>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concatenated__sequences_8hpp.html">bio/ranges/container/concatenated_sequences.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences&lt;bio::alphabet::dna4_vector&gt;</a> concat1{<span class="stringliteral">&quot;ACGT&quot;</span>_dna4, <span class="stringliteral">&quot;GAGGA&quot;</span>_dna4};</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, concat1[0]); <span class="comment">// &quot;ACGT&quot;</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna4_vector&gt;</a> concat2{<span class="stringliteral">&quot;ACTA&quot;</span>_dna4, <span class="stringliteral">&quot;AGGA&quot;</span>_dna4};</div>
<div class="line"> </div>
<div class="line">    concat1 = concat2;               <span class="comment">// you can assign from other ranges</span></div>
<div class="line"> </div>
<div class="line">    concat2[0] = <span class="stringliteral">&quot;ATTA&quot;</span>_dna4;        <span class="comment">// this works for vector of vector</span></div>
<div class="line">    concat1[0][1] = <span class="charliteral">&#39;T&#39;</span>_dna4;        <span class="comment">// and this works for concatenated_sequences</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, concat1[0]); <span class="comment">// &quot;ATTA&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if you know that you will be adding ten vectors of length ten:</span></div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna4&gt;</a> vector_of_length10{<span class="stringliteral">&quot;ACGTACGTAC&quot;</span>_dna4};</div>
<div class="line"> </div>
<div class="line">    concat1.<a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector/reserve.html">reserve</a>(10);</div>
<div class="line">    concat1.concat_reserve(10 * vector_of_length10.size());</div>
<div class="line">    <span class="keywordflow">while</span> (concat1.size() &lt; 10)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">        concat1.push_back(vector_of_length10);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassbio_1_1ranges_1_1concatenated__sequences_html"><div class="ttname"><a href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a></div><div class="ttdoc">Container that stores sequences concatenated internally.</div><div class="ttdef"><b>Definition:</b> concatenated_sequences.hpp:87</div></div>
<div class="ttc" id="aconcatenated__sequences_8hpp_html"><div class="ttname"><a href="concatenated__sequences_8hpp.html">concatenated_sequences.hpp</a></div><div class="ttdoc">Provides bio::ranges::concatenated_sequences.</div></div>
<div class="ttc" id="adna4_8hpp_html"><div class="ttname"><a href="dna4_8hpp.html">dna4.hpp</a></div><div class="ttdoc">Provides bio::alphabet::dna4, container aliases and string literals.</div></div>
<div class="ttc" id="afmt_8hpp_html"><div class="ttname"><a href="fmt_8hpp.html">fmt.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
<div class="ttc" id="anamespacebio_1_1alphabet_1_1literals_html"><div class="ttname"><a href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a></div><div class="ttdoc">An inline namespace for alphabet literals. It exists to safely allow using namespace.</div><div class="ttdef"><b>Definition:</b> aa10li.hpp:196</div></div>
<div class="ttc" id="areserve_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/container/vector/reserve.html">std::vector::reserve</a></div><div class="ttdeci">T reserve(T... args)</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a></div></div>
</div><!-- fragment --><h3>Exceptions</h3>
<p >Whenever a strong exception guarantee is given for this class, it presumes that <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_move_constructible.html">std::is_nothrow_move_constructible</a>&lt;typename underlying_container_type::value_type&gt;</code> otherwise only basic exception safety can be assumed.</p>
<h3>Thread safety</h3>
<p >This container provides no thread-safety beyond the promise given also by the STL that all calls to <code>const</code> member function are safe from multiple threads (as long as no thread calls a non-<code>const</code> member function at the same time). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a41ba6d0707085a4ff179843cf744ec9e" name="a41ba6d0707085a4ff179843cf744ec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ba6d0707085a4ff179843cf744ec9e">&#9670;&nbsp;</a></span>concatenated_sequences() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range rng_of_rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concatenated_sequences </td>
          <td>(</td>
          <td class="paramtype">rng_of_rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng_of_rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign from a different range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_of_rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a32fc00b34c17a179059b4f87d636ab50">range_value_t_is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng_of_rng</td><td>The sequences to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Linear in the cumulative size of <code>rng_of_rng</code>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a29814b938516f98a47b873ede8dc4ea1" name="a29814b938516f98a47b873ede8dc4ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29814b938516f98a47b873ede8dc4ea1">&#9670;&nbsp;</a></span>concatenated_sequences() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concatenated_sequences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign with <code>count</code> times <code>value</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">value</td><td>The initial value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >In <img class="formulaInl" alt="$O(count*value)$" src="form_4.png" width="128" height="19"/>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a0ad4b59f79223f61587890e43266b34b" name="a0ad4b59f79223f61587890e43266b34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad4b59f79223f61587890e43266b34b">&#9670;&nbsp;</a></span>concatenated_sequences() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concatenated_sequences </td>
          <td>(</td>
          <td class="paramtype">begin_iterator_type&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">end_iterator_type&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign from pair of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">begin_iterator_type</td><td>Must satisfy std::forward_iterator and must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a3a56f3c5956f5ac72c42ec90cb5ad8af">iter_value_t_is_compatible_with_value_type</a>. </td></tr>
    <tr><td class="paramname">end_iterator_type</td><td>Must satisfy std::sized_sentinel_for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_it</td><td>begin of range to construct/assign from. </td></tr>
    <tr><td class="paramname">end_it</td><td>end of range to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Linear in the cumulative size of the ranges between <code>begin_it</code> and <code>end_it</code>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a5d2834662378cb1a5357570945c3981d" name="a5d2834662378cb1a5357570945c3981d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2834662378cb1a5357570945c3981d">&#9670;&nbsp;</a></span>concatenated_sequences() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range value_type_t = value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concatenated_sequences </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type_t &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type_t</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>an <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code> of <code>value_type_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Linear in the cumulative size of the ranges in <code>ilist</code>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6cbb6bf60a7dbc6298b14c4ca66968b3" name="a6cbb6bf60a7dbc6298b14c4ca66968b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbb6bf60a7dbc6298b14c4ca66968b3">&#9670;&nbsp;</a></span>append_inner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::append_inner </td>
          <td>(</td>
          <td class="paramtype">rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given elements to the end of the underlying container (increases size of last element by n). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append.</td></tr>
  </table>
  </dd>
</dl>
<p>This conceptionally performs an <code><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#afe7363e23fdb65c2d6114b502c854d4b" title="Inserts value before position in the container.">insert()</a></code> on the <code><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#af091bdbd6e31e0dc46b78bf0d3a8470c" title="Return the last element as a view.">back()</a></code> of this container, i.e. the last inner container grows by <a class="el" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d" title="A type trait that holds the size of a (semi-)alphabet.">value.size()</a>.</p>
<p >If the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a> is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a>, all iterators and references (including the past-the-end iterator) are invalidated. Otherwise, only the past-the-end iterator is invalidated.</p>
<h3>Complexity</h3>
<p >Amortised linear in the size of value. Wort-case linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak. However, the container may contain invalid data after an exception is thrown. </p>

</div>
</div>
<a id="ae9aac9d5e7a10956f69f14d06f4481c5" name="ae9aac9d5e7a10956f69f14d06f4481c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9aac9d5e7a10956f69f14d06f4481c5">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">begin_iterator_type&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">end_iterator_type&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign from pair of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">begin_iterator_type</td><td>Must satisfy std::forward_iterator and satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a3a56f3c5956f5ac72c42ec90cb5ad8af">iter_value_t_is_compatible_with_value_type</a>. </td></tr>
    <tr><td class="paramname">end_iterator_type</td><td>Must satisfy std::sized_sentinel_for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_it</td><td>begin of range to construct/assign from. </td></tr>
    <tr><td class="paramname">end_it</td><td>end of range to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Linear in the cumulative size of the ranges between <code>begin_it</code> and <code>end_it</code>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a1300e0e6682524d4e84420df31edf712" name="a1300e0e6682524d4e84420df31edf712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1300e0e6682524d4e84420df31edf712">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range rng_of_rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">rng_of_rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng_of_rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign from a different range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_of_rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a32fc00b34c17a179059b4f87d636ab50">range_value_t_is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng_of_rng</td><td>The sequences to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Linear in the cumulative size of <code>rng_of_rng</code>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="af87a2f924c1dfc7d56833742f7fac278" name="af87a2f924c1dfc7d56833742f7fac278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87a2f924c1dfc7d56833742f7fac278">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign with <code>count</code> times <code>value</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">value</td><td>The initial value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >In <img class="formulaInl" alt="$O(count*value)$" src="form_4.png" width="128" height="19"/>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a5fd95c1cb350466705b675216dd5e46a" name="a5fd95c1cb350466705b675216dd5e46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd95c1cb350466705b675216dd5e46a">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type = value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; rng_type &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>an <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code> of <code>rng_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Linear in the cumulative size of the elements in <code>ilist</code>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="aad58859482a46f80420a78617510b4e5" name="aad58859482a46f80420a78617510b4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad58859482a46f80420a78617510b4e5">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element as a view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>If you access an element behind the last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view on the underlying concatenated sequences that acts as a proxy for the element.</dd></dl>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data).. </p>

</div>
</div>
<a id="aceee97c1357cb104562559a98ca490eb" name="aceee97c1357cb104562559a98ca490eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceee97c1357cb104562559a98ca490eb">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element as a view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>If you access an element behind the last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view on the underlying concatenated sequences that acts as a proxy for the element.</dd></dl>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data).. </p>

</div>
</div>
<a id="af091bdbd6e31e0dc46b78bf0d3a8470c" name="af091bdbd6e31e0dc46b78bf0d3a8470c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af091bdbd6e31e0dc46b78bf0d3a8470c">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last element as a view. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view on the underlying concatenated sequences that acts as a proxy for the element.</dd></dl>
<p>Calling back on an empty container is undefined. In debug mode an assertion checks the size of the container. </p><h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data).. </p>

</div>
</div>
<a id="a9be82a9beaf538eaa5f35def3dfed2f5" name="a9be82a9beaf538eaa5f35def3dfed2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be82a9beaf538eaa5f35def3dfed2f5">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last element as a view. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view on the underlying concatenated sequences that acts as a proxy for the element.</dd></dl>
<p>Calling back on an empty container is undefined. In debug mode an assertion checks the size of the container. </p><h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data).. </p>

</div>
</div>
<a id="a73f399787dab851ea6411ea05a6cf087" name="a73f399787dab851ea6411ea05a6cf087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f399787dab851ea6411ea05a6cf087">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a>.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="acdc9768f3b3438caf85c5a332af8908f" name="acdc9768f3b3438caf85c5a332af8908f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc9768f3b3438caf85c5a332af8908f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a>.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a67463019572b330feaafba7bbf80b7cc" name="a67463019572b330feaafba7bbf80b7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67463019572b330feaafba7bbf80b7cc">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that the container has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the currently allocated storage.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>This does not operate on underlying concat container, see <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a>.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a350904ea62c071d535423ba5cecb1958" name="a350904ea62c071d535423ba5cecb1958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350904ea62c071d535423ba5cecb1958">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a>.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a9ff960838cf08a11eedb8296c2420bf0" name="a9ff960838cf08a11eedb8296c2420bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff960838cf08a11eedb8296c2420bf0">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>This element acts as a placeholder; attempting to dereference it results in undefined behaviour.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a70ba664013a6486a88de1e0a277f7548" name="a70ba664013a6486a88de1e0a277f7548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ba664013a6486a88de1e0a277f7548">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the container. </p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a4678ee666dd44987efb55020cf739a84" name="a4678ee666dd44987efb55020cf739a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4678ee666dd44987efb55020cf739a84">&#9670;&nbsp;</a></span>concat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the concatenation of all members. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view proxy on the concatenation of underlying sequences.</dd></dl>
<p>This is a safe way of accessing the internal concatenated representation, i.e. you cannot do operations that would invalidate this container (like insert or resize), but you can write to the individual positions.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data). </p>

</div>
</div>
<a id="aac390322a20e99fcfe49d6d7fd439003" name="aac390322a20e99fcfe49d6d7fd439003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac390322a20e99fcfe49d6d7fd439003">&#9670;&nbsp;</a></span>concat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the concatenation of all members. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view proxy on the concatenation of underlying sequences.</dd></dl>
<p>This is a safe way of accessing the internal concatenated representation, i.e. you cannot do operations that would invalidate this container (like insert or resize), but you can write to the individual positions.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data). </p>

</div>
</div>
<a id="a44cf54faf3c6e87cc6156feda6be1562" name="a44cf54faf3c6e87cc6156feda6be1562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cf54faf3c6e87cc6156feda6be1562">&#9670;&nbsp;</a></span>concat_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concat_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the concatenated size the container has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the currently allocated storage.</dd></dl>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a01246b34e006f8150a993cadcdd02282" name="a01246b34e006f8150a993cadcdd02282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01246b34e006f8150a993cadcdd02282">&#9670;&nbsp;</a></span>concat_reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concat_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a> to a value that's greater or equal to new_cap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>The new capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If new_cap &gt; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a02c2256d883b3a625dfccde922d2d25b" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/exception.html">std::exception</a></td><td>Any exception thrown by <code>Allocator::allocate()</code> (typically <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc.html">std::bad_alloc</a></code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Increase the capacity of the underlying concatenated sequence to a value that's greater or equal to new_cap. If new_cap is greater than the current <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a>, new storage is allocated, otherwise the method does nothing. If new_cap is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a>, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</p>
<h3>Complexity</h3>
<p >At most linear in the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a> of the container.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a0fd1da21587b6d01165f24b1fc318290" name="a0fd1da21587b6d01165f24b1fc318290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd1da21587b6d01165f24b1fc318290">&#9670;&nbsp;</a></span>concat_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::concat_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cumulative size of all elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The cumulative size of elements in the container.</dd></dl>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a2f2b8a5790c66dd42c9d0b52e044479b" name="a2f2b8a5790c66dd42c9d0b52e044479b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2b8a5790c66dd42c9d0b52e044479b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty, <code>false</code> otherwise.</dd></dl>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="ad024ec1aa32a2c1a65710d1681acb215" name="ad024ec1aa32a2c1a65710d1681acb215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad024ec1aa32a2c1a65710d1681acb215">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>This element acts as a placeholder; attempting to dereference it results in undefined behaviour.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a92c6386b3ddaaac34cd0617c14a11440" name="a92c6386b3ddaaac34cd0617c14a11440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c6386b3ddaaac34cd0617c14a11440">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>This element acts as a placeholder; attempting to dereference it results in undefined behaviour.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a1e281e9ae928e3b37a9f3eb6c01ac50a" name="a1e281e9ae928e3b37a9f3eb6c01ac50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e281e9ae928e3b37a9f3eb6c01ac50a">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified elements from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Begin of range to erase. </td></tr>
    <tr><td class="paramname">last</td><td>Behind the end of range to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if <code>first==last</code>.</dd></dl>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator.</p>
<p >The iterator first does not need to be dereferenceable if first==last: erasing an empty range is a no-op.</p>
<h3>Complexity</h3>
<p >Linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak, but container my contain invalid data after exceptions is thrown. </p>

</div>
</div>
<a id="acc4bcf58efeef7baef0c7859120c5a47" name="acc4bcf58efeef7baef0c7859120c5a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4bcf58efeef7baef0c7859120c5a47">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified elements from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Remove the element at pos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if <code>first==last</code>.</dd></dl>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator.</p>
<p >The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator (which is valid, but is not dereferencable) cannot be used as a value for pos.</p>
<h3>Complexity</h3>
<p >Linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak, but container my contain invalid data after exceptions is thrown. </p>

</div>
</div>
<a id="a69eb0da29eede9634012f757c968ecb2" name="a69eb0da29eede9634012f757c968ecb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69eb0da29eede9634012f757c968ecb2">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first element as a view. Calling front on an empty container is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view on the underlying concatenated sequences that acts as a proxy for the element.</dd></dl>
<p>Calling front on an empty container is undefined. In debug mode an assertion checks the size of the container. </p><h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data). </p>

</div>
</div>
<a id="a461bca9014754a68fbaeabddba424506" name="a461bca9014754a68fbaeabddba424506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461bca9014754a68fbaeabddba424506">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first element as a view. Calling front on an empty container is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view on the underlying concatenated sequences that acts as a proxy for the element.</dd></dl>
<p>Calling front on an empty container is undefined. In debug mode an assertion checks the size of the container. </p><h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data). </p>

</div>
</div>
<a id="a9ecd03de0b3a83ae585a29bd34951f96" name="a9ecd03de0b3a83ae585a29bd34951f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecd03de0b3a83ae585a29bd34951f96">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">begin_iterator_type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">end_iterator_type&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range <code>[first, last)</code> before position in the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">begin_iterator_type</td><td>Must satisfy std::forward_iterator and <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a3a56f3c5956f5ac72c42ec90cb5ad8af">iter_value_t_is_compatible_with_value_type</a>. </td></tr>
    <tr><td class="paramname">end_iterator_type</td><td>Must satisfy std::sized_sentinel_for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. <code>pos</code> may be the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">first</td><td>Begin of range to insert. </td></tr>
    <tr><td class="paramname">last</td><td>Behind the end of range to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if <code>first==last</code>.</dd></dl>
<p>The behaviour is undefined if first and last are iterators into <code>*this</code>.</p>
<p >Causes reallocation if the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than the old <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>. If the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<h3>Complexity</h3>
<p >Worst-case linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>. This is a drawback over e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;alphabet&gt;&gt;</code>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak, but container my contain invalid data after exceptions is thrown. </p>

</div>
</div>
<a id="afe7363e23fdb65c2d6114b502c854d4b" name="afe7363e23fdb65c2d6114b502c854d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7363e23fdb65c2d6114b502c854d4b">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value before position in the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy std::ranges::forward_range and have the same <code>value_type</code> as <code>value_type</code> (i.e. <code>value_type</code>'s <code>value_type</code>!). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. <code>pos</code> may be the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">value</td><td>Element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the inserted value.</dd></dl>
<p>Causes reallocation if the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than the old <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>. If the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<h3>Complexity</h3>
<p >Worst-case linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>. This is a drawback over e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;alphabet&gt;&gt;</code>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak, but container my contain invalid data after exceptions is thrown.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concatenated__sequences_8hpp.html">bio/ranges/container/concatenated_sequences.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences&lt;bio::alphabet::dna4_vector&gt;</a> foobar;</div>
<div class="line">    foobar.<a class="code hl_function" href="classbio_1_1ranges_1_1concatenated__sequences.html#afe7363e23fdb65c2d6114b502c854d4b">insert</a>(foobar.<a class="code hl_function" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440">end</a>(), <span class="stringliteral">&quot;ACGT&quot;</span>_dna4);</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, foobar[0]); <span class="comment">// &quot;ACGT&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassbio_1_1ranges_1_1concatenated__sequences_html_a92c6386b3ddaaac34cd0617c14a11440"><div class="ttname"><a href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440">bio::ranges::concatenated_sequences::end</a></div><div class="ttdeci">iterator end() noexcept</div><div class="ttdoc">Returns an iterator to the element following the last element of the container.</div><div class="ttdef"><b>Definition:</b> concatenated_sequences.hpp:448</div></div>
<div class="ttc" id="aclassbio_1_1ranges_1_1concatenated__sequences_html_afe7363e23fdb65c2d6114b502c854d4b"><div class="ttname"><a href="classbio_1_1ranges_1_1concatenated__sequences.html#afe7363e23fdb65c2d6114b502c854d4b">bio::ranges::concatenated_sequences::insert</a></div><div class="ttdeci">iterator insert(const_iterator pos, rng_type &amp;&amp;value)</div><div class="ttdoc">Inserts value before position in the container.</div><div class="ttdef"><b>Definition:</b> concatenated_sequences.hpp:812</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9bdf497f3e7d20a18b27f662a8b2335c" name="a9bdf497f3e7d20a18b27f662a8b2335c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdf497f3e7d20a18b27f662a8b2335c">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of value before position in the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. <code>pos</code> may be the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">count</td><td>Number of copies. </td></tr>
    <tr><td class="paramname">value</td><td>Element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if <code>count==0</code>.</dd></dl>
<p>Causes reallocation if the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than the old <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>. If the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<h3>Complexity</h3>
<p >Worst-case linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>. This is a drawback over e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;alphabet&gt;&gt;</code>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak, but container my contain invalid data after exceptions is thrown.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concatenated__sequences_8hpp.html">bio/ranges/container/concatenated_sequences.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences&lt;bio::alphabet::dna4_vector&gt;</a> foobar;</div>
<div class="line">    foobar.<a class="code hl_function" href="classbio_1_1ranges_1_1concatenated__sequences.html#afe7363e23fdb65c2d6114b502c854d4b">insert</a>(foobar.<a class="code hl_function" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440">end</a>(), 2, <span class="stringliteral">&quot;ACGT&quot;</span>_dna4);</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, foobar[0]); <span class="comment">// &quot;ACGT&quot;</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, foobar[1]); <span class="comment">// &quot;ACGT&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac8c7eaf8c5ff9e20e79d5271ca9842ed" name="ac8c7eaf8c5ff9e20e79d5271ca9842ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c7eaf8c5ff9e20e79d5271ca9842ed">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ae1a3f2fb0ead878373d8f82c3a82429c">iterator</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a9570fa4466c9cd3fa8b083f30c745c34">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; rng_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list before position in the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. <code>pos</code> may be the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">ilist</td><td>Initializer list with values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if <code>ilist</code> is empty.</dd></dl>
<p>Causes reallocation if the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than the old <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>. If the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<h3>Complexity</h3>
<p >Worst-case linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>. This is a drawback over e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;alphabet&gt;&gt;</code>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak, but container my contain invalid data after exceptions is thrown. </p>

</div>
</div>
<a id="a02c2256d883b3a625dfccde922d2d25b" name="a02c2256d883b3a625dfccde922d2d25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c2256d883b3a625dfccde922d2d25b">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#acdc9768f3b3438caf85c5a332af8908f" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a>) for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<p>This value typically reflects the theoretical limit on the size of the container. At runtime, the size of the container may be limited to a value smaller than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a02c2256d883b3a625dfccde922d2d25b" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a> by the amount of RAM available. </p><h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a89023678e7c85d80d140de47939c4db6" name="a89023678e7c85d80d140de47939c4db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89023678e7c85d80d140de47939c4db6">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range value_type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a> &amp; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type_t &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct/assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type_t</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>an <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code> of <code>value_type_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Linear in the cumulative size of the elements in <code>ilist</code>.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a7bcc4492613cbe9b799f49763a41e8a7" name="a7bcc4492613cbe9b799f49763a41e8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcc4492613cbe9b799f49763a41e8a7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#ade58ffa47c048d0d75bb0607246e4913">reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element as a view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view on the underlying concatenated sequences that acts as a proxy for the element.</dd></dl>
<p>Accessing an element behind the last causes undefined behaviour. In debug mode an assertion checks the size of the container. </p><h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data).. </p>

</div>
</div>
<a id="a7d8f7ede2fc4804a2e8e5f45a707248c" name="a7d8f7ede2fc4804a2e8e5f45a707248c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8f7ede2fc4804a2e8e5f45a707248c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a99379ad28d44f3a4c12d78556fa94e57">const_reference</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element as a view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::ranges::view on the underlying concatenated sequences that acts as a proxy for the element.</dd></dl>
<p>Accessing an element behind the last causes undefined behaviour. In debug mode an assertion checks the size of the container. </p><h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (never modifies data).. </p>

</div>
</div>
<a id="a79867e2d296a9e0512acc3341c886a68" name="a79867e2d296a9e0512acc3341c886a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79867e2d296a9e0512acc3341c886a68">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. </p>
<p >Calling pop_back on an empty container is undefined. In debug mode an assertion will be thrown.</p>
<p >No iterators or references except for <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#af091bdbd6e31e0dc46b78bf0d3a8470c" title="Return the last element as a view.">back()</a> and <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a> are invalidated.</p>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No exception is thrown in release mode.</p>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a2a5a5172c5aa0b28070b06dffa27546f" name="a2a5a5172c5aa0b28070b06dffa27546f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5a5172c5aa0b28070b06dffa27546f">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::push_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends an empty element to the end of the container. </p>
<p >This conceptionally adds an empty element to the container, i.e. the "outer container" grows by 1 and the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#af091bdbd6e31e0dc46b78bf0d3a8470c" title="Return the last element as a view.">back()</a> will be empty.</p>
<p >No iterators are invalidated.</p>
<h3>Complexity</h3>
<p >Amortised constant. Wort-case linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak. However, the container may contain invalid data after an exception is thrown. </p>

</div>
</div>
<a id="a238c4f65d3eb4ec027dc8f55f865db0c" name="a238c4f65d3eb4ec027dc8f55f865db0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238c4f65d3eb4ec027dc8f55f865db0c">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append.</td></tr>
  </table>
  </dd>
</dl>
<p>This conceptionally adds another element to the container with the specified content, i.e. the "outer container" grows by 1.</p>
<p >If the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a> is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a>, all iterators and references (including the past-the-end iterator) are invalidated. Otherwise, only the past-the-end iterator is invalidated.</p>
<h3>Complexity</h3>
<p >Amortised linear in the size of value. Wort-case linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak, but container my contain invalid data after exceptions is thrown. </p>

</div>
</div>
<a id="a80bfec6e20aa7300ebc09ff1170d4f2e" name="a80bfec6e20aa7300ebc09ff1170d4f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bfec6e20aa7300ebc09ff1170d4f2e">&#9670;&nbsp;</a></span>push_back_inner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::push_back_inner </td>
          <td>(</td>
          <td class="paramtype">std::ranges::range_value_t&lt; underlying_container_type &gt; const&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element-of-element value to the end of the underlying container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append.</td></tr>
  </table>
  </dd>
</dl>
<p>This conceptionally performs a <code><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a2a5a5172c5aa0b28070b06dffa27546f" title="Appends an empty element to the end of the container.">push_back()</a></code> on the <code><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#af091bdbd6e31e0dc46b78bf0d3a8470c" title="Return the last element as a view.">back()</a></code> of this container, i.e. that last inner container grows by 1.</p>
<p >If the new <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a> is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a>, all iterators and references (including the past-the-end iterator) are invalidated. Otherwise, only the past-the-end iterator is invalidated.</p>
<h3>Complexity</h3>
<p >Amortised constant. Wort-case linear in <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>.</p>
<h3>Exceptions</h3>
<p >Basic exception guarantee, i.e. guaranteed not to leak. However, the container may contain invalid data after an exception is thrown. </p>

</div>
</div>
<a id="a0fcc1c5ffcafbd0a4e3cc3e1e7895514" name="a0fcc1c5ffcafbd0a4e3cc3e1e7895514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcc1c5ffcafbd0a4e3cc3e1e7895514">&#9670;&nbsp;</a></span>raw_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; decltype(data_values) &amp;, decltype(data_delimiters) &amp; &gt; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::raw_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides direct, unsafe access to underlying data structures. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a> of the concatenated sequences and the delimiter string.</dd></dl>
<p>The exact representation of the data is implementation defined. Do not rely on it for API stability. </p>

</div>
</div>
<a id="aaf220abc76ac2d81cecf1b29a32656e5" name="aaf220abc76ac2d81cecf1b29a32656e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf220abc76ac2d81cecf1b29a32656e5">&#9670;&nbsp;</a></span>raw_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; decltype(data_values) const &amp;, decltype(data_delimiters) const &amp; &gt; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::raw_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides direct, unsafe access to underlying data structures. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a> of the concatenated sequences and the delimiter string.</dd></dl>
<p>The exact representation of the data is implementation defined. Do not rely on it for API stability. </p>

</div>
</div>
<a id="a7d24f956f652e3a9e9b19ca3a88906b1" name="a7d24f956f652e3a9e9b19ca3a88906b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d24f956f652e3a9e9b19ca3a88906b1">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity to a value that's greater or equal to new_cap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>The new capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If new_cap &gt; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a02c2256d883b3a625dfccde922d2d25b" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/exception.html">std::exception</a></td><td>Any exception thrown by <code>Allocator::allocate()</code> (typically <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc.html">std::bad_alloc</a></code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Increase the capacity of the vector to a value that's greater or equal to new_cap. If new_cap is greater than the current <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, new storage is allocated, otherwise the method does nothing. If new_cap is greater than <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</p>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>This does not operate on underlying concat container, see <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a01246b34e006f8150a993cadcdd02282" title="Increase the concat_capacity() to a value that&#39;s greater or equal to new_cap.">concat_reserve()</a>.</p>
<h3>Complexity</h3>
<p >At most linear in the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the container.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a774fddde8d5db3bbc7975463d85a42a9" name="a774fddde8d5db3bbc7975463d85a42a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774fddde8d5db3bbc7975463d85a42a9">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If count &gt; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a02c2256d883b3a625dfccde922d2d25b" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/exception.html">std::exception</a></td><td>Any exception thrown by <code>Allocator::allocate()</code> (typically <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc.html">std::bad_alloc</a></code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Increase the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the vector to count.</p>
<p >If the current <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> is smaller than count, new storage is allocated and all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise only the past-the-end iterator is invalidated.</p>
<p >If the current size is greater than count, the container is reduced to its first count elements. Capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a79867e2d296a9e0512acc3341c886a68" title="Removes the last element of the container.">pop_back()</a> calls.</p>
<h3>Complexity</h3>
<p >At most linear in the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the container.</p>
<h3>Exceptions</h3>
<p >Only new size: Strong exception guarantee (no data is modified in case an exception is thrown). [only new size]</p>
<p >New default value: Basic exception guarantee, i.e. guaranteed not to leak, but container my contain bogus data after exceptions is thrown. </p>

</div>
</div>
<a id="a92ffe9d52927fb05a212e6e2d9ceb1b1" name="a92ffe9d52927fb05a212e6e2d9ceb1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ffe9d52927fb05a212e6e2d9ceb1b1">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range rng_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rng_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rng_type</td><td>The type of range to be inserted; must satisfy <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a6b14c15b62b94547dda1b0f39f5c4eb6">is_compatible_with_value_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Instead of appending empty containers, append copies of value. </td></tr>
    <tr><td class="paramname">count</td><td>The new size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If count &gt; <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a02c2256d883b3a625dfccde922d2d25b" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/exception.html">std::exception</a></td><td>Any exception thrown by <code>Allocator::allocate()</code> (typically <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc.html">std::bad_alloc</a></code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Increase the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the vector to count.</p>
<p >If the current <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> is smaller than count, new storage is allocated and all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise only the past-the-end iterator is invalidated.</p>
<p >If the current size is greater than count, the container is reduced to its first count elements. Capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a79867e2d296a9e0512acc3341c886a68" title="Removes the last element of the container.">pop_back()</a> calls.</p>
<h3>Complexity</h3>
<p >At most linear in the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the container.</p>
<h3>Exceptions</h3>
<p >Only new size: Strong exception guarantee (no data is modified in case an exception is thrown). [only new size]</p>
<p >New default value: Basic exception guarantee, i.e. guaranteed not to leak, but container my contain bogus data after exceptions is thrown. </p>

</div>
</div>
<a id="adac6ad4833ec10922c127ff819c87bd4" name="adac6ad4833ec10922c127ff819c87bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac6ad4833ec10922c127ff819c87bd4">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>
<p >It is a non-binding request to reduce <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a67463019572b330feaafba7bbf80b7cc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> to <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> and <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a44cf54faf3c6e87cc6156feda6be1562" title="Returns the concatenated size the container has currently allocated space for.">concat_capacity()</a> to <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a0fd1da21587b6d01165f24b1fc318290" title="Returns the cumulative size of all elements in the container.">concat_size()</a>. It depends on the implementation if the request is fulfilled. If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</p>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>This effects both underlying data structures.</p>
<h3>Complexity</h3>
<p >At most linear in the <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a805aa9beca299259b7ef66b6953f21a5" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the container.</p>
<h3>Exceptions</h3>
<p >Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a805aa9beca299259b7ef66b6953f21a5" name="a805aa9beca299259b7ef66b6953f21a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805aa9beca299259b7ef66b6953f21a5">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a5898489c8cec16d613ae365574bb7c27">size_type</a> <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. std::distance(<a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#acdc9768f3b3438caf85c5a332af8908f" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html#a92c6386b3ddaaac34cd0617c14a11440" title="Returns an iterator to the element following the last element of the container.">end()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="aa2855754ba06c11303466d89480227de" name="aa2855754ba06c11303466d89480227de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2855754ba06c11303466d89480227de">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap contents with another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The other instance to swap with.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<a id="a8cd6bcb6374a0519931ffa1eacaac0fe" name="a8cd6bcb6374a0519931ffa1eacaac0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd6bcb6374a0519931ffa1eacaac0fe">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename underlying_container_type , typename data_delimiters_type  = std::vector&lt;typename underlying_container_type::size_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">bio::ranges::concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a>&lt; underlying_container_type, data_delimiters_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap contents with another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The other instance to swap with.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p >Constant.</p>
<h3>Exceptions</h3>
<p >No-throw guarantee. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bio/ranges/container/<a class="el" href="concatenated__sequences_8hpp_source.html">concatenated_sequences.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="navelem"><a class="el" href="namespacebio.html">bio</a></li><li class="navelem"><a class="el" href="namespacebio_1_1ranges.html">ranges</a></li><li class="navelem"><a class="el" href="classbio_1_1ranges_1_1concatenated__sequences.html">concatenated_sequences</a></li>
    <li class="footer">Generated on Mon Jul 25 2022 14:00:35 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
