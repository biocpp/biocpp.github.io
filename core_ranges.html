<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: Ranges</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">BioC++<span id="projectnumber">&#160;core-0.7.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('core_ranges.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Ranges </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md44">Motivation</a></li>
<li class="level1"><a href="#autotoc_md45">Ranges</a><ul><li class="level2"><a href="#autotoc_md46">Range concepts</a></li>
<li class="level2"><a href="#autotoc_md47">Storage behaviour</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md48">Views</a><ul><li class="level2"><a href="#autotoc_md49">Lazy-evaluation</a></li>
<li class="level2"><a href="#autotoc_md50">Combinability</a></li>
<li class="level2"><a href="#autotoc_md51">View concepts</a></li>
<li class="level2"><a href="#autotoc_md52">Views in the standard library and in BioC++</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md53">Containers</a><ul><li class="level2"><a href="#autotoc_md54">The bitcompressed vector</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_hannes_devel_biocpp_core_doc_core_tutorial_ranges_index"></a></p>
<p>This tutorial introduces the notion of <em>ranges</em>, a C++20 feature that BioC++ makes strong use of.</p>
<table class="doxtable">
<tr>
<th>Difficulty</th><td>Moderate</td></tr>
<tr>
<th>Duration</th><td>90 min</td></tr>
<tr>
<th>Prerequisite tutorials</th><td><a class="el" href="core_concepts.html">C++ Concepts</a></td></tr>
<tr>
<th>Recommended reading</th><td></td></tr>
</table>
<h1><a class="anchor" id="autotoc_md44"></a>
Motivation</h1>
<p>Traditionally most generic algorithms in the C++ standard library, like <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/algorithm/sort.html">std::sort</a>, take a pair of iterators (e.g. the object returned by <code>begin()</code>). If you want to sort a <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> <code>v</code>, you have to call <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/algorithm/sort.html">std::sort</a>(v.begin(), v.end())</code> and not <code>std::sort(v)</code>. Why was this design with iterators chosen? It is more flexible, because it allows e.g.:</p><ul>
<li>sorting only all elements after the fifth one: <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/algorithm/sort.html">std::sort</a>(v.begin() + 5, v.end())</code></li>
<li>using non-standard iterators like reverse iterators: <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/algorithm/sort.html">std::sort</a>(v.rbegin() + 5, v.rend())</code> (sorts in reverse order)</li>
</ul>
<p>But this interface is less intuitive than just calling <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/algorithm/sort.html">std::sort</a> on the entity that you wish to sort and it allows for more mistakes, e.g. mixing two incompatible iterators. C++20 introduces the notion of <em>ranges</em> and provides algorithms that accept such in the namespace <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/namespacestd_1_1ranges.html">std::ranges</a>::</code>, e.g. <code>std::ranges::sort(v)</code> now works if <code>v</code> is range – and vectors are ranges!</p>
<p>What about the two examples that suggest superiority of the iterator-based approach? In C++20 you can do the following:</p><ul>
<li>sorting only all elements after the fifth one: <code>std::ranges::sort(std::views::drop(v, 5))</code></li>
<li>sorting in reverse order: <code>std::ranges::sort(std::views::reverse(v))</code></li>
</ul>
<p>We will discuss later what <code>std::views::reverse(v)</code> does, for now it is enough to understand that it returns something that appears like a container and that <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/algorithm/ranges/sort.html">std::ranges::sort</a> can sort it. Later we will see that this approach offers even more flexibility than working with iterators.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
Ranges</h1>
<p><em>Ranges</em> are an abstraction of "a collection of items", or "something iterable". The most basic definition requires only the existence of <code>begin()</code> and <code>end()</code> on the range.</p>
<p>There are different ways to classify ranges, one way is through the capabilities of its iterator.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Range concepts</h2>
<p>Ranges are typically either <a class="el" href="">input ranges </a> (they can be read from) or <a class="el" href="">output ranges </a> (they can be written to) or both. E.g. a <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;int&gt;</code> is both, but a <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;int&gt; const</code> would only be an input range.</p>
<p><a class="el" href="">Input ranges </a> have different <em>strengths</em> that are realised through more refined concepts (i.e. types that model a stronger concept, always also model the weaker one):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::input_range   </td><td class="markdownTableBodyNone">can be iterated from beginning to end <b>at least once</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::forward_range   </td><td class="markdownTableBodyNone">can be iterated from beginning to end <b>multiple times</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::bidirectional_range   </td><td class="markdownTableBodyNone">iterator can also move backwards with <code>--</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::random_access_range   </td><td class="markdownTableBodyNone">you can jump to elements <b>in constant-time</b> <code>[]</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::contiguous_range   </td><td class="markdownTableBodyNone">elements are always stored consecutively in memory   </td></tr>
</table>
<p>For the well-known containers from the standard library this matrix shows which concepts they model:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/forward_list.html">std::forward_list</a>   </th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/list.html">std::list</a>   </th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>   </th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/array.html">std::array</a>   </th><th class="markdownTableHeadCenter"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::input_range   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::forward_range   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::bidirectional_range   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::random_access_range   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::contiguous_range   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td></tr>
</table>
<p>There are also range concepts that are independent of input or output or one of the above concept, e.g. std::ranges::sized_range which requires that the size of a range can be computed and in constant time.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Storage behaviour</h2>
<p><b>Containers</b> are the ranges most well known, they own their elements. BioC++ makes use of standard STL containers like <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code>, but also implements some custom containers.</p>
<p><b>Views</b> are ranges that are usually defined on another range and transform the underlying range via some algorithm or operation. The exact definition of what a view is, has changed over time and is not covered here, but many of the key features are described below.</p>
<p>The storage behaviour is orthogonal to the range concepts defined by the iterators mentioned above, i.e. you can have a container that satisfies std::ranges::random_access_range (e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> does, but <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/list.html">std::list</a></code> does not) and you can have views that do so or don't.</p>
<h1><a class="anchor" id="autotoc_md48"></a>
Views</h1>
<p>As mentioned above, views are a specific kind of range. They are incredibly useful and you will find them throughout the library.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Lazy-evaluation</h2>
<p>A key feature of views is that whatever transformation they apply, they do so at the moment you request an element, not when the view is created.</p>
<div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</div>
<div class="line"><span class="keyword">auto</span> v = std::views::reverse(vec);</div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><p>Here <code>v</code> is a view; creating it neither changes <code>vec</code>, nor does <code>v</code> store any elements. The time it takes to construct <code>v</code> and its size in memory is independent of the size of <code>vec</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</div>
<div class="line"><span class="keyword">auto</span> v = std::views::reverse(vec);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; *v.begin() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="ttc" id="acout_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a></div></div>
</div><!-- fragment --><p>This will print "6", but the important thing is that resolving the first element of <code>v</code> to the last element of <code>vec</code> happens <b>on-demand</b>. This guarantees that views can be used as flexibly as iterators, but it also means that if the view performs an expensive transformation, it will have to do so repeatedly if the same element is requested multiple times.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Combinability</h2>
<p>You may have wondered why we wrote</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = std::views::reverse(vec);</div>
</div><!-- fragment --><p>and not </p><div class="fragment"><div class="line">std::views::reverse v{vec};</div>
</div><!-- fragment --><p>That's because <code>std::views::reverse</code> is not the view itself, it's an <em>adaptor</em> that takes the underlying range (in our case the vector) and returns a view object over the vector. The exact type of this view is hidden behind the <code>auto</code> statement. This has the advantage, that we don't need to worry about the template arguments of the view type, but more importantly the adaptor has an additional feature: it can be <em>chained</em> with other adaptors!</p>
<div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</div>
<div class="line"><span class="keyword">auto</span> v = vec | std::views::reverse | std::views::drop(2);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; *v.begin() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><p>What will this print?  <div class="assignment"> <details><summary><b>Hint</b></summary>  It will print "4".  </details> </div> </p>
<p>In the above example the vector is "piped" (similar to the unix command line) into the reverse adaptor and then into the drop adaptor and a combined view object is returned. Note that accessing the 0th element of the view is still lazy, determining which element it maps to happens at the time of access.</p>
<p> <div class="assignemnt"><h4>Assignment 1: Fun with views I</h4><div class="assignment_content"> Look up the documentation of std::views::transform and std::views::filter. Both take a invocable object as parameter, e.g. a lambda function. std::views::transform applies the lambda on each element in the underlying range and std::views::filter filter "removes" those elements that its lambda function evaluates to false for.</p>
<p>What does this imply for argument types and return types of the lambda functions?</p>
<p> <div class="assignment"> <details><summary><b>Hint</b></summary>  The transform's lambda should return something of the same type as the input and the filter's lambda should return true or false!  </details> </div> </p>
<p>Task: Create a view on <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</code> that filters out all uneven numbers and squares the remaining (even) values, i.e. </p><div class="fragment"><div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</div>
<div class="line"><span class="keyword">auto</span> v = vec | <span class="comment">// ...?</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; *v.begin() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// should print 4</span></div>
</div><!-- fragment --><p>  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span>                    <span class="comment">// include all of the standard library&#39;s views</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</div>
<div class="line">    <span class="keyword">auto</span> v = vec | std::views::filter([] (<span class="keyword">auto</span> <span class="keyword">const</span> i) { <span class="keywordflow">return</span> i % 2 == 0; })</div>
<div class="line">                 | std::views::transform([] (<span class="keyword">auto</span> <span class="keyword">const</span> i) { <span class="keywordflow">return</span> i*i; });</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; *v.begin() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// prints 4</span></div>
<div class="line">}</div>
<div class="ttc" id="aiostream_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a></div></div>
<div class="ttc" id="aranges_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a></div></div>
</div><!-- fragment --><p>  </details> </div> </p>
<h2><a class="anchor" id="autotoc_md51"></a>
View concepts</h2>
<p>Views are a specific kind of range that is formalised in the std::ranges::view concept. Every view returned by a view adaptor models this concept, but which other range concepts are modeled by a view?</p>
<p>It depends on the underlying range and also the view itself. With few exceptions, views don't model more/stronger range concepts than their underlying range (other than std::ranges::view) and they try to preserve as much of the underlying range's concepts as possible. For instance the view returned by <code>std::views::reverse</code> models std::ranges::random_access_range (and weaker concepts) iff the underlying range also models the respective concept. It never models std::ranges::contiguous_range, because the third element of the view is not located immediately after the second in memory (but instead before the second).</p>
<p>Perhaps surprising to some, many views also model std::ranges::output_range if the underlying range does, i.e. <b>views are not read-only</b>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> vec{1, 2, 3, 4, 5, 6};</div>
<div class="line"><span class="keyword">auto</span> v = vec | std::views::reverse | std::views::drop(2);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; *v.begin() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">*v.begin() = 42;                  <span class="comment">// now vec == {1, 2, 3, 42, 5, 6 } !!</span></div>
</div><!-- fragment --><p> <div class="assignemnt"><h4>Assignment 2: Fun with views II</h4><div class="assignment_content"> Have a look at the solution to the previous assignment (filter+transform). Which of the following concepts do you think <code>v</code> models?</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept   </th><th class="markdownTableHeadCenter">yes/no?    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::input_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::forward_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::bidirectional_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::random_access_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::contiguous_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::view   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::sized_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::output_range   </td><td class="markdownTableBodyCenter"></td></tr>
</table>
<p> </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary> </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept   </th><th class="markdownTableHeadCenter">yes/no?    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::input_range   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::forward_range   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::bidirectional_range   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::random_access_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::contiguous_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::view   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">std::ranges::sized_range   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::ranges::output_range   </td><td class="markdownTableBodyCenter"></td></tr>
</table>
<p>Surprised? Let's have a closer look at the std::views::filter view. The filter view only returns the value of the underlying range for which the given predicate evaluates to <code>true</code>. To know which value is an element of the filter view, the view has to look at each of them. Thus, it must scan the underlying range value-by-value and cannot jump to an arbitrary location in constant time since it cannot know how many elements it had to skip without looking at them. Accordingly, the std::views::filter preserves only std::ranges::bidirectional_range, because it can scan the text in reverse order as well. Since the view cannot guarantee that the values lie in contiguous memory, it can also not preserve std::ranges::contiguous_range. Similarly, the view cannot model std::ranges::sized_range as it cannot determine the number of values not filtered out in constant time.</p>
<p>The transform on the other hand produces a new element on every access (the result of the multiplication), therefore <code>v</code> is not a std::ranges::output_range, you cannot assign values to its elements. Note that this prevents modelling the std::ranges::contiguous_range as well because values are created on-demand and are not stored in memory at all.  </details> </div> </p>
<p>We provide overview tables for all our view adaptors that document which concepts are modelled by the views they return.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Views in the standard library and in BioC++</h2>
<p>The standard library in C++20 provides a number of useful views and BioC++ provides many views, as well. Most views provided by BioC++ are specific to biological operations, like bio::views::trim_quality which trims sequences based on the quality or bio::views::complement which generates the complement of a nucleotide sequence. But BioC++ also provides some general purpose views.</p>
<p>Have a look at the <a class="el" href="group__views.html">views-submodule </a> to get an overview of BioC++'s views and also read through the detailed description on that page now that you had a more gentle introduction.</p>
<p> <div class="assignemnt"><h4>Assignment 3: Fun with views III</h4><div class="assignment_content"> Create a small program that</p><ol type="1">
<li>reads a string from the command line (first argument to the program)</li>
<li>"converts" the string to a range of <a class="el" href="classbio_1_1alphabet_1_1dna5.html" title="The five letter DNA alphabet of A,C,G,T and the unknown character N..">bio::alphabet::dna5</a> (Bonus: throw an exception if loss of information occurs)</li>
<li>prints the string and it's reverse complement</li>
<li>prints the six-frame translation of the string</li>
</ol>
<p>Use views to implement steps 2.-4.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/ranges.html">ranges</a>&gt;</span>                               <span class="comment">// include all of the standard library&#39;s views</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ranges_2views_2all_8hpp.html">bio/ranges/views/all.hpp</a>&gt;</span>            <span class="comment">// include all of BioCpp&#39;s views</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (argc != 2)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// add error handling here</span></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> s = argv[1];</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> s_as_dna = s | bio::views::char_to&lt;bio::alphabet::dna5&gt;;</div>
<div class="line">    <span class="comment">// Bonus:</span></div>
<div class="line">    <span class="comment">//auto s_as_dna = s | std::views::transform([] (char const c)</span></div>
<div class="line">    <span class="comment">//{</span></div>
<div class="line">    <span class="comment">//    return bio::alphabet::assign_char_strictly_to(c, bio::alphabet::dna5{});</span></div>
<div class="line">    <span class="comment">//});</span></div>
<div class="line"> </div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;Original: {}\n&quot;</span>, s_as_dna);</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;RevComp:  {}\n&quot;</span>, s_as_dna | std::views::reverse | bio::views::complement);</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;Frames:   {}\n&quot;</span>, s_as_dna | bio::views::translate);</div>
<div class="line">}</div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="afmt_8hpp_html"><div class="ttname"><a href="fmt_8hpp.html">fmt.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
<div class="ttc" id="aranges_2views_2all_8hpp_html"><div class="ttname"><a href="ranges_2views_2all_8hpp.html">all.hpp</a></div><div class="ttdoc">Meta-header for the views submodule .</div></div>
</div><!-- fragment --><p>  </details> </div> </p>
<h1><a class="anchor" id="autotoc_md53"></a>
Containers</h1>
<p>Containers are ranges that own their data. BioC++ uses the standard library containers, like <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> and <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> to store elements. For certain use-cases we have introduced our own containers, though.</p>
<p>All standard library containers model std::ranges::forward_range (see above), but these concepts do not cover adding/removing elements. Surprisingly little generic code requires functionality like random inserts, but for back insertion ("appending an element") we have introduced the concepts <a class="el" href="conceptbio_1_1ranges_1_1back__insertable.html" title="Describes range types that can grow in amortised constant time by appending an element.">bio::ranges::back_insertable</a> and <a class="el" href="conceptbio_1_1ranges_1_1back__insertable__with.html" title="Describes range types that can grow in amortised constant time by appending an element of type val_t.">bio::ranges::back_insertable_with</a>.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
The bitcompressed vector</h2>
<p>If you followed the alphabet tutorial closely, you will know that <a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a> needs only two bits to represent its state. However, single objects are always at least a byte (eight bits) big in C++. To store sequences of small alphabets more space-efficiently, we developed <a class="el" href="classbio_1_1ranges_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bio::ranges::bitcompressed_vector</a>.</p>
<p>Open the API documentation of <a class="el" href="classbio_1_1ranges_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bio::ranges::bitcompressed_vector</a>, display the inheritance diagram and read through the interface overview and the detailed description.</p>
<p> <div class="assignemnt"><h4>Assignment 4: The bitcompressed vector</h4><div class="assignment_content"> Create a small program that asks the user for a size and then creates a vector of <a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a> of that size. Add an argument parser flag that allows the user to decide whether <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> or <a class="el" href="classbio_1_1ranges_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bio::ranges::bitcompressed_vector</a> is used. After creating the vector, print its size.</p>
<p>Measure and compare the amount of main memory that your program uses depending on the vector implementation. On Linux based systems use <code>/usr/bin/time -v &lt;program&gt; &lt;args&gt;</code> and look for "Maximum resident set size". (Not to be confused with the built-in Bash time command! So use the full path <code>/usr/bin/time</code>)</p>
<p>On macOS and BSD use <code>/usr/bin/time -l &lt;program&gt; &lt;args&gt;</code> and look for "maximum resident set size".</p>
<dl class="section note"><dt>Note</dt><dd>This command diplays the peak memory usage and only gives you a first impression. You can use [valgrind] (<a href="https://valgrind.org/docs/manual/ms-manual.html">https://valgrind.org/docs/manual/ms-manual.html</a>) if you want to have a more detailed analysis of your memory consumption.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/string_view.html">string_view</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bitcompressed__vector_8hpp.html">bio/ranges/container/bitcompressed_vector.hpp</a>&gt;</span>      <span class="comment">// include bitcompressed vector</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* call with two arguments:</span></div>
<div class="line"><span class="comment"> * SIZE</span></div>
<div class="line"><span class="comment"> * &quot;0&quot; or &quot;1&quot; for vector/bitvector</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (argc != 3)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// add error handling here</span></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> size = <a class="code hl_functionRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string/stoul.html">std::stoull</a>(argv[1]);</div>
<div class="line">    <span class="keywordtype">bool</span> use_bitvector = (<a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string_view.html">std::string_view</a>{argv[2]} == <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (use_bitvector)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_class" href="classbio_1_1ranges_1_1bitcompressed__vector.html">bio::ranges::bitcompressed_vector&lt;bio::alphabet::dna4&gt;</a> vector;</div>
<div class="line">        vector.<a class="code hl_function" href="classbio_1_1ranges_1_1bitcompressed__vector.html#ae3db14b9b3603a07c472ffafca66e7d8">resize</a>(size, <span class="charliteral">&#39;A&#39;</span>_dna4);</div>
<div class="line">        fmt::print(<span class="stringliteral">&quot;Allocated bio::ranges::bitcompressed_vector&lt;bio::alphabet::dna4&gt; of size {}\n&quot;</span>, vector.<a class="code hl_function" href="classbio_1_1ranges_1_1bitcompressed__vector.html#adbe78383a80dbea78c8ebff90b0418bd">size</a>());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna4&gt;</a> vector{<a class="code hl_variable" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d">size</a>};</div>
<div class="line">        fmt::print(<span class="stringliteral">&quot;Allocated std::vector&lt;bio::alphabet::dna4&gt; of size {}\n&quot;</span>, vector.<a class="code hl_function" href="classbio_1_1ranges_1_1bitcompressed__vector.html#adbe78383a80dbea78c8ebff90b0418bd">size</a>());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="abasic_string_view_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/string/basic_string_view.html">std::string_view</a></div></div>
<div class="ttc" id="abitcompressed__vector_8hpp_html"><div class="ttname"><a href="bitcompressed__vector_8hpp.html">bitcompressed_vector.hpp</a></div><div class="ttdoc">Provides bio::ranges::bitcompressed_vector.</div></div>
<div class="ttc" id="aclassbio_1_1ranges_1_1bitcompressed__vector_html"><div class="ttname"><a href="classbio_1_1ranges_1_1bitcompressed__vector.html">bio::ranges::bitcompressed_vector</a></div><div class="ttdoc">A space-optimised version of std::vector that compresses multiple letters into a single byte.</div><div class="ttdef"><b>Definition:</b> bitcompressed_vector.hpp:63</div></div>
<div class="ttc" id="aclassbio_1_1ranges_1_1bitcompressed__vector_html_adbe78383a80dbea78c8ebff90b0418bd"><div class="ttname"><a href="classbio_1_1ranges_1_1bitcompressed__vector.html#adbe78383a80dbea78c8ebff90b0418bd">bio::ranges::bitcompressed_vector::size</a></div><div class="ttdeci">size_type size() const noexcept</div><div class="ttdoc">Returns the number of elements in the container, i.e. std::distance(begin(), end()).</div><div class="ttdef"><b>Definition:</b> bitcompressed_vector.hpp:590</div></div>
<div class="ttc" id="aclassbio_1_1ranges_1_1bitcompressed__vector_html_ae3db14b9b3603a07c472ffafca66e7d8"><div class="ttname"><a href="classbio_1_1ranges_1_1bitcompressed__vector.html#ae3db14b9b3603a07c472ffafca66e7d8">bio::ranges::bitcompressed_vector::resize</a></div><div class="ttdeci">void resize(size_type const count)</div><div class="ttdoc">Resizes the container to contain count elements.</div><div class="ttdef"><b>Definition:</b> bitcompressed_vector.hpp:921</div></div>
<div class="ttc" id="adna4_8hpp_html"><div class="ttname"><a href="dna4_8hpp.html">dna4.hpp</a></div><div class="ttdoc">Provides bio::alphabet::dna4, container aliases and string literals.</div></div>
<div class="ttc" id="agroup__alphabet_html_ga299ddd5bf7e8221cb9d283f8a8d24f8d"><div class="ttname"><a href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d">bio::alphabet::size</a></div><div class="ttdeci">constexpr auto size</div><div class="ttdoc">A type trait that holds the size of a (semi-)alphabet.</div><div class="ttdef"><b>Definition:</b> concept.hpp:517</div></div>
<div class="ttc" id="anamespacebio_1_1alphabet_1_1literals_html"><div class="ttname"><a href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a></div><div class="ttdoc">An inline namespace for alphabet literals. It exists to safely allow using namespace.</div><div class="ttdef"><b>Definition:</b> aa10li.hpp:183</div></div>
<div class="ttc" id="astoul_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/string/basic_string/stoul.html">std::stoull</a></div><div class="ttdeci">T stoull(T... args)</div></div>
<div class="ttc" id="astring_view_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/string_view.html">string_view</a></div></div>
</div><!-- fragment -->  </details> </div>  </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Thu Mar 30 2023 15:25:52 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
