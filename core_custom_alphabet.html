<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: How to write your own alphabet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BioC++
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('core_custom_alphabet.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How to write your own alphabet </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md59">Motivation</a></li>
<li class="level1"><a href="#autotoc_md60">Step by step: Create your own alphabet</a><ul><li class="level2"><a href="#autotoc_md61">Prerequisites</a></li>
<li class="level2"><a href="#autotoc_md62">Semialphabet</a></li>
<li class="level2"><a href="#autotoc_md63">Alphabet</a></li>
<li class="level2"><a href="#autotoc_md64">Shortcut: alphabet base template</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md65">Further examples</a><ul><li class="level2"><a href="#autotoc_md66">Implementation as enum class</a></li>
<li class="level2"><a href="#howto_write_an_alphabet_custom">Adaptation of a third party type</a></li>
<li class="level2"><a href="#autotoc_md67">Implementation of a non-default-constructible class</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_hannes_devel_bio_core_doc_core_write_an_alphabet_index"></a></p>
<p>This HowTo documents how to write a custom alphabet that can be used with the algorithms and data structures in BioC++.</p>
<table class="doxtable">
<tr>
<th>Difficulty</th><td>Moderate</td></tr>
<tr>
<th>Duration</th><td>45 min</td></tr>
<tr>
<th>Prerequisite tutorials</th><td><a class="el" href="core_concepts.html">C++ Concepts</a>, <a class="el" href="core_alphabets.html">Alphabets in BioC++</a></td></tr>
<tr>
<th>Recommended reading</th><td><a class="el" href="group__alphabet.html">Alphabet</a></td></tr>
</table>
<h1><a class="anchor" id="autotoc_md59"></a>
Motivation</h1>
<p>In the <a class="el" href="core_alphabets.html">alphabet tutorial</a> you have learned that alphabets are a core component in BioC++ and represent the smallest unit of biological sequence data. We introduced the common alphabets for nucleotide, amino acid and gap as well as structure and quality annotation. However, in your BioC++ application you may want to implement a custom alphabet in order to work efficiently with BioC++'s algorithms. To achieve this, your custom alphabet must meet certain requirements, which are defined in <a class="el" href="core_concepts.html">concepts</a>.</p>
<p>For detailed information on the alphabet concepts please read the <a class="el" href="group__alphabet.html">Alphabet</a> page. In the following sections we demonstrate how to write an alphabet that models them.</p>
<p>A brief summary of the concepts used in this HowTo:</p><ul>
<li><a class="el" href="interfacebio_1_1alphabet_1_1semialphabet.html" title="The basis for bio::alphabet::alphabet, but requires only rank interface (not char).">bio::alphabet::semialphabet</a> requires your type to have a numerical representation (rank), as well as an alphabet size and comparison operators.</li>
<li><a class="el" href="interfacebio_1_1alphabet_1_1writable__semialphabet.html" title="A refinement of bio::alphabet::semialphabet that adds assignability.">bio::alphabet::writable_semialphabet</a> additionally requires being able to change the value of the object via the rank representation.</li>
<li><a class="el" href="interfacebio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> requires that your type has a visual representation in addition to the numerical representation. Usually this is a character type like char.</li>
<li><a class="el" href="interfacebio_1_1alphabet_1_1writable__alphabet.html" title="Refines bio::alphabet::alphabet and adds assignability.">bio::alphabet::writable_alphabet</a> additionally requires being able to change the value of the object via the char representation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md60"></a>
Step by step: Create your own alphabet</h1>
<p>In the alphabet tutorial we have calculated the GC content of a nucleotide sequence. Guanine and Cytosine are complementary nucleobases, which pair in a DNA molecule by building 3 hydrogen bonds. Adenine and Thymine pair with only 2 hydrogen bonds. As a consequence, we denote Guanine and Cytosine as strong (S) and Adenine and Thymine as weak (W) nucleobases. In this section we want to implement a <a class="el" href="interfacebio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> that consists of the characters <code>S</code> and <code>W</code> to represent strong and weak nucleobases.</p>
<p>Let's start with a simple struct that only holds the alphabet's numerical representation, namely the <b>rank</b> value. It is not specified how the value of an alphabet is stored internally, however alphabets typically store the rank as a member variable. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                         <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line">};</div>
<div class="ttc" id="aalphabet_2concept_8hpp_html"><div class="ttname"><a href="alphabet_2concept_8hpp.html">concept.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The type of the member variable is typically the smallest unsigned integer type that can hold the maximum rank. In our case we have only two values so <code>bool</code> would be sufficient. However <code>bool</code> is not actually smaller than <code>uint8_t</code> and does not always behave like an unsigned integral type so we use <code>uint8_t</code> here. You only need a different type if your alphabet has an alphabet size &gt;=255.</dd></dl>
<p>If you want BioC++'s algorithms to accept it as an alphabet, you need to make sure that your type satisfies the requirements of the <a class="el" href="interfacebio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> concept. A quick check can reveal that this is not the case: </p><div class="fragment"><div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1alphabet.html">bio::alphabet::alphabet&lt;dna2&gt;</a> == <span class="keyword">false</span>);      <span class="comment">// NOT an alphabet</span></div>
<div class="ttc" id="ainterfacebio_1_1alphabet_1_1alphabet_html"><div class="ttname"><a href="interfacebio_1_1alphabet_1_1alphabet.html">alphabet</a></div><div class="ttdoc">The generic alphabet concept that covers most data types used in ranges.</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md61"></a>
Prerequisites</h2>
<p>A look at the documentation of <a class="el" href="interfacebio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> will reveal that it is actually a refinement of other concepts, more precisely <a class="el" href="interfacebio_1_1alphabet_1_1semialphabet.html" title="The basis for bio::alphabet::alphabet, but requires only rank interface (not char).">bio::alphabet::semialphabet</a> which in turn refines std::copy_constructible and std::totally_ordered. Let's check those: </p><div class="fragment"><div class="line">static_assert(std::copy_constructible&lt;dna2&gt;);               <span class="comment">// ok</span></div>
<div class="line">static_assert(std::totally_ordered&lt;dna2&gt; == <span class="keyword">false</span>);         <span class="comment">// NO comparison operators</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1semialphabet.html">bio::alphabet::semialphabet&lt;dna2&gt;</a> == <span class="keyword">false</span>);  <span class="comment">// NOT a semialphabet</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1alphabet.html">bio::alphabet::alphabet&lt;dna2&gt;</a> == <span class="keyword">false</span>);      <span class="comment">// NOT an alphabet</span></div>
<div class="ttc" id="ainterfacebio_1_1alphabet_1_1semialphabet_html"><div class="ttname"><a href="interfacebio_1_1alphabet_1_1semialphabet.html">semialphabet</a></div><div class="ttdoc">The basis for bio::alphabet::alphabet, but requires only rank interface (not char).</div></div>
</div><!-- fragment --><p> You should see that your type models only the std::copy_constructible concept. Let's have a look at the documentation for std::totally_ordered. Can you guess what it describes?</p>
<p>It describes the requirements for types that are comparable via <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.</p>
<p> <div class="assignemnt"><h4>Excercise</h4><div class="assignment_content"> Make all these operators available on <code>dna2</code>. HINT: Since C++20, you don't actually need to implement every operator individually.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                     <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Comparison operators</span></div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> operator&lt;=&gt;(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::totally_ordered&lt;dna2&gt;);              <span class="comment">// ok</span></div>
</div><!-- fragment --><p> </details> </div> </p>
<h2><a class="anchor" id="autotoc_md62"></a>
Semialphabet</h2>
<p>Let's move on to the more interesting concepts. <a class="el" href="interfacebio_1_1alphabet_1_1semialphabet.html" title="The basis for bio::alphabet::alphabet, but requires only rank interface (not char).">bio::alphabet::semialphabet</a> constitutes the <em>rank interface</em> that we introduced in the <a class="el" href="core_alphabets.html">alphabet tutorial</a>. Have a look at the API reference again. Beyond the conceptional requirements, it also requires that <a class="el" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet::size</a> and <a class="el" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e" title="Return the rank representation of a (semi-)alphabet object.">bio::alphabet::to_rank</a> can be called on your alphabet.</p>
<p>Have a look at the respective API reference and also the <a class="el" href="biocpp_customisation.html">documentation on customisation points</a>.</p>
<p>You can add member functions for you type, and then make <code><a class="el" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1" title="The number of values the char type can take (e.g. 256 for char).">tag_invoke()</a></code> wrappers, but for simplicity, we will put the functionality directly into the <code><a class="el" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1" title="The number of values the char type can take (e.g. 256 for char).">tag_invoke()</a></code> overloads here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cassert.html">cassert</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                             <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Comparison operators */</span></div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keyword">auto</span> operator&lt;=&gt;(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Semialphabet */</span></div>
<div class="line">    consteval <span class="keyword">friend</span> <span class="keywordtype">size_t</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1size.html">bio::alphabet::cpo::size</a>,</div>
<div class="line">                                       dna2) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> uint8_t <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1to__rank.html">bio::alphabet::cpo::to_rank</a>,</div>
<div class="line">                                        dna2 <span class="keyword">const</span> &amp; d) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> d.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> dna2 &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1assign__rank__to.html">bio::alphabet::cpo::assign_rank_to</a>,</div>
<div class="line">                                       uint8_t rk,</div>
<div class="line">                                       dna2 &amp; d) noexcept</div>
<div class="line">    {</div>
<div class="line">        assert(rk &lt; 2);</div>
<div class="line">        d.rank = rk;</div>
<div class="line">        <span class="keywordflow">return</span> d;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="acassert_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/cassert.html">cassert</a></div></div>
<div class="ttc" id="agroup__adaptation_html_ga90e36e0f53be2c688535b847e3d626e1"><div class="ttname"><a href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">bio::alphabet::cpo::tag_invoke</a></div><div class="ttdeci">consteval auto tag_invoke(size, char_type const) noexcept</div><div class="ttdoc">The number of values the char type can take (e.g. 256 for char).</div><div class="ttdef"><b>Definition:</b> char.hpp:38</div></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1cpo_1_1assign__rank__to_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1cpo_1_1assign__rank__to.html">bio::alphabet::cpo::assign_rank_to</a></div><div class="ttdoc">Customisation tag for bio::alphabet::assign_rank_to.#.</div><div class="ttdef"><b>Definition:</b> concept.hpp:121</div></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1cpo_1_1size_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1cpo_1_1size.html">bio::alphabet::cpo::size</a></div><div class="ttdoc">CPO tag definition for bio::alphabet::size.</div><div class="ttdef"><b>Definition:</b> concept.hpp:570</div></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1cpo_1_1to__rank_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1cpo_1_1to__rank.html">bio::alphabet::cpo::to_rank</a></div><div class="ttdoc">Customisation tag for bio::alphabet::to_rank.</div><div class="ttdef"><b>Definition:</b> concept.hpp:39</div></div>
</div><!-- fragment --><p> As you can see from the <code>static_assert</code>, our dna2 alphabet now models <a class="el" href="interfacebio_1_1alphabet_1_1semialphabet.html" title="The basis for bio::alphabet::alphabet, but requires only rank interface (not char).">bio::alphabet::semialphabet</a> and <a class="el" href="interfacebio_1_1alphabet_1_1writable__semialphabet.html" title="A refinement of bio::alphabet::semialphabet that adds assignability.">bio::alphabet::writable_semialphabet</a>: </p><div class="fragment"><div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1semialphabet.html">bio::alphabet::semialphabet&lt;dna2&gt;</a>);               <span class="comment">// ok</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1writable__semialphabet.html">bio::alphabet::writable_semialphabet&lt;dna2&gt;</a>);      <span class="comment">// ok</span></div>
<div class="ttc" id="ainterfacebio_1_1alphabet_1_1writable__semialphabet_html"><div class="ttname"><a href="interfacebio_1_1alphabet_1_1writable__semialphabet.html">writable_semialphabet</a></div><div class="ttdoc">A refinement of bio::alphabet::semialphabet that adds assignability.</div></div>
</div><!-- fragment --><p> You can also try out the customisation points directly (they appear like free functions). Here is an example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">    dna2 chr{};</div>
<div class="line">    <a class="code" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">bio::alphabet::assign_rank_to</a>(1, chr);                      <span class="comment">// chr is assigned rank 1</span></div>
<div class="line">    uint8_t rnk = <a class="code" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a>(chr);                  <span class="comment">// query rank value  =&gt; 1</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__alphabet_html_ga2a48a5c1883184e362f09e32ac33241e"><div class="ttname"><a href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a></div><div class="ttdeci">constexpr auto to_rank</div><div class="ttdoc">Return the rank representation of a (semi-)alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:83</div></div>
<div class="ttc" id="agroup__alphabet_html_gab718eab4e0f0e1b44f78b7600dee5e4d"><div class="ttname"><a href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">bio::alphabet::assign_rank_to</a></div><div class="ttdeci">constexpr auto assign_rank_to</div><div class="ttdoc">Assign a rank to an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:172</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md63"></a>
Alphabet</h2>
<p>Now that you have a feeling for concepts, have a look at <a class="el" href="interfacebio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> and <a class="el" href="interfacebio_1_1alphabet_1_1writable__alphabet.html" title="Refines bio::alphabet::alphabet and adds assignability.">bio::alphabet::writable_alphabet</a> and make your type also model these concepts.</p>
<p> <div class="assignemnt"><h4>Excercise</h4><div class="assignment_content"></p><ol type="1">
<li>Implement the <a class="el" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1" title="The number of values the char type can take (e.g. 256 for char).">tag_invoke()</a> function for "to_char" which returns the char 'S' or 'W' depending on the rank value.</li>
<li>Implement the <a class="el" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1" title="The number of values the char type can take (e.g. 256 for char).">tag_invoke()</a> function for "assign_char".</li>
<li>There is a function object that tells us which characters are valid for a given alphabet: <a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce" title="Returns whether a character is in the valid set of a bio::alphabet::alphabet (usually implies a bijec...">bio::alphabet::char_is_valid_for</a>. By default, all characters are "valid" that are preserved when being assigned from and then be converted back. But in some cases you want to change the default behaviour, e.g. declaring lower-case letters to be valid, as well. <br  />
 <b>Optional task:</b> Implement the <a class="el" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1" title="The number of values the char type can take (e.g. 256 for char).">tag_invoke()</a> function for "char_is_valid" to also accept 's' and 'w' as valid characters.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cassert.html">cassert</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                   <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Comparison operators */</span></div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keyword">auto</span> operator&lt;=&gt;(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Semialphabet */</span></div>
<div class="line">    consteval <span class="keyword">friend</span> <span class="keywordtype">size_t</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1size.html">bio::alphabet::cpo::size</a>,</div>
<div class="line">                                       dna2) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> uint8_t <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1to__rank.html">bio::alphabet::cpo::to_rank</a>,</div>
<div class="line">                                        dna2 <span class="keyword">const</span> &amp; d) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> d.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> dna2 &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1assign__rank__to.html">bio::alphabet::cpo::assign_rank_to</a>,</div>
<div class="line">                                       uint8_t rk,</div>
<div class="line">                                       dna2 &amp; d) noexcept</div>
<div class="line">    {</div>
<div class="line">        assert(rk &lt; 2);</div>
<div class="line">        d.rank = rk;</div>
<div class="line">        <span class="keywordflow">return</span> d;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Alphabet */</span></div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">char</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1to__char.html">bio::alphabet::cpo::to_char</a>,</div>
<div class="line">                                     dna2 <span class="keyword">const</span> &amp; d) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// map 0 =&gt; &#39;S&#39; and 1 =&gt; &#39;W&#39;</span></div>
<div class="line">        <span class="keywordflow">return</span> d.rank == 0 ? <span class="charliteral">&#39;S&#39;</span> : <span class="charliteral">&#39;W&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> dna2 &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1assign__char__to.html">bio::alphabet::cpo::assign_char_to</a>,</div>
<div class="line">                                       <span class="keywordtype">char</span> ch,</div>
<div class="line">                                       dna2 &amp; d) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (ch)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;W&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;w&#39;</span>:</div>
<div class="line">                d.rank = 1; <span class="comment">// allow assignment from uppercase and lowercase</span></div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                d.rank = 0; <span class="comment">// unknown characters are mapped to 0 (=&gt; &#39;S&#39;)</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> d;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Optional: make lower-case letters valid</span></div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1char__is__valid__for.html">bio::alphabet::cpo::char_is_valid_for</a>,</div>
<div class="line">                                     <span class="keywordtype">char</span> ch,</div>
<div class="line">                                     dna2) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (ch)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;W&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;w&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;S&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;s&#39;</span>: <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">default</span>:  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="astructbio_1_1alphabet_1_1cpo_1_1assign__char__to_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1cpo_1_1assign__char__to.html">bio::alphabet::cpo::assign_char_to</a></div><div class="ttdoc">Customisation tag for bio::alphabet::assign_char_to.</div><div class="ttdef"><b>Definition:</b> concept.hpp:283</div></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1cpo_1_1char__is__valid__for_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1cpo_1_1char__is__valid__for.html">bio::alphabet::cpo::char_is_valid_for</a></div><div class="ttdoc">Customisation tag for bio::alphabet::assign_char_to.</div><div class="ttdef"><b>Definition:</b> concept.hpp:364</div></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1cpo_1_1to__char_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1cpo_1_1to__char.html">bio::alphabet::cpo::to_char</a></div><div class="ttdoc">Customisation tag for bio::alphabet::to_char.</div><div class="ttdef"><b>Definition:</b> concept.hpp:201</div></div>
</div><!-- fragment --> </details> </div> </li>
</ol>
<p>At this point the <a class="el" href="interfacebio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> concept should be modelled successfully and even <a class="el" href="interfacebio_1_1alphabet_1_1writable__alphabet.html" title="Refines bio::alphabet::alphabet and adds assignability.">bio::alphabet::writable_alphabet</a> is fine because we implemented <code>assign_char</code> and <code>char_is_valid</code>. </p><div class="fragment"><div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1alphabet.html">bio::alphabet::alphabet&lt;dna2&gt;</a>);               <span class="comment">// ok</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1writable__alphabet.html">bio::alphabet::writable_alphabet&lt;dna2&gt;</a>);      <span class="comment">// ok</span></div>
<div class="ttc" id="ainterfacebio_1_1alphabet_1_1writable__alphabet_html"><div class="ttname"><a href="interfacebio_1_1alphabet_1_1writable__alphabet.html">writable_alphabet</a></div><div class="ttdoc">Refines bio::alphabet::alphabet and adds assignability.</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md64"></a>
Shortcut: alphabet base template</h2>
<p>Often it is not required to implement the entire class yourself, instead you can derive from <a class="el" href="classbio_1_1alphabet_1_1alphabet__base.html" title="A CRTP-base that makes defining a custom alphabet easier.">bio::alphabet::alphabet_base</a>. The base class defines both members and <a class="el" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1" title="The number of values the char type can take (e.g. 256 for char).">tag_invoke()</a> overloads for you––if you provide certain conversion tables. Read the documentation of <a class="el" href="classbio_1_1alphabet_1_1alphabet__base.html" title="A CRTP-base that makes defining a custom alphabet easier.">bio::alphabet::alphabet_base</a> for details. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/array.html">array</a>&gt;</span>                                            <span class="comment">// std::array</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet__base_8hpp.html">bio/alphabet/alphabet_base.hpp</a>&gt;</span>                   <span class="comment">// alphabet_base</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                         <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// derive from alphabet_base</span></div>
<div class="line"><span class="keyword">struct </span>dna2 : <span class="keyword">public</span> <a class="code" href="classbio_1_1alphabet_1_1alphabet__base.html">bio::alphabet::alphabet_base</a>&lt;dna2, 2&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// map 0 =&gt; &#39;S&#39; and 1 =&gt; &#39;W&#39;</span></div>
<div class="line">    <span class="keyword">static</span> constexpr char_type rank_to_char[alphabet_size] {<span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;W&#39;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/array.html">std::array&lt;rank_type, 256&gt;</a> char_to_rank =</div>
<div class="line">    <span class="comment">// initialise with an immediately evaluated lambda expression:</span></div>
<div class="line">    [] () constexpr</div>
<div class="line">    {</div>
<div class="line">        <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/array.html">std::array&lt;rank_type, 256&gt;</a> ret{}; <span class="comment">// initialise all values with 0 (=&gt; &#39;S&#39;)</span></div>
<div class="line">        ret[<span class="charliteral">&#39;W&#39;</span>] = 1;                     <span class="comment">// only &#39;W&#39; and &#39;w&#39; result in rank 1</span></div>
<div class="line">        ret[<span class="charliteral">&#39;w&#39;</span>] = 1;</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    } ();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// make the base class a friend so it can access the tables:</span></div>
<div class="line">    <span class="keyword">friend</span> <a class="code" href="classbio_1_1alphabet_1_1alphabet__base.html">bio::alphabet::alphabet_base&lt;dna2, 2&gt;</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check the concepts</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1alphabet.html">bio::alphabet::alphabet&lt;dna2&gt;</a>);               <span class="comment">// ok</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1writable__alphabet.html">bio::alphabet::writable_alphabet&lt;dna2&gt;</a>);      <span class="comment">// ok</span></div>
<div class="ttc" id="aalphabet__base_8hpp_html"><div class="ttname"><a href="alphabet__base_8hpp.html">alphabet_base.hpp</a></div><div class="ttdoc">Provides bio::alphabet::alphabet_base.</div></div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/array.html">array</a></div></div>
<div class="ttc" id="aclassbio_1_1alphabet_1_1alphabet__base_html"><div class="ttname"><a href="classbio_1_1alphabet_1_1alphabet__base.html">bio::alphabet::alphabet_base</a></div><div class="ttdoc">A CRTP-base that makes defining a custom alphabet easier.</div><div class="ttdef"><b>Definition:</b> alphabet_base.hpp:55</div></div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md65"></a>
Further examples</h1>
<h2><a class="anchor" id="autotoc_md66"></a>
Implementation as enum class</h2>
<p>This is an example of a minimal custom alphabet that provides implementations for all necessary customisation points.</p>
<p>As an enum class the values already have an order and therefore the class models std::totally_ordered without defining the (in)equality and comparison operators. Opposed to the examples above, we use free functions to implement the functionality (because we can't add friends to an enum). </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span> <span class="comment">// for bio::alphabet::alphabet</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cstddef.html">cstddef</a>&gt;</span>                  <span class="comment">// for size_t</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_namespace</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> my_alph</div>
<div class="line">{</div>
<div class="line">    ZERO,</div>
<div class="line">    ONE,</div>
<div class="line">    TWO</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">consteval <span class="keywordtype">size_t</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1size.html">bio::alphabet::cpo::size</a>, my_alph <span class="keyword">const</span> &amp;) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> 3;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1to__rank.html">bio::alphabet::cpo::to_rank</a>, my_alph <span class="keyword">const</span> a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr my_alph &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1assign__rank__to.html">bio::alphabet::cpo::assign_rank_to</a>, <span class="keywordtype">size_t</span> <span class="keyword">const</span> r, my_alph &amp; a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (r)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> 0:</div>
<div class="line">            a = my_alph::ZERO;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">case</span> 1:</div>
<div class="line">            a = my_alph::ONE;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            a = my_alph::TWO;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">char</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1to__char.html">bio::alphabet::cpo::to_char</a>, my_alph <span class="keyword">const</span> a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (a)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> my_alph::ZERO:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> my_alph::ONE:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="charliteral">&#39;1&#39;</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="charliteral">&#39;2&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr my_alph &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1assign__char__to.html">bio::alphabet::cpo::assign_char_to</a>, <span class="keywordtype">char</span> <span class="keyword">const</span> c, my_alph &amp; a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (c)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>:</div>
<div class="line">            a = my_alph::ZERO;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>:</div>
<div class="line">            a = my_alph::ONE;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            a = my_alph::TWO;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_namespace</span></div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1alphabet.html">bio::alphabet::alphabet&lt;my_namespace::my_alph&gt;</a>);</div>
<div class="ttc" id="acstddef_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/cstddef.html">cstddef</a></div></div>
</div><!-- fragment --> <h2><a class="anchor" id="howto_write_an_alphabet_custom"></a>
Adaptation of a third party type</h2>
<p>This example is similar to the previous one, but assuming that you cannot add anything to the namespace of the type that you wish to adapt. In that case, you need to add the <a class="el" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1" title="The number of values the char type can take (e.g. 256 for char).">tag_invoke()</a> implementations to namespace <a class="el" href="namespacebio_1_1alphabet_1_1cpo.html" title="A namespace for third party and standard library specialisations of BioC++ customisation points.">bio::alphabet::cpo</a> so that they are found by our customisation points.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span> <span class="comment">// for bio::alphabet::alphabet</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cstddef.html">cstddef</a>&gt;</span>                  <span class="comment">// for size_t</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// this is from some other library:</span></div>
<div class="line"><span class="keyword">namespace </span>third_party_ns</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> third_party_type</div>
<div class="line">{</div>
<div class="line">    ZERO,</div>
<div class="line">    ONE,</div>
<div class="line">    TWO</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace third_party_ns</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// in this case, overloads for tag_invoke are defined within bio::*::cpo</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebio_1_1alphabet_1_1cpo.html">bio::alphabet::cpo</a></div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">consteval <span class="keywordtype">size_t</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d">size</a>, third_party_ns::third_party_type) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> 3;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">to_rank</a>, third_party_ns::third_party_type <span class="keyword">const</span> a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr third_party_ns::third_party_type &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">assign_rank_to</a>,</div>
<div class="line">                                                        <span class="keywordtype">size_t</span> <span class="keyword">const</span>                       r,</div>
<div class="line">                                                        third_party_ns::third_party_type &amp; a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (r)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> 0:</div>
<div class="line">            a = third_party_ns::third_party_type::ZERO;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">case</span> 1:</div>
<div class="line">            a = third_party_ns::third_party_type::ONE;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            a = third_party_ns::third_party_type::TWO;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">char</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">to_char</a>, third_party_ns::third_party_type <span class="keyword">const</span> a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (a)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> third_party_ns::third_party_type::ZERO:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> third_party_ns::third_party_type::ONE:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="charliteral">&#39;1&#39;</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="charliteral">&#39;2&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr third_party_ns::third_party_type &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">assign_char_to</a>,</div>
<div class="line">                                                        <span class="keywordtype">char</span> <span class="keyword">const</span>                         c,</div>
<div class="line">                                                        third_party_ns::third_party_type &amp; a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (c)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>:</div>
<div class="line">            a = third_party_ns::third_party_type::ZERO;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>:</div>
<div class="line">            a = third_party_ns::third_party_type::ONE;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            a = third_party_ns::third_party_type::TWO;</div>
<div class="line">            <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace bio::alphabet::cpo</span></div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1alphabet.html">bio::alphabet::alphabet&lt;third_party_ns::third_party_type&gt;</a>);</div>
<div class="ttc" id="agroup__alphabet_html_ga064e386f9360cca0fd3702b4957a27a0"><div class="ttname"><a href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a></div><div class="ttdeci">constexpr auto to_char</div><div class="ttdoc">Return the char representation of an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:245</div></div>
<div class="ttc" id="agroup__alphabet_html_ga0c2eb25dabf59ccf9992b2661083ea5b"><div class="ttname"><a href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">bio::alphabet::assign_char_to</a></div><div class="ttdeci">constexpr auto assign_char_to</div><div class="ttdoc">Assign a char to an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:334</div></div>
<div class="ttc" id="agroup__alphabet_html_ga299ddd5bf7e8221cb9d283f8a8d24f8d"><div class="ttname"><a href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d">bio::alphabet::size</a></div><div class="ttdeci">constexpr auto size</div><div class="ttdoc">A type trait that holds the size of a (semi-)alphabet.</div><div class="ttdef"><b>Definition:</b> concept.hpp:628</div></div>
<div class="ttc" id="anamespacebio_1_1alphabet_1_1cpo_html"><div class="ttname"><a href="namespacebio_1_1alphabet_1_1cpo.html">bio::alphabet::cpo</a></div><div class="ttdoc">A namespace for third party and standard library specialisations of BioC++ customisation points.</div><div class="ttdef"><b>Definition:</b> char.hpp:33</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md67"></a>
Implementation of a non-default-constructible class</h2>
<p>This is an example of a custom alphabet that is not default-constructible and that has a non-default overload for <a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce" title="Returns whether a character is in the valid set of a bio::alphabet::alphabet (usually implies a bijec...">bio::alphabet::char_is_valid_for</a>.</p>
<p>Please note that for the overloads of <a class="el" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet::size</a> and <a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce" title="Returns whether a character is in the valid set of a bio::alphabet::alphabet (usually implies a bijec...">bio::alphabet::char_is_valid_for</a> our alphabet type has to be wrapped into <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a>&lt;&gt;</code> to be recognised by the customisation point objects, because the type does not model <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a> after we have deleted the default constructor.</p>
<p>With the overload of <a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce" title="Returns whether a character is in the valid set of a bio::alphabet::alphabet (usually implies a bijec...">bio::alphabet::char_is_valid_for</a>, we allow assignment to the underlying rank type from '1', 't' and 'T' for value 1 as well as from '0', 'f' and 'F' for value 0.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span> <span class="comment">// for bio::alphabet::alphabet</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cstddef.html">cstddef</a>&gt;</span>                  <span class="comment">// for size_t</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/type_traits.html">type_traits</a>&gt;</span>              <span class="comment">// for std::type_identity</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_namespace</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>my_alph</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    uint8_t rank;</div>
<div class="line"> </div>
<div class="line">    my_alph()                                      = <span class="keyword">delete</span>;</div>
<div class="line">    constexpr my_alph(my_alph <span class="keyword">const</span> &amp;)             = <span class="keywordflow">default</span>;</div>
<div class="line">    constexpr my_alph &amp; operator=(my_alph <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    constexpr my_alph(uint8_t rank) : rank{rank} {}</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keyword">auto</span> operator&lt;=&gt;(my_alph lhs, my_alph rhs) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    consteval <span class="keyword">friend</span> <span class="keywordtype">size_t</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1size.html">bio::alphabet::cpo::size</a>, <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity&lt;my_alph&gt;</a>) noexcept { <span class="keywordflow">return</span> 2; }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> uint8_t <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1to__rank.html">bio::alphabet::cpo::to_rank</a>, my_alph <span class="keyword">const</span> a) noexcept { <span class="keywordflow">return</span> a.rank; }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> my_alph &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1assign__rank__to.html">bio::alphabet::cpo::assign_rank_to</a>, uint8_t <span class="keyword">const</span> r, my_alph &amp; a) noexcept</div>
<div class="line">    {</div>
<div class="line">        a.rank = r;</div>
<div class="line">        <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">char</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1to__char.html">bio::alphabet::cpo::to_char</a>, my_alph <span class="keyword">const</span> a) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (a.rank)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="charliteral">&#39;1&#39;</span>;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> my_alph &amp; <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1assign__char__to.html">bio::alphabet::cpo::assign_char_to</a>, <span class="keywordtype">char</span> <span class="keyword">const</span> c, my_alph &amp; a) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (c)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>:</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;F&#39;</span>:</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>:</div>
<div class="line">                a.rank = 0;</div>
<div class="line">                <span class="keywordflow">return</span> a;</div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                a.rank = 1;</div>
<div class="line">                <span class="keywordflow">return</span> a;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__adaptation.html#ga90e36e0f53be2c688535b847e3d626e1">tag_invoke</a>(<a class="code" href="structbio_1_1alphabet_1_1cpo_1_1char__is__valid__for.html">bio::alphabet::cpo::char_is_valid_for</a>,</div>
<div class="line">                                     <span class="keywordtype">char</span> <span class="keyword">const</span> c,</div>
<div class="line">                                     <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity&lt;my_alph&gt;</a>) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (c)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>:</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;F&#39;</span>:</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>:</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>:</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;T&#39;</span>:</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;t&#39;</span>:</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_namespace</span></div>
<div class="line"> </div>
<div class="line">static_assert(bio::alphabet::size&lt;my_namespace::my_alph&gt; == 2);</div>
<div class="line">static_assert(bio::alphabet::char_is_valid_for&lt;my_namespace::my_alph&gt;(<span class="charliteral">&#39;T&#39;</span>));</div>
<div class="line">static_assert(!bio::alphabet::char_is_valid_for&lt;my_namespace::my_alph&gt;(<span class="charliteral">&#39;!&#39;</span>));</div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1semialphabet.html">bio::alphabet::semialphabet&lt;my_namespace::my_alph&gt;</a>);</div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet_1_1alphabet.html">bio::alphabet::alphabet&lt;my_namespace::my_alph&gt;</a>);</div>
<div class="ttc" id="atype_identity_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a></div></div>
<div class="ttc" id="atype_traits_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/type_traits.html">type_traits</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You should really make your alphabet types <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">no-throw-default-constructible</a> if you can! </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Tue Aug 2 2022 17:33:49 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
