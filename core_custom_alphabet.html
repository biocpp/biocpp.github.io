<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: How to write your own alphabet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BioC++
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('core_custom_alphabet.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How to write your own alphabet </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md59">Motivation</a></li>
<li class="level1"><a href="#autotoc_md60">Step by step: Create your own alphabet</a><ul><li class="level2"><a href="#autotoc_md61">Prerequisites</a></li>
<li class="level2"><a href="#autotoc_md62">semialphabet</a></li>
<li class="level2"><a href="#autotoc_md63">alphabet</a></li>
<li class="level2"><a href="#autotoc_md64">Shortcut: alphabet base template</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md65">Further examples</a><ul><li class="level2"><a href="#autotoc_md66">Implementation as enum class</a></li>
<li class="level2"><a href="#howto_write_an_alphabet_custom">Adaptation of a third party type</a></li>
<li class="level2"><a href="#autotoc_md67">Implementation of a non-default-constructible class</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_hannes_devel_bio_core_doc_core_write_an_alphabet_index"></a></p>
<p>This HowTo documents how to write a custom alphabet that can be used with the algorithms and data structures in BioC++.</p>
<table class="doxtable">
<tr>
<th>Difficulty</th><td>Moderate</td></tr>
<tr>
<th>Duration</th><td>45 min</td></tr>
<tr>
<th>Prerequisite tutorials</th><td><a class="el" href="core_concepts.html">C++ Concepts</a>, <a class="el" href="core_alphabets.html">Alphabets in BioC++</a></td></tr>
<tr>
<th>Recommended reading</th><td><a class="el" href="group__alphabet.html">Alphabet</a></td></tr>
</table>
<h1><a class="anchor" id="autotoc_md59"></a>
Motivation</h1>
<p>In the <a class="el" href="core_alphabets.html">alphabet tutorial</a> you have learned that alphabets are a core component in BioC++ and represent the smallest unit of biological sequence data. We introduced the common alphabets for nucleotide, amino acid and gap as well as structure and quality annotation. However, in your BioC++ application you may want to implement a custom alphabet in order to work efficiently with BioC++'s algorithms. To achieve this, your custom alphabet must meet certain requirements, which are defined in <a class="el" href="core_concepts.html">concepts</a>.</p>
<p>For detailed information on the alphabet concepts please read the <a class="el" href="group__alphabet.html">Alphabet</a> page. In the following sections we demonstrate how to write an alphabet that models them.</p>
<p>A brief summary of the concepts used in this HowTo:</p><ul>
<li><a class="el" href="interfacebio_1_1semialphabet.html" title="The basis for bio::alphabet, but requires only rank interface (not char).">bio::semialphabet</a> requires your type to have a numerical representation (rank), as well as an alphabet size and comparison operators.</li>
<li><a class="el" href="interfacebio_1_1writable__semialphabet.html" title="A refinement of bio::semialphabet that adds assignability.">bio::writable_semialphabet</a> additionally requires being able to change the value of the object via the rank representation.</li>
<li><a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> requires that your type has a visual representation in addition to the numerical representation. Usually this is a character type like char.</li>
<li><a class="el" href="interfacebio_1_1writable__alphabet.html" title="Refines bio::alphabet and adds assignability.">bio::writable_alphabet</a> additionally requires being able to change the value of the object via the char representation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md60"></a>
Step by step: Create your own alphabet</h1>
<p>In the alphabet tutorial we have calculated the GC content of a nucleotide sequence. Guanine and Cytosine are complementary nucleobases, which pair in a DNA molecule by building 3 hydrogen bonds. Adenine and Thymine pair with only 2 hydrogen bonds. As a consequence, we denote Guanine and Cytosine as strong (S) and Adenine and Thymine as weak (W) nucleobases. In this section we want to implement a <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> that consists of the characters <code>S</code> and <code>W</code> to represent strong and weak nucleobases.</p>
<p>Let's start with a simple struct that only holds the alphabet's numerical representation, namely the <b>rank</b> value. It is not specified how the value of an alphabet is stored internally, however alphabets typically store the rank as a member variable. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                   <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line">};</div>
<div class="ttc" id="aalphabet_2concept_8hpp_html"><div class="ttname"><a href="alphabet_2concept_8hpp.html">concept.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The type of the member variable is typically the smallest unsigned integer type that can hold the maximum rank. In our case we have only two values so <code>bool</code> would be sufficient. However <code>bool</code> is not actually smaller than <code>uint8_t</code> and does not always behave like an unsigned integral type so we use <code>uint8_t</code> here. You only need a different type if your alphabet has an alphabet size &gt;=255.</dd></dl>
<p>If you want BioC++'s algorithms to accept it as an alphabet, you need to make sure that your type satisfies the requirements of the <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> concept. A quick check can reveal that this is not the case: </p><div class="fragment"><div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet.html">bio::alphabet&lt;dna2&gt;</a> == <span class="keyword">false</span>);          <span class="comment">// NOT an alphabet</span></div>
<div class="ttc" id="ainterfacebio_1_1alphabet_html"><div class="ttname"><a href="interfacebio_1_1alphabet.html">alphabet</a></div><div class="ttdoc">The generic alphabet concept that covers most data types used in ranges.</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>A <code>static_assert()</code> will only tell you whether the expression is true or not. If you want the compiler to tell you <b>why</b> the concept is not modelled, you can construct a dummy requirement like this: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;bio::alphabet check_this_type&gt;</div>
<div class="line"><span class="keywordtype">void</span> foo()</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    foo&lt;dna2&gt;();</div>
<div class="line">}</div>
</div><!-- fragment -->This will fail with a (slightly long and need-to-get-used-to) error message telling you that <code>foo()</code> cannot be called with <code>dna2</code> because <code>constraints are not satisfied ...</code>.</dd></dl>
<h2><a class="anchor" id="autotoc_md61"></a>
Prerequisites</h2>
<p>A look at the documentation of <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> will reveal that it is actually a refinement of other concepts, more precisely <a class="el" href="interfacebio_1_1semialphabet.html" title="The basis for bio::alphabet, but requires only rank interface (not char).">bio::semialphabet</a> which in turn refines std::copy_constructible and std::totally_ordered. Let's check those: </p><div class="fragment"><div class="line">static_assert(std::copy_constructible&lt;dna2&gt;);             <span class="comment">// ok</span></div>
<div class="line">static_assert(std::totally_ordered&lt;dna2&gt; == <span class="keyword">false</span>); <span class="comment">// NO comparison operators</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1semialphabet.html">bio::semialphabet&lt;dna2&gt;</a> == <span class="keyword">false</span>);      <span class="comment">// NOT a semialphabet</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet.html">bio::alphabet&lt;dna2&gt;</a> == <span class="keyword">false</span>);          <span class="comment">// NOT an alphabet</span></div>
<div class="ttc" id="ainterfacebio_1_1semialphabet_html"><div class="ttname"><a href="interfacebio_1_1semialphabet.html">semialphabet</a></div><div class="ttdoc">The basis for bio::alphabet, but requires only rank interface (not char).</div></div>
</div><!-- fragment --><p> You should see that your type models only the std::copy_constructible concept. Let's have a look at the documentation for std::totally_ordered. Can you guess what it describes?</p>
<p>It describes the requirements for types that are comparable via <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>. This is useful so that you can sort a text over the alphabet, for example. Additionally, std::totally_ordered is again a refinement of std::equality_comparable, which requires the <code>==</code> and <code>!=</code> operators, so let's first implement those. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                   <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Equality operator</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank == rhs.rank;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> As you can see we chose to implement them as friend functions. You can also implement them as free functions in the namespace of your class, but you should avoid regular member functions, because they result in different conversion rules for left-hand-side and right-hand-side.</p>
<p> <div class="assignemnt"><h4>Excercise</h4><div class="assignment_content"> Implement the inequality operator (!=) for <code>dna2</code>.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                   <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Equality and inequality operators</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank == rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !(lhs == rhs);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::equality_comparable&lt;dna2&gt;);            <span class="comment">// ok</span></div>
<div class="ttc" id="aoperator_cmp_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">std::rel_ops::operator!=</a></div><div class="ttdeci">T operator!=(T... args)</div></div>
</div><!-- fragment --><p> </details> </div> </p>
<p>We see that our type now models std::equality_comparable, which is a prerequisite of std::totally_ordered.</p>
<p> <div class="assignemnt"><h4>Excercise</h4><div class="assignment_content"> Implement the four comparison operators and verify that your type models std::totally_ordered.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                   <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Equality and inequality operators</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank == rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !(lhs == rhs);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Comparison operators</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt;(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank &lt; rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator&lt;=</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank &lt;= rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator&gt;</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank &gt; rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator&gt;=</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank &gt;= rhs.rank;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::equality_comparable&lt;dna2&gt;);            <span class="comment">// ok</span></div>
<div class="line">static_assert(std::totally_ordered&lt;dna2&gt;);          <span class="comment">// ok</span></div>
</div><!-- fragment --><p> </details> </div> </p>
<h2><a class="anchor" id="autotoc_md62"></a>
semialphabet</h2>
<p>Let's move on to the more interesting concepts. <a class="el" href="interfacebio_1_1semialphabet.html" title="The basis for bio::alphabet, but requires only rank interface (not char).">bio::semialphabet</a> constitutes the <em>rank interface</em> that we introduced in the <a class="el" href="core_alphabets.html">alphabet tutorial</a>. Have a look at the API reference again. Beyond the conceptional requirements, it also requires that <a class="el" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet_size</a> and <a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0" title="Return the rank representation of a (semi-)alphabet object.">bio::to_rank</a> can be called on your alphabet.</p>
<p>There are different ways to satisfy <a class="el" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet_size</a> and <a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0" title="Return the rank representation of a (semi-)alphabet object.">bio::to_rank</a>, have a look at the respective API reference and also the <a class="el" href="biocpp_customisation.html">documentation on customisation points</a>.</p>
<p>In this case we choose to implement the functionality as member functions: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cassert.html">cassert</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                   <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// semialphabet</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a> = 2;</div>
<div class="line"> </div>
<div class="line">    uint8_t <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">to_rank</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    dna2 &amp; assign_rank(uint8_t <span class="keyword">const</span> rk) noexcept</div>
<div class="line">    {</div>
<div class="line">        assert(rk &lt; <a class="code" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a>);</div>
<div class="line">        rank = rk;</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Equality and inequality operators ...</span></div>
<div class="line">    <span class="comment">// Comparison operators ...</span></div>
<div class="line">};</div>
<div class="ttc" id="acassert_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/cassert.html">cassert</a></div></div>
<div class="ttc" id="agroup__alphabet_html_ga9189b35f800d7e5abad51e021ea811a0"><div class="ttname"><a href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a></div><div class="ttdeci">constexpr auto to_rank</div><div class="ttdoc">Return the rank representation of a (semi-)alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:144</div></div>
<div class="ttc" id="agroup__alphabet_html_gabd77e4c1f2d28c1af7a223605bbb7c82"><div class="ttname"><a href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">bio::alphabet_size</a></div><div class="ttdeci">constexpr auto alphabet_size</div><div class="ttdoc">A type trait that holds the size of a (semi-)alphabet.</div><div class="ttdef"><b>Definition:</b> concept.hpp:708</div></div>
</div><!-- fragment --><p> As you can see from the <code>static_assert</code> our dna2 alphabet now models <a class="el" href="interfacebio_1_1semialphabet.html" title="The basis for bio::alphabet, but requires only rank interface (not char).">bio::semialphabet</a> and <a class="el" href="interfacebio_1_1writable__semialphabet.html" title="A refinement of bio::semialphabet that adds assignability.">bio::writable_semialphabet</a>: </p><div class="fragment"><div class="line">static_assert(<a class="code" href="interfacebio_1_1semialphabet.html">bio::semialphabet&lt;dna2&gt;</a>);               <span class="comment">// ok</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1writable__semialphabet.html">bio::writable_semialphabet&lt;dna2&gt;</a>);       <span class="comment">// ok</span></div>
<div class="ttc" id="ainterfacebio_1_1writable__semialphabet_html"><div class="ttname"><a href="interfacebio_1_1writable__semialphabet.html">writable_semialphabet</a></div><div class="ttdoc">A refinement of bio::semialphabet that adds assignability.</div></div>
</div><!-- fragment --><p> You can also try out the customisation points directly (they appear like free functions). Here is an example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">    dna2 chr{};</div>
<div class="line">    <a class="code" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">bio::assign_rank_to</a>(1, chr);                      <span class="comment">// chr is assigned rank 1</span></div>
<div class="line">    uint8_t rnk = <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a>(chr);                  <span class="comment">// query rank value  =&gt; 1</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__alphabet_html_gae34fa2b37a8b40f2f2fa64fed7bbb410"><div class="ttname"><a href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">bio::assign_rank_to</a></div><div class="ttdeci">constexpr auto assign_rank_to</div><div class="ttdoc">Assign a rank to an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:240</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md63"></a>
alphabet</h2>
<p>Now that you have a feeling for concepts, have a look at <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> and <a class="el" href="interfacebio_1_1writable__alphabet.html" title="Refines bio::alphabet and adds assignability.">bio::writable_alphabet</a> and make your type also model these concepts.</p>
<p> <div class="assignemnt"><h4>Excercise</h4><div class="assignment_content"></p><ol type="1">
<li>Implement the member function <code>char to_char()</code> which returns the char 'S' or 'W' depending on the rank value.</li>
<li>Implement the member function <code>dna2 &amp; assign_char(char const)</code>.</li>
<li>There is a function object that tells us which characters are valid for a given alphabet: <a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52" title="Returns whether a character is in the valid set of a bio::alphabet (usually implies a bijective mappi...">bio::char_is_valid_for</a>. By default, all characters are "valid" that are preserved when being assigned from and then be converted back. But in some cases you want to change the default behaviour, e.g. declaring lower-case letters to be valid, as well. <br  />
 <b>Optional task:</b> Implement the static member function <code>bool char_is_valid(char const)</code> in order to allow also 's' and 'w' as valid characters.  </div></div>  <div class="solution"> <details><summary><b>Solution</b></summary>  <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cassert.html">cassert</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                   <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dna2</div>
<div class="line">{</div>
<div class="line">    uint8_t rank{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// semialphabet</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a> = 2;</div>
<div class="line"> </div>
<div class="line">    uint8_t <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">to_rank</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    dna2 &amp; assign_rank(uint8_t <span class="keyword">const</span> rk) noexcept</div>
<div class="line">    {</div>
<div class="line">        assert(rk &lt; <a class="code" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a>);</div>
<div class="line">        rank = rk;</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// alphabet</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span> <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">to_char</a>() const noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// map 0 =&gt; &#39;S&#39; and 1 =&gt; &#39;W&#39;</span></div>
<div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span> rank_to_char[2] {<span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;W&#39;</span>};</div>
<div class="line">        <span class="keywordflow">return</span> rank_to_char[rank];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    dna2 &amp; assign_char(<span class="keywordtype">char</span> <span class="keyword">const</span> ch) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (ch)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;W&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;w&#39;</span>: rank = 1; <span class="keywordflow">break</span>;         <span class="comment">// allow assignment from uppercase and lowercase</span></div>
<div class="line">            <span class="keywordflow">default</span>:  rank = 0;                          <span class="comment">// unknown characters are mapped to 0 (=&gt; &#39;S&#39;)</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Optional: Can be omitted.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> char_is_valid(<span class="keywordtype">char</span> <span class="keyword">const</span> ch) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (ch == dna2{}.assign_char(ch).<a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">to_char</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Equality and inequality operators</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank == rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !(lhs == rhs);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Comparison operators</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt;(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank &lt; rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator&lt;=</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank &lt;= rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator&gt;</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank &gt; rhs.rank;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator&gt;=</a>(dna2 <span class="keyword">const</span> &amp; lhs, dna2 <span class="keyword">const</span> &amp; rhs) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> lhs.rank &gt;= rhs.rank;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__alphabet_html_gab295f04aea840000aafc640b5e6528c8"><div class="ttname"><a href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a></div><div class="ttdeci">constexpr auto to_char</div><div class="ttdoc">Return the char representation of an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:322</div></div>
</div><!-- fragment --> </details> </div> </li>
</ol>
<p>At this point the <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> concept should be modelled successfully and even <a class="el" href="interfacebio_1_1writable__alphabet.html" title="Refines bio::alphabet and adds assignability.">bio::writable_alphabet</a> is fine because we implemented <code>assign_char</code> and <code>char_is_valid</code>. </p><div class="fragment"><div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet.html">bio::alphabet&lt;dna2&gt;</a>);                   <span class="comment">// ok</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1writable__alphabet.html">bio::writable_alphabet&lt;dna2&gt;</a>);           <span class="comment">// ok</span></div>
<div class="ttc" id="ainterfacebio_1_1writable__alphabet_html"><div class="ttname"><a href="interfacebio_1_1writable__alphabet.html">writable_alphabet</a></div><div class="ttdoc">Refines bio::alphabet and adds assignability.</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md64"></a>
Shortcut: alphabet base template</h2>
<p>Often it is not required to implement the entire class yourself, instead you can derive from <a class="el" href="classbio_1_1alphabet__base.html" title="A CRTP-base that makes defining a custom alphabet easier.">bio::alphabet_base</a> which defines most things for you if you provide certain conversion tables. Read the documentation of <a class="el" href="classbio_1_1alphabet__base.html" title="A CRTP-base that makes defining a custom alphabet easier.">bio::alphabet_base</a> for details. This implementation deduces <code>bool</code> as the smallest possible rank type. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/array.html">array</a>&gt;</span>                                         <span class="comment">// std::array</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet__base_8hpp.html">bio/alphabet/alphabet_base.hpp</a>&gt;</span>             <span class="comment">// alphabet_base</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>                   <span class="comment">// alphabet concept checks</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// derive from alphabet_base</span></div>
<div class="line"><span class="keyword">struct </span>dna2 : <span class="keyword">public</span> <a class="code" href="classbio_1_1alphabet__base.html">bio::alphabet_base</a>&lt;dna2, 2&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// map 0 =&gt; &#39;S&#39; and 1 =&gt; &#39;W&#39;</span></div>
<div class="line">    <span class="keyword">static</span> constexpr char_type rank_to_char[<a class="code" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a>] {<span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;W&#39;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/array.html">std::array&lt;rank_type, 256&gt;</a> char_to_rank</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// initialise with an immediately evaluated lambda expression:</span></div>
<div class="line">        [] () constexpr</div>
<div class="line">        {</div>
<div class="line">            <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/array.html">std::array&lt;rank_type, 256&gt;</a> ret{}; <span class="comment">// initialise all values with 0 (=&gt; &#39;S&#39;)</span></div>
<div class="line">            ret[<span class="charliteral">&#39;W&#39;</span>] = 1;                     <span class="comment">// only &#39;W&#39; and &#39;w&#39; result in rank 1</span></div>
<div class="line">            ret[<span class="charliteral">&#39;w&#39;</span>] = 1;</div>
<div class="line">            <span class="keywordflow">return</span> ret;</div>
<div class="line">        } ()</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// make the base class a friend so it can access the tables:</span></div>
<div class="line">    <span class="keyword">friend</span> <a class="code" href="classbio_1_1alphabet__base.html">bio::alphabet_base&lt;dna2, 2&gt;</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check the concepts</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet.html">bio::alphabet&lt;dna2&gt;</a>);                   <span class="comment">// ok</span></div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1writable__alphabet.html">bio::writable_alphabet&lt;dna2&gt;</a>);           <span class="comment">// ok</span></div>
<div class="ttc" id="aalphabet__base_8hpp_html"><div class="ttname"><a href="alphabet__base_8hpp.html">alphabet_base.hpp</a></div><div class="ttdoc">Provides bio::alphabet_base.</div></div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/array.html">array</a></div></div>
<div class="ttc" id="aclassbio_1_1alphabet__base_html"><div class="ttname"><a href="classbio_1_1alphabet__base.html">bio::alphabet_base</a></div><div class="ttdoc">A CRTP-base that makes defining a custom alphabet easier.</div><div class="ttdef"><b>Definition:</b> alphabet_base.hpp:55</div></div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md65"></a>
Further examples</h1>
<h2><a class="anchor" id="autotoc_md66"></a>
Implementation as enum class</h2>
<p>This is an example of a minimal custom alphabet that provides implementations for all necessary customisation points.</p>
<p>As an enum class the values already have an order and therefore the class models std::totally_ordered without defining the (in)equality and comparison operators. Opposed to the examples above, we use only free functions to model the functionality. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cstddef.html">cstddef</a>&gt;</span>                      <span class="comment">// for size_t</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>  <span class="comment">// for bio::alphabet</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_namespace</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> my_alph</div>
<div class="line">{</div>
<div class="line">    ZERO,</div>
<div class="line">    ONE,</div>
<div class="line">    TWO</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a>(my_alph <span class="keyword">const</span> &amp;) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> 3;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">to_rank</a>(my_alph <span class="keyword">const</span> a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr my_alph &amp; <a class="code" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">assign_rank_to</a>(<span class="keywordtype">size_t</span> <span class="keyword">const</span> r, my_alph &amp; a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (r)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> 0:  a = my_alph::ZERO; <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">case</span> 1:  a = my_alph::ONE;  <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">default</span>: a = my_alph::TWO;  <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">char</span> <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">to_char</a>(my_alph <span class="keyword">const</span> a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (a)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> my_alph::ZERO: <span class="keywordflow">return</span> <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> my_alph::ONE:  <span class="keywordflow">return</span> <span class="charliteral">&#39;1&#39;</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:            <span class="keywordflow">return</span> <span class="charliteral">&#39;2&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr my_alph &amp; <a class="code" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">assign_char_to</a>(<span class="keywordtype">char</span> <span class="keyword">const</span> c, my_alph &amp; a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (c)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>: a = my_alph::ZERO; <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>: a = my_alph::ONE;  <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">default</span>:  a = my_alph::TWO;  <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_namespace</span></div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet.html">bio::alphabet&lt;my_namespace::my_alph&gt;</a>);</div>
<div class="ttc" id="acstddef_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/cstddef.html">cstddef</a></div></div>
<div class="ttc" id="agroup__alphabet_html_ga05da42eb0b9a48f4d1a554c7d3a9044d"><div class="ttname"><a href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">bio::assign_char_to</a></div><div class="ttdeci">constexpr auto assign_char_to</div><div class="ttdoc">Assign a character to an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:418</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="howto_write_an_alphabet_custom"></a>
Adaptation of a third party type</h2>
<p>This example is similar to the previous one, but assuming that you cannot add anything to the namespace of the type that you wish to adapt. In that case, you need to specialise the <a class="el" href="structbio_1_1custom_1_1alphabet.html" title="A type that can be specialised to provide customisation point implementations so that third party typ...">bio::custom::alphabet</a> class template and provide the required functionality as static members.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cstddef.html">cstddef</a>&gt;</span>                      <span class="comment">// for size_t</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>  <span class="comment">// for bio::alphabet</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// this is from some other library:</span></div>
<div class="line"><span class="keyword">namespace </span>third_party_ns</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> third_party_type</div>
<div class="line">{</div>
<div class="line">    ZERO,</div>
<div class="line">    ONE,</div>
<div class="line">    TWO</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace third_party_ns</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// this is in your code (no namespace):</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structbio_1_1custom_1_1alphabet.html">bio::custom::alphabet</a>&lt;third_party_ns::third_party_type&gt;</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a> = 3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">to_rank</a>(third_party_ns::third_party_type <span class="keyword">const</span> a) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr third_party_ns::third_party_type &amp; <a class="code" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">assign_rank_to</a>(<span class="keywordtype">size_t</span> <span class="keyword">const</span> r, third_party_ns::third_party_type &amp; a) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (r)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> 0:  a = third_party_ns::third_party_type::ZERO; <span class="keywordflow">return</span> a;</div>
<div class="line">            <span class="keywordflow">case</span> 1:  a = third_party_ns::third_party_type::ONE;  <span class="keywordflow">return</span> a;</div>
<div class="line">            <span class="keywordflow">default</span>: a = third_party_ns::third_party_type::TWO;  <span class="keywordflow">return</span> a;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">char</span> <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">to_char</a>(third_party_ns::third_party_type <span class="keyword">const</span> a) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (a)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> third_party_ns::third_party_type::ZERO: <span class="keywordflow">return</span> <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> third_party_ns::third_party_type::ONE:  <span class="keywordflow">return</span> <span class="charliteral">&#39;1&#39;</span>;</div>
<div class="line">            <span class="keywordflow">default</span>:                                     <span class="keywordflow">return</span> <span class="charliteral">&#39;2&#39;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr third_party_ns::third_party_type &amp; <a class="code" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">assign_char_to</a>(<span class="keywordtype">char</span> <span class="keyword">const</span> c, third_party_ns::third_party_type &amp; a) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (c)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>: a = third_party_ns::third_party_type::ZERO; <span class="keywordflow">return</span> a;</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>: a = third_party_ns::third_party_type::ONE;  <span class="keywordflow">return</span> a;</div>
<div class="line">            <span class="keywordflow">default</span>:  a = third_party_ns::third_party_type::TWO;  <span class="keywordflow">return</span> a;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet.html">bio::alphabet&lt;third_party_ns::third_party_type&gt;</a>);</div>
<div class="ttc" id="astructbio_1_1custom_1_1alphabet_html"><div class="ttname"><a href="structbio_1_1custom_1_1alphabet.html">bio::custom::alphabet</a></div><div class="ttdoc">A type that can be specialised to provide customisation point implementations so that third party typ...</div><div class="ttdef"><b>Definition:</b> concept.hpp:49</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md67"></a>
Implementation of a non-default-constructible class</h2>
<p>This is an example of a custom alphabet that is not default-constructible and that has a non-default overload for <a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52" title="Returns whether a character is in the valid set of a bio::alphabet (usually implies a bijective mappi...">bio::char_is_valid_for</a>.</p>
<p>Please note that for the overloads of <a class="el" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet_size</a> and <a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52" title="Returns whether a character is in the valid set of a bio::alphabet (usually implies a bijective mappi...">bio::char_is_valid_for</a> our alphabet type has to be wrapped into <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a>&lt;&gt;</code> to be recognised by the customisation point objects, because our type does not model <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a> after we have deleted the default constructor.</p>
<p>With the overload of <a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52" title="Returns whether a character is in the valid set of a bio::alphabet (usually implies a bijective mappi...">bio::char_is_valid_for</a> we allow assignment to the underlying boolean type from '1', 't' and 'T' for value 1 as well as from '0', 'f' and 'F' for value 0.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/cstddef.html">cstddef</a>&gt;</span>                      <span class="comment">// for size_t</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span>  <span class="comment">// for bio::alphabet</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/type_traits.html">type_traits</a>&gt;</span>       <span class="comment">// for std::type_identity</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_namespace</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>my_alph</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> rank;</div>
<div class="line"> </div>
<div class="line">    my_alph() = <span class="keyword">delete</span>;</div>
<div class="line">    constexpr my_alph(my_alph <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    constexpr my_alph &amp; operator=(my_alph <span class="keyword">const</span> &amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    constexpr my_alph(<span class="keywordtype">bool</span> rank) : rank{rank} {}</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(my_alph lhs, my_alph rhs) { <span class="keywordflow">return</span> lhs.rank == rhs.rank; }</div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(my_alph lhs, my_alph rhs) { <span class="keywordflow">return</span> lhs.rank != rhs.rank; }</div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator&lt;=</a>(my_alph lhs, my_alph rhs) { <span class="keywordflow">return</span> lhs.rank &lt;= rhs.rank; }</div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator&gt;=</a>(my_alph lhs, my_alph rhs) { <span class="keywordflow">return</span> lhs.rank &gt;= rhs.rank; }</div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt; (my_alph lhs, my_alph rhs) { <span class="keywordflow">return</span> lhs.rank &lt;  rhs.rank; }</div>
<div class="line">    constexpr <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&gt; (my_alph lhs, my_alph rhs) { <span class="keywordflow">return</span> lhs.rank &gt;  rhs.rank; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">size_t</span> <a class="code" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a>(<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity&lt;my_alph&gt;</a> <span class="keyword">const</span> &amp;) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> 2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">bool</span> <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">to_rank</a>(my_alph <span class="keyword">const</span> a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a.rank;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr my_alph &amp; <a class="code" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">assign_rank_to</a>(<span class="keywordtype">bool</span> <span class="keyword">const</span> r, my_alph &amp; a) noexcept</div>
<div class="line">{</div>
<div class="line">    a.rank = r;</div>
<div class="line">    <span class="keywordflow">return</span> a;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">char</span> <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">to_char</a>(my_alph <span class="keyword">const</span> a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (a.rank)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="charliteral">&#39;1&#39;</span>;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr my_alph &amp; <a class="code" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">assign_char_to</a>(<span class="keywordtype">char</span> <span class="keyword">const</span> c, my_alph &amp; a) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (c)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;F&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>: a.rank = 0; <span class="keywordflow">return</span> a;</div>
<div class="line">        <span class="keywordflow">default</span>: a.rank = 1; <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">bool</span> <a class="code" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52">char_is_valid_for</a>(<span class="keywordtype">char</span> <span class="keyword">const</span> c, <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity&lt;my_alph&gt;</a> <span class="keyword">const</span> &amp;) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (c)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;F&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;T&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;t&#39;</span>: <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_namespace</span></div>
<div class="line"> </div>
<div class="line">static_assert(bio::alphabet_size&lt;my_namespace::my_alph&gt; == 2);</div>
<div class="line">static_assert(bio::char_is_valid_for&lt;my_namespace::my_alph&gt;(<span class="charliteral">&#39;T&#39;</span>));</div>
<div class="line">static_assert(!bio::char_is_valid_for&lt;my_namespace::my_alph&gt;(<span class="charliteral">&#39;!&#39;</span>));</div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1semialphabet.html">bio::semialphabet&lt;my_namespace::my_alph&gt;</a>);</div>
<div class="line">static_assert(<a class="code" href="interfacebio_1_1alphabet.html">bio::alphabet&lt;my_namespace::my_alph&gt;</a>);</div>
<div class="ttc" id="agroup__alphabet_html_ga510b0657b8a3ae7d304999afd8fdcd52"><div class="ttname"><a href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52">bio::char_is_valid_for</a></div><div class="ttdeci">constexpr auto char_is_valid_for</div><div class="ttdoc">Returns whether a character is in the valid set of a bio::alphabet (usually implies a bijective mappi...</div><div class="ttdef"><b>Definition:</b> concept.hpp:523</div></div>
<div class="ttc" id="atype_identity_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a></div></div>
<div class="ttc" id="atype_traits_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/type_traits.html">type_traits</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You should really make your alphabet types <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">no-throw-default-constructible</a> if you can! </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Sun Jun 12 2022 17:23:28 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
