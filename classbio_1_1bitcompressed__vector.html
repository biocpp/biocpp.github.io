<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: bio::bitcompressed_vector&lt; alphabet_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BioC++
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classbio_1_1bitcompressed__vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classbio_1_1bitcompressed__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bio::bitcompressed_vector&lt; alphabet_type &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__range.html">Range</a> &raquo; <a class="el" href="group__container.html">Container</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A space-optimised version of <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> that compresses multiple letters into a single byte.  
 <a href="classbio_1_1bitcompressed__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bitcompressed__vector_8hpp_source.html">bio/ranges/container/bitcompressed_vector.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for bio::bitcompressed_vector&lt; alphabet_type &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classbio_1_1bitcompressed__vector__inherit__graph.svg" width="100%" height="476"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Associated types</div></td></tr>
<tr class="memitem:ac9ee67bf9f36119e001763eee14e3e60"><td class="memItemLeft" align="right" valign="top"><a id="ac9ee67bf9f36119e001763eee14e3e60"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> = alphabet_type</td></tr>
<tr class="memdesc:ac9ee67bf9f36119e001763eee14e3e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals the alphabet_type. <br /></td></tr>
<tr class="separator:ac9ee67bf9f36119e001763eee14e3e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbce5b446665ed3468cef3ba594c05b"><td class="memItemLeft" align="right" valign="top"><a id="a7fbce5b446665ed3468cef3ba594c05b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a> = reference_proxy_type</td></tr>
<tr class="memdesc:a7fbce5b446665ed3468cef3ba594c05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy type that enables assignment, if the underlying data structure also provides a proxy. <br /></td></tr>
<tr class="separator:a7fbce5b446665ed3468cef3ba594c05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9726a45c5a216b20db7950b1115334f"><td class="memItemLeft" align="right" valign="top"><a id="aa9726a45c5a216b20db7950b1115334f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a> = alphabet_type</td></tr>
<tr class="memdesc:aa9726a45c5a216b20db7950b1115334f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals the alphabet_type / <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>. <br /></td></tr>
<tr class="separator:aa9726a45c5a216b20db7950b1115334f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc5c931e4e2eb5dbe0980684d1e8ba9"><td class="memItemLeft" align="right" valign="top"><a id="a7cc5c931e4e2eb5dbe0980684d1e8ba9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> = detail::random_access_iterator&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &gt;</td></tr>
<tr class="memdesc:a7cc5c931e4e2eb5dbe0980684d1e8ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type of this container (a random access iterator). <br /></td></tr>
<tr class="separator:a7cc5c931e4e2eb5dbe0980684d1e8ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c71d49e13956c39731e31cb1d2e544d"><td class="memItemLeft" align="right" valign="top"><a id="a7c71d49e13956c39731e31cb1d2e544d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> = detail::random_access_iterator&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const  &gt;</td></tr>
<tr class="memdesc:a7c71d49e13956c39731e31cb1d2e544d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const_iterator type of this container (a random access iterator). <br /></td></tr>
<tr class="separator:a7c71d49e13956c39731e31cb1d2e544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac718f80191673cb0d1cabbeecb2cf7"><td class="memItemLeft" align="right" valign="top"><a id="a9ac718f80191673cb0d1cabbeecb2cf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a9ac718f80191673cb0d1cabbeecb2cf7">difference_type</a> = std::ranges::range_difference_t&lt; data_type &gt;</td></tr>
<tr class="memdesc:a9ac718f80191673cb0d1cabbeecb2cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integer type (usually <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/ptrdiff_t.html">std::ptrdiff_t</a>) <br /></td></tr>
<tr class="separator:a9ac718f80191673cb0d1cabbeecb2cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58a3a61636aa19e0fdfc70e5b06a779"><td class="memItemLeft" align="right" valign="top"><a id="ab58a3a61636aa19e0fdfc70e5b06a779"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> = std::ranges::range_size_t&lt; data_type &gt;</td></tr>
<tr class="memdesc:ab58a3a61636aa19e0fdfc70e5b06a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type (usually <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a>) <br /></td></tr>
<tr class="separator:ab58a3a61636aa19e0fdfc70e5b06a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor and assignment</div></td></tr>
<tr class="memitem:a10562d4b7d2a2d936860da55dd7f835e"><td class="memItemLeft" align="right" valign="top"><a id="a10562d4b7d2a2d936860da55dd7f835e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a10562d4b7d2a2d936860da55dd7f835e">bitcompressed_vector</a> ()=default</td></tr>
<tr class="memdesc:a10562d4b7d2a2d936860da55dd7f835e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:a10562d4b7d2a2d936860da55dd7f835e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd4e72a1ae1e80d9abd7b4ed8dccd3"><td class="memItemLeft" align="right" valign="top"><a id="ab9dd4e72a1ae1e80d9abd7b4ed8dccd3"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab9dd4e72a1ae1e80d9abd7b4ed8dccd3">bitcompressed_vector</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const &amp;)=default</td></tr>
<tr class="memdesc:ab9dd4e72a1ae1e80d9abd7b4ed8dccd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:ab9dd4e72a1ae1e80d9abd7b4ed8dccd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93014352f46c22769b6e510db363522"><td class="memItemLeft" align="right" valign="top"><a id="ae93014352f46c22769b6e510db363522"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ae93014352f46c22769b6e510db363522">bitcompressed_vector</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:ae93014352f46c22769b6e510db363522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:ae93014352f46c22769b6e510db363522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc37ffde2b608716344e3a304bea159"><td class="memItemLeft" align="right" valign="top"><a id="acbc37ffde2b608716344e3a304bea159"></a>
constexpr <a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#acbc37ffde2b608716344e3a304bea159">operator=</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const &amp;)=default</td></tr>
<tr class="memdesc:acbc37ffde2b608716344e3a304bea159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:acbc37ffde2b608716344e3a304bea159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0115e63c11ba1a7fc4308efd1a296e1"><td class="memItemLeft" align="right" valign="top"><a id="aa0115e63c11ba1a7fc4308efd1a296e1"></a>
constexpr <a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa0115e63c11ba1a7fc4308efd1a296e1">operator=</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:aa0115e63c11ba1a7fc4308efd1a296e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:aa0115e63c11ba1a7fc4308efd1a296e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68240017cca323de66d49e226f749364"><td class="memItemLeft" align="right" valign="top"><a id="a68240017cca323de66d49e226f749364"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a68240017cca323de66d49e226f749364">~bitcompressed_vector</a> ()=default</td></tr>
<tr class="memdesc:a68240017cca323de66d49e226f749364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted. <br /></td></tr>
<tr class="separator:a68240017cca323de66d49e226f749364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2d3530fce6b52e30f9798fe92b16ae"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range other_range_t&gt; </td></tr>
<tr class="memitem:aef2d3530fce6b52e30f9798fe92b16ae"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#aef2d3530fce6b52e30f9798fe92b16ae">bitcompressed_vector</a> (other_range_t &amp;&amp;range)</td></tr>
<tr class="memdesc:aef2d3530fce6b52e30f9798fe92b16ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a different range.  <a href="classbio_1_1bitcompressed__vector.html#aef2d3530fce6b52e30f9798fe92b16ae">More...</a><br /></td></tr>
<tr class="separator:aef2d3530fce6b52e30f9798fe92b16ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268f374bcb93ccbdf4dda59ef33b084f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a268f374bcb93ccbdf4dda59ef33b084f">bitcompressed_vector</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const count, <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const value)</td></tr>
<tr class="memdesc:a268f374bcb93ccbdf4dda59ef33b084f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with <code>count</code> times <code>value</code>.  <a href="classbio_1_1bitcompressed__vector.html#a268f374bcb93ccbdf4dda59ef33b084f">More...</a><br /></td></tr>
<tr class="separator:a268f374bcb93ccbdf4dda59ef33b084f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8719dc1579fc6864796a38ce357870a5"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </td></tr>
<tr class="memitem:a8719dc1579fc6864796a38ce357870a5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a8719dc1579fc6864796a38ce357870a5">bitcompressed_vector</a> (begin_iterator_type begin_it, end_iterator_type end_it)</td></tr>
<tr class="memdesc:a8719dc1579fc6864796a38ce357870a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from pair of iterators.  <a href="classbio_1_1bitcompressed__vector.html#a8719dc1579fc6864796a38ce357870a5">More...</a><br /></td></tr>
<tr class="separator:a8719dc1579fc6864796a38ce357870a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08287f09c3822a995ceb448590bae48d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a08287f09c3822a995ceb448590bae48d">bitcompressed_vector</a> (<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a08287f09c3822a995ceb448590bae48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>.  <a href="classbio_1_1bitcompressed__vector.html#a08287f09c3822a995ceb448590bae48d">More...</a><br /></td></tr>
<tr class="separator:a08287f09c3822a995ceb448590bae48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42ba94c830f48ee9088171c0c75b5ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ae42ba94c830f48ee9088171c0c75b5ac">operator=</a> (<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ae42ba94c830f48ee9088171c0c75b5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>.  <a href="classbio_1_1bitcompressed__vector.html#ae42ba94c830f48ee9088171c0c75b5ac">More...</a><br /></td></tr>
<tr class="separator:ae42ba94c830f48ee9088171c0c75b5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1d61708330304b42a618d95d6e00dd"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range other_range_t&gt; </td></tr>
<tr class="memitem:aea1d61708330304b42a618d95d6e00dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#aea1d61708330304b42a618d95d6e00dd">assign</a> (other_range_t &amp;&amp;range)</td></tr>
<tr class="memdesc:aea1d61708330304b42a618d95d6e00dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a different range.  <a href="classbio_1_1bitcompressed__vector.html#aea1d61708330304b42a618d95d6e00dd">More...</a><br /></td></tr>
<tr class="separator:aea1d61708330304b42a618d95d6e00dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1861fe78fa907f005b26fb07a69c8561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a1861fe78fa907f005b26fb07a69c8561">assign</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const count, <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const value)</td></tr>
<tr class="memdesc:a1861fe78fa907f005b26fb07a69c8561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign with <code>count</code> times <code>value</code>.  <a href="classbio_1_1bitcompressed__vector.html#a1861fe78fa907f005b26fb07a69c8561">More...</a><br /></td></tr>
<tr class="separator:a1861fe78fa907f005b26fb07a69c8561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acb64a18c0229ba1a60128b9bfd57c3"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </td></tr>
<tr class="memitem:a0acb64a18c0229ba1a60128b9bfd57c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a0acb64a18c0229ba1a60128b9bfd57c3">assign</a> (begin_iterator_type begin_it, end_iterator_type end_it)</td></tr>
<tr class="memdesc:a0acb64a18c0229ba1a60128b9bfd57c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from pair of iterators.  <a href="classbio_1_1bitcompressed__vector.html#a0acb64a18c0229ba1a60128b9bfd57c3">More...</a><br /></td></tr>
<tr class="separator:a0acb64a18c0229ba1a60128b9bfd57c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d28eb22054f7471e0e83046c5015f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ac0d28eb22054f7471e0e83046c5015f1">assign</a> (<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ac0d28eb22054f7471e0e83046c5015f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>.  <a href="classbio_1_1bitcompressed__vector.html#ac0d28eb22054f7471e0e83046c5015f1">More...</a><br /></td></tr>
<tr class="separator:ac0d28eb22054f7471e0e83046c5015f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a1bed2f5665f704de7af5a58d7efb6d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a1bed2f5665f704de7af5a58d7efb6d74">begin</a> () noexcept</td></tr>
<tr class="memdesc:a1bed2f5665f704de7af5a58d7efb6d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classbio_1_1bitcompressed__vector.html#a1bed2f5665f704de7af5a58d7efb6d74">More...</a><br /></td></tr>
<tr class="separator:a1bed2f5665f704de7af5a58d7efb6d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc08572f9ee4834ed862a9168f5e747"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#addc08572f9ee4834ed862a9168f5e747">begin</a> () const noexcept</td></tr>
<tr class="memdesc:addc08572f9ee4834ed862a9168f5e747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classbio_1_1bitcompressed__vector.html#addc08572f9ee4834ed862a9168f5e747">More...</a><br /></td></tr>
<tr class="separator:addc08572f9ee4834ed862a9168f5e747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47baac5753dfc6b975f560550b646b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#af47baac5753dfc6b975f560550b646b4">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:af47baac5753dfc6b975f560550b646b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classbio_1_1bitcompressed__vector.html#af47baac5753dfc6b975f560550b646b4">More...</a><br /></td></tr>
<tr class="separator:af47baac5753dfc6b975f560550b646b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c4ca8855e6f2be0d10fbfb49f4f347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347">end</a> () noexcept</td></tr>
<tr class="memdesc:a00c4ca8855e6f2be0d10fbfb49f4f347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347">More...</a><br /></td></tr>
<tr class="separator:a00c4ca8855e6f2be0d10fbfb49f4f347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55d41b22741b32c714330a4a7b203ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ad55d41b22741b32c714330a4a7b203ea">end</a> () const noexcept</td></tr>
<tr class="memdesc:ad55d41b22741b32c714330a4a7b203ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classbio_1_1bitcompressed__vector.html#ad55d41b22741b32c714330a4a7b203ea">More...</a><br /></td></tr>
<tr class="separator:ad55d41b22741b32c714330a4a7b203ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52de0015268121a2fcefcda7debb531c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a52de0015268121a2fcefcda7debb531c">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a52de0015268121a2fcefcda7debb531c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classbio_1_1bitcompressed__vector.html#a52de0015268121a2fcefcda7debb531c">More...</a><br /></td></tr>
<tr class="separator:a52de0015268121a2fcefcda7debb531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr class="memitem:a643e68c622dbfd90b318f4082c7274c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a643e68c622dbfd90b318f4082c7274c0">at</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const i)</td></tr>
<tr class="memdesc:a643e68c622dbfd90b318f4082c7274c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element.  <a href="classbio_1_1bitcompressed__vector.html#a643e68c622dbfd90b318f4082c7274c0">More...</a><br /></td></tr>
<tr class="separator:a643e68c622dbfd90b318f4082c7274c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d9315f01cb2f72bc1e2ad0761c644d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ae5d9315f01cb2f72bc1e2ad0761c644d">at</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const i) const</td></tr>
<tr class="memdesc:ae5d9315f01cb2f72bc1e2ad0761c644d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element.  <a href="classbio_1_1bitcompressed__vector.html#ae5d9315f01cb2f72bc1e2ad0761c644d">More...</a><br /></td></tr>
<tr class="separator:ae5d9315f01cb2f72bc1e2ad0761c644d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a30ef4ab585f7929ef2230653b9684f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a9a30ef4ab585f7929ef2230653b9684f">operator[]</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const i) noexcept</td></tr>
<tr class="memdesc:a9a30ef4ab585f7929ef2230653b9684f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element.  <a href="classbio_1_1bitcompressed__vector.html#a9a30ef4ab585f7929ef2230653b9684f">More...</a><br /></td></tr>
<tr class="separator:a9a30ef4ab585f7929ef2230653b9684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10024a7309e34090cb8fc9b3b478b755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a10024a7309e34090cb8fc9b3b478b755">operator[]</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const i) const noexcept</td></tr>
<tr class="memdesc:a10024a7309e34090cb8fc9b3b478b755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th element.  <a href="classbio_1_1bitcompressed__vector.html#a10024a7309e34090cb8fc9b3b478b755">More...</a><br /></td></tr>
<tr class="separator:a10024a7309e34090cb8fc9b3b478b755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a64a3f7b23d385bba3723e1f8dc44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a351a64a3f7b23d385bba3723e1f8dc44">front</a> () noexcept</td></tr>
<tr class="memdesc:a351a64a3f7b23d385bba3723e1f8dc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element. Calling front on an empty container is undefined.  <a href="classbio_1_1bitcompressed__vector.html#a351a64a3f7b23d385bba3723e1f8dc44">More...</a><br /></td></tr>
<tr class="separator:a351a64a3f7b23d385bba3723e1f8dc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0da9b101b2900f0cf2fd5dbddf678b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ad0da9b101b2900f0cf2fd5dbddf678b0">front</a> () const noexcept</td></tr>
<tr class="memdesc:ad0da9b101b2900f0cf2fd5dbddf678b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element. Calling front on an empty container is undefined.  <a href="classbio_1_1bitcompressed__vector.html#ad0da9b101b2900f0cf2fd5dbddf678b0">More...</a><br /></td></tr>
<tr class="separator:ad0da9b101b2900f0cf2fd5dbddf678b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba1805de922f834686c33ba73cd852b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a8ba1805de922f834686c33ba73cd852b">back</a> () noexcept</td></tr>
<tr class="memdesc:a8ba1805de922f834686c33ba73cd852b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element.  <a href="classbio_1_1bitcompressed__vector.html#a8ba1805de922f834686c33ba73cd852b">More...</a><br /></td></tr>
<tr class="separator:a8ba1805de922f834686c33ba73cd852b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87765b7551285b8fdcaaad3515cfb32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a87765b7551285b8fdcaaad3515cfb32f">back</a> () const noexcept</td></tr>
<tr class="memdesc:a87765b7551285b8fdcaaad3515cfb32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element.  <a href="classbio_1_1bitcompressed__vector.html#a87765b7551285b8fdcaaad3515cfb32f">More...</a><br /></td></tr>
<tr class="separator:a87765b7551285b8fdcaaad3515cfb32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a977b266705b8dc4629315c85ceed30"><td class="memItemLeft" align="right" valign="top">constexpr data_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a0a977b266705b8dc4629315c85ceed30">raw_data</a> () noexcept</td></tr>
<tr class="memdesc:a0a977b266705b8dc4629315c85ceed30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct, unsafe access to underlying data structures.  <a href="classbio_1_1bitcompressed__vector.html#a0a977b266705b8dc4629315c85ceed30">More...</a><br /></td></tr>
<tr class="separator:a0a977b266705b8dc4629315c85ceed30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf0f8ea29f9c55a8e2f4d193806302f"><td class="memItemLeft" align="right" valign="top">constexpr data_type const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a9bf0f8ea29f9c55a8e2f4d193806302f">raw_data</a> () const noexcept</td></tr>
<tr class="memdesc:a9bf0f8ea29f9c55a8e2f4d193806302f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct, unsafe access to underlying data structures.  <a href="classbio_1_1bitcompressed__vector.html#a9bf0f8ea29f9c55a8e2f4d193806302f">More...</a><br /></td></tr>
<tr class="separator:a9bf0f8ea29f9c55a8e2f4d193806302f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:a7d7ef5a5d4ae3888083376256e3345e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7d7ef5a5d4ae3888083376256e3345e0">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a7d7ef5a5d4ae3888083376256e3345e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="classbio_1_1bitcompressed__vector.html#a7d7ef5a5d4ae3888083376256e3345e0">More...</a><br /></td></tr>
<tr class="separator:a7d7ef5a5d4ae3888083376256e3345e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295bd19be040cbdfbd7d02c02608da20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20">size</a> () const noexcept</td></tr>
<tr class="memdesc:a295bd19be040cbdfbd7d02c02608da20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(<a class="el" href="classbio_1_1bitcompressed__vector.html#a1bed2f5665f704de7af5a58d7efb6d74" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a>).  <a href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20">More...</a><br /></td></tr>
<tr class="separator:a295bd19be040cbdfbd7d02c02608da20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5e568dcefe38275c1a47af4913e27c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a5d5e568dcefe38275c1a47af4913e27c">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a5d5e568dcefe38275c1a47af4913e27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="classbio_1_1bitcompressed__vector.html#a1bed2f5665f704de7af5a58d7efb6d74" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a>) for the largest container.  <a href="classbio_1_1bitcompressed__vector.html#a5d5e568dcefe38275c1a47af4913e27c">More...</a><br /></td></tr>
<tr class="separator:a5d5e568dcefe38275c1a47af4913e27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efc2081d1d54cebbf1e9d79358a84fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a5efc2081d1d54cebbf1e9d79358a84fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for.  <a href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc">More...</a><br /></td></tr>
<tr class="separator:a5efc2081d1d54cebbf1e9d79358a84fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e9603eca3cd066eede88603eeaf0f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a83e9603eca3cd066eede88603eeaf0f4">reserve</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const new_cap)</td></tr>
<tr class="memdesc:a83e9603eca3cd066eede88603eeaf0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity to a value that's greater or equal to new_cap.  <a href="classbio_1_1bitcompressed__vector.html#a83e9603eca3cd066eede88603eeaf0f4">More...</a><br /></td></tr>
<tr class="separator:a83e9603eca3cd066eede88603eeaf0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce571abdb61d2782922841983241764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a8ce571abdb61d2782922841983241764">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a8ce571abdb61d2782922841983241764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <a href="classbio_1_1bitcompressed__vector.html#a8ce571abdb61d2782922841983241764">More...</a><br /></td></tr>
<tr class="separator:a8ce571abdb61d2782922841983241764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr class="memitem:af7f192071d2acdaefda4d3cd436a8702"><td class="memItemLeft" align="right" valign="top"><a id="af7f192071d2acdaefda4d3cd436a8702"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#af7f192071d2acdaefda4d3cd436a8702">operator==</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:af7f192071d2acdaefda4d3cd436a8702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is equal to <code>rhs</code>. <br /></td></tr>
<tr class="separator:af7f192071d2acdaefda4d3cd436a8702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019dd7bcd1e5dab41fe574fefac06b9c"><td class="memItemLeft" align="right" valign="top"><a id="a019dd7bcd1e5dab41fe574fefac06b9c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a019dd7bcd1e5dab41fe574fefac06b9c">operator!=</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a019dd7bcd1e5dab41fe574fefac06b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is not equal to <code>rhs</code>. <br /></td></tr>
<tr class="separator:a019dd7bcd1e5dab41fe574fefac06b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9a588a97d62f3e0c0abc0dba154239"><td class="memItemLeft" align="right" valign="top"><a id="a7c9a588a97d62f3e0c0abc0dba154239"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c9a588a97d62f3e0c0abc0dba154239">operator&lt;</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a7c9a588a97d62f3e0c0abc0dba154239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is less than <code>rhs</code>. <br /></td></tr>
<tr class="separator:a7c9a588a97d62f3e0c0abc0dba154239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989318971d230696d53997275ca40ef2"><td class="memItemLeft" align="right" valign="top"><a id="a989318971d230696d53997275ca40ef2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a989318971d230696d53997275ca40ef2">operator&gt;</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a989318971d230696d53997275ca40ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is greater than <code>rhs</code>. <br /></td></tr>
<tr class="separator:a989318971d230696d53997275ca40ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fb7f32a0e82ccbdebb82eee88d9614"><td class="memItemLeft" align="right" valign="top"><a id="a98fb7f32a0e82ccbdebb82eee88d9614"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a98fb7f32a0e82ccbdebb82eee88d9614">operator&lt;=</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a98fb7f32a0e82ccbdebb82eee88d9614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is less than or equal to <code>rhs</code>. <br /></td></tr>
<tr class="separator:a98fb7f32a0e82ccbdebb82eee88d9614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d71be0d3fc9f9f440031941869b2f1a"><td class="memItemLeft" align="right" valign="top"><a id="a5d71be0d3fc9f9f440031941869b2f1a"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a5d71be0d3fc9f9f440031941869b2f1a">operator&gt;=</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a5d71be0d3fc9f9f440031941869b2f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is greater than or equal to <code>rhs</code>. <br /></td></tr>
<tr class="separator:a5d71be0d3fc9f9f440031941869b2f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Modifiers</h2></td></tr>
<tr class="memitem:a15948168c438aad04753fdf1144ad5db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a15948168c438aad04753fdf1144ad5db">clear</a> () noexcept</td></tr>
<tr class="memdesc:a15948168c438aad04753fdf1144ad5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the container.  <a href="classbio_1_1bitcompressed__vector.html#a15948168c438aad04753fdf1144ad5db">More...</a><br /></td></tr>
<tr class="separator:a15948168c438aad04753fdf1144ad5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe29373a636b706dbd6cc13694918804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#afe29373a636b706dbd6cc13694918804">insert</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> pos, <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const value)</td></tr>
<tr class="memdesc:afe29373a636b706dbd6cc13694918804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value before position in the container.  <a href="classbio_1_1bitcompressed__vector.html#afe29373a636b706dbd6cc13694918804">More...</a><br /></td></tr>
<tr class="separator:afe29373a636b706dbd6cc13694918804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6ce56fa5b723ddec40d6e995588726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a9c6ce56fa5b723ddec40d6e995588726">insert</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> pos, <a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const count, <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const value)</td></tr>
<tr class="memdesc:a9c6ce56fa5b723ddec40d6e995588726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of value before position in the container.  <a href="classbio_1_1bitcompressed__vector.html#a9c6ce56fa5b723ddec40d6e995588726">More...</a><br /></td></tr>
<tr class="separator:a9c6ce56fa5b723ddec40d6e995588726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6937f9c4ae6c83cd54a88fef91607edb"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </td></tr>
<tr class="memitem:a6937f9c4ae6c83cd54a88fef91607edb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a6937f9c4ae6c83cd54a88fef91607edb">insert</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> pos, begin_iterator_type begin_it, end_iterator_type end_it)</td></tr>
<tr class="memdesc:a6937f9c4ae6c83cd54a88fef91607edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range <code>[begin_it, end_it)</code> before position in the container.  <a href="classbio_1_1bitcompressed__vector.html#a6937f9c4ae6c83cd54a88fef91607edb">More...</a><br /></td></tr>
<tr class="separator:a6937f9c4ae6c83cd54a88fef91607edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a1c950fdd86768a8a369a6c150c280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a62a1c950fdd86768a8a369a6c150c280">insert</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> pos, <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> &gt; const &amp;ilist)</td></tr>
<tr class="memdesc:a62a1c950fdd86768a8a369a6c150c280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list before position in the container.  <a href="classbio_1_1bitcompressed__vector.html#a62a1c950fdd86768a8a369a6c150c280">More...</a><br /></td></tr>
<tr class="separator:a62a1c950fdd86768a8a369a6c150c280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58c0c880aed1fe92e7368b321bcb86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#af58c0c880aed1fe92e7368b321bcb86b">erase</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> begin_it, <a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> end_it)</td></tr>
<tr class="memdesc:af58c0c880aed1fe92e7368b321bcb86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified elements from the container.  <a href="classbio_1_1bitcompressed__vector.html#af58c0c880aed1fe92e7368b321bcb86b">More...</a><br /></td></tr>
<tr class="separator:af58c0c880aed1fe92e7368b321bcb86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ceeca8b41079b1c15d86a22874b4b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a18ceeca8b41079b1c15d86a22874b4b0">erase</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a18ceeca8b41079b1c15d86a22874b4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified elements from the container.  <a href="classbio_1_1bitcompressed__vector.html#a18ceeca8b41079b1c15d86a22874b4b0">More...</a><br /></td></tr>
<tr class="separator:a18ceeca8b41079b1c15d86a22874b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aacba70d90008824de4bdf425aeb68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a29aacba70d90008824de4bdf425aeb68">push_back</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const value)</td></tr>
<tr class="memdesc:a29aacba70d90008824de4bdf425aeb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <a href="classbio_1_1bitcompressed__vector.html#a29aacba70d90008824de4bdf425aeb68">More...</a><br /></td></tr>
<tr class="separator:a29aacba70d90008824de4bdf425aeb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0eca6ca74207ac20006d51f735fee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#afa0eca6ca74207ac20006d51f735fee5">pop_back</a> ()</td></tr>
<tr class="memdesc:afa0eca6ca74207ac20006d51f735fee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container.  <a href="classbio_1_1bitcompressed__vector.html#afa0eca6ca74207ac20006d51f735fee5">More...</a><br /></td></tr>
<tr class="separator:afa0eca6ca74207ac20006d51f735fee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab72f3bf702d164dacfac0b529895cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#abab72f3bf702d164dacfac0b529895cf">resize</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const count)</td></tr>
<tr class="memdesc:abab72f3bf702d164dacfac0b529895cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classbio_1_1bitcompressed__vector.html#abab72f3bf702d164dacfac0b529895cf">More...</a><br /></td></tr>
<tr class="separator:abab72f3bf702d164dacfac0b529895cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add41a2e4955b8481da2c02fdee8098d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#add41a2e4955b8481da2c02fdee8098d8">resize</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const count, <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const value)</td></tr>
<tr class="memdesc:add41a2e4955b8481da2c02fdee8098d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classbio_1_1bitcompressed__vector.html#add41a2e4955b8481da2c02fdee8098d8">More...</a><br /></td></tr>
<tr class="separator:add41a2e4955b8481da2c02fdee8098d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301e5ffe3f8dbbc8d0eace4775a53bb5"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a301e5ffe3f8dbbc8d0eace4775a53bb5">swap</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a301e5ffe3f8dbbc8d0eace4775a53bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents with another instance.  <a href="classbio_1_1bitcompressed__vector.html#a301e5ffe3f8dbbc8d0eace4775a53bb5">More...</a><br /></td></tr>
<tr class="separator:a301e5ffe3f8dbbc8d0eace4775a53bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb6f62a3a6042f2599192df2f8785c2"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a8eb6f62a3a6042f2599192df2f8785c2">swap</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8eb6f62a3a6042f2599192df2f8785c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents with another instance.  <a href="classbio_1_1bitcompressed__vector.html#a8eb6f62a3a6042f2599192df2f8785c2">More...</a><br /></td></tr>
<tr class="separator:a8eb6f62a3a6042f2599192df2f8785c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ebc82faec312807470178e261e390f"><td class="memItemLeft" align="right" valign="top">constexpr friend void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#ae8ebc82faec312807470178e261e390f">swap</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;lhs, <a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae8ebc82faec312807470178e261e390f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents with another instance.  <a href="classbio_1_1bitcompressed__vector.html#ae8ebc82faec312807470178e261e390f">More...</a><br /></td></tr>
<tr class="separator:ae8ebc82faec312807470178e261e390f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028d679dd297df9752edce7d683050b3"><td class="memItemLeft" align="right" valign="top"><a id="a028d679dd297df9752edce7d683050b3"></a>
constexpr friend void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1bitcompressed__vector.html#a028d679dd297df9752edce7d683050b3">swap</a> (<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;&amp;lhs, <a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a028d679dd297df9752edce7d683050b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a028d679dd297df9752edce7d683050b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;writable_semialphabet alphabet_type&gt;<br />
class bio::bitcompressed_vector&lt; alphabet_type &gt;</h3>

<p>A space-optimised version of <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> that compresses multiple letters into a single byte. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alphabet_type</td><td>The value type of the container, must satisfy <a class="el" href="interfacebio_1_1writable__semialphabet.html" title="A refinement of bio::semialphabet that adds assignability.">bio::writable_semialphabet</a> and std::regular.</td></tr>
  </table>
  </dd>
</dl>
<p>This class template behaves just like std::vector&lt;alphabet_type&gt; but has an internal representation where multiple values are packed into a single byte/word to save space, e.g. <a class="el" href="classbio_1_1bitcompressed__vector.html#a10562d4b7d2a2d936860da55dd7f835e" title="Defaulted.">bitcompressed_vector&lt;bio::dna4&gt;</a> uses a quarter of of the memory that std::vector&lt;bio::dna4&gt; uses, because a single <a class="el" href="classbio_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T.">bio::dna4</a> letter can be represented in two bits (instead of 8 which is the lower bound for a single object in C++).</p>
<p>The disadvantages are slightly slower operations and unsafety towards parallel writes to adjacent positions in the <a class="el" href="classbio_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bitcompressed_vector</a>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bitcompressed__vector_8hpp.html">bio/ranges/container/bitcompressed_vector.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_dna4;</div>
<div class="line"> </div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::dna4&gt;</a>                  v0{<span class="stringliteral">&quot;ACGT&quot;</span>_dna4}; <span class="comment">// data occupies 4 bytes in memory</span></div>
<div class="line">    <a class="code" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector&lt;bio::dna4&gt;</a> v1{<span class="stringliteral">&quot;ACGT&quot;</span>_dna4}; <span class="comment">// data occupies 1 byte in memory</span></div>
<div class="line">}</div>
<div class="ttc" id="abitcompressed__vector_8hpp_html"><div class="ttname"><a href="bitcompressed__vector_8hpp.html">bitcompressed_vector.hpp</a></div><div class="ttdoc">Provides bio::bitcompressed_vector.</div></div>
<div class="ttc" id="aclassbio_1_1bitcompressed__vector_html"><div class="ttname"><a href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a></div><div class="ttdoc">A space-optimised version of std::vector that compresses multiple letters into a single byte.</div><div class="ttdef"><b>Definition:</b> bitcompressed_vector.hpp:67</div></div>
<div class="ttc" id="adna4_8hpp_html"><div class="ttname"><a href="dna4_8hpp.html">dna4.hpp</a></div><div class="ttdoc">Provides bio::dna4, container aliases and string literals.</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/vector.html">vector</a></div></div>
</div><!-- fragment --><h3>Thread safety</h3>
<p>This container provides no thread-safety beyond the promise given also by the STL that all calls to <code>const</code> member function are safe from multiple threads (as long as no thread calls a non-<code>const</code> member function at the same time).</p>
<p>An important difference to <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> is that calling <code>vec[i] = value;</code> and <code>vec[j] = value2;</code> from two different threads at the same time <b>is not safe</b> and will lead to corruption if both values are stored in the same 64bit-block, i.e. if the distance between <code>i</code> and <code>j</code> is smaller than 64 / alphabet_size. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aef2d3530fce6b52e30f9798fe92b16ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2d3530fce6b52e30f9798fe92b16ae">&#9670;&nbsp;</a></span>bitcompressed_vector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range other_range_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> </td>
          <td>(</td>
          <td class="paramtype">other_range_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a different range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">other_range_t</td><td>The type of range to construct from; must satisfy std::ranges::input_range and std::common_reference_with&lt;std::ranges::range_value_t&lt;other_range_t&gt;, <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>The sequences to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the size of <code>range</code>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a268f374bcb93ccbdf4dda59ef33b084f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268f374bcb93ccbdf4dda59ef33b084f">&#9670;&nbsp;</a></span>bitcompressed_vector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with <code>count</code> times <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The initial value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>In <img class="formulaInl" alt="$O(count)$" src="form_8.png" width="68" height="19"/>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a8719dc1579fc6864796a38ce357870a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8719dc1579fc6864796a38ce357870a5">&#9670;&nbsp;</a></span>bitcompressed_vector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> </td>
          <td>(</td>
          <td class="paramtype">begin_iterator_type&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">end_iterator_type&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from pair of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">begin_iterator_type</td><td>Must model std::forward_iterator and std::common_reference_with&lt;std::iter_value_t&lt;begin_iterator_type&gt;, <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>&gt;. </td></tr>
    <tr><td class="paramname">end_iterator_type</td><td>Must model std::sentinel_for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_it</td><td>Begin of range to construct/assign from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_it</td><td>End of range to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the distance between <code>begin_it</code> and <code>end_it</code>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a08287f09c3822a995ceb448590bae48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08287f09c3822a995ceb448590bae48d">&#9670;&nbsp;</a></span>bitcompressed_vector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::<a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>A <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code> of <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the size of <code>ilist</code>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0acb64a18c0229ba1a60128b9bfd57c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acb64a18c0229ba1a60128b9bfd57c3">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">begin_iterator_type&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">end_iterator_type&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from pair of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">begin_iterator_type</td><td>Must satisfy std::forward_iterator and std::common_reference_with&lt;std::iter_value_t&lt;begin_iterator_type&gt;, <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>&gt;. </td></tr>
    <tr><td class="paramname">end_iterator_type</td><td>Must satisfy std::sentinel_for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_it</td><td>Begin of range to construct/assign from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_it</td><td>End of range to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the distance between <code>begin_it</code> and <code>end_it</code>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="aea1d61708330304b42a618d95d6e00dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1d61708330304b42a618d95d6e00dd">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range other_range_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">other_range_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from a different range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">other_range_t</td><td>The type of range to be inserted; must satisfy std::ranges::input_range and std::common_reference_with&lt;std::ranges::range_value_t&lt;other_range_t&gt;, <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>The sequences to construct/assign from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the size of <code>range</code>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a1861fe78fa907f005b26fb07a69c8561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1861fe78fa907f005b26fb07a69c8561">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign with <code>count</code> times <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The initial value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>In <img class="formulaInl" alt="$O(count)$" src="form_8.png" width="68" height="19"/>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="ac0d28eb22054f7471e0e83046c5015f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d28eb22054f7471e0e83046c5015f1">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>A <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code> of <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the size of <code>ilist</code>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a643e68c622dbfd90b318f4082c7274c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643e68c622dbfd90b318f4082c7274c0">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>If you access an element behind the last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either a writable proxy to the element or a copy (if called in const context).</dd></dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>Throws <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a> if <code>i &gt;= <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a></code>. </p>

</div>
</div>
<a id="ae5d9315f01cb2f72bc1e2ad0761c644d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d9315f01cb2f72bc1e2ad0761c644d">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>If you access an element behind the last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either a writable proxy to the element or a copy (if called in const context).</dd></dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>Throws <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a> if <code>i &gt;= <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a></code>. </p>

</div>
</div>
<a id="a87765b7551285b8fdcaaad3515cfb32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87765b7551285b8fdcaaad3515cfb32f">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Either a writable proxy to the element or a copy (if called in const context).</dd></dl>
<p>Calling back on an empty container is undefined. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a8ba1805de922f834686c33ba73cd852b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba1805de922f834686c33ba73cd852b">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Either a writable proxy to the element or a copy (if called in const context).</dd></dl>
<p>Calling back on an empty container is undefined. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="addc08572f9ee4834ed862a9168f5e747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc08572f9ee4834ed862a9168f5e747">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a>.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a1bed2f5665f704de7af5a58d7efb6d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bed2f5665f704de7af5a58d7efb6d74">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a>.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a5efc2081d1d54cebbf1e9d79358a84fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efc2081d1d54cebbf1e9d79358a84fc">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that the container has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the currently allocated storage.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>This does not operate on underlying concat container, see concat_capacity().</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="af47baac5753dfc6b975f560550b646b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47baac5753dfc6b975f560550b646b4">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a>.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a52de0015268121a2fcefcda7debb531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52de0015268121a2fcefcda7debb531c">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>This element acts as a placeholder; attempting to dereference it results in undefined behaviour.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a15948168c438aad04753fdf1144ad5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15948168c438aad04753fdf1144ad5db">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a7d7ef5a5d4ae3888083376256e3345e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7ef5a5d4ae3888083376256e3345e0">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty, <code>false</code> otherwise.</dd></dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="ad55d41b22741b32c714330a4a7b203ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55d41b22741b32c714330a4a7b203ea">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>This element acts as a placeholder; attempting to dereference it results in undefined behaviour.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a00c4ca8855e6f2be0d10fbfb49f4f347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c4ca8855e6f2be0d10fbfb49f4f347">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<p>This element acts as a placeholder; attempting to dereference it results in undefined behaviour.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="af58c0c880aed1fe92e7368b321bcb86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58c0c880aed1fe92e7368b321bcb86b">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified elements from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_it</td><td>Begin of range to erase. </td></tr>
    <tr><td class="paramname">end_it</td><td>Behind the end of range to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last element removed. If the iterator <code>pos</code> refers to the last element, the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator is returned.</dd></dl>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator.</p>
<p>The iterator first does not need to be dereferenceable if first==end_it: erasing an empty range is a no-op.</p>
<h3>Complexity</h3>
<p>Linear in <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee, i.e. guaranteed not to leak, but container may contain invalid data after exception is thrown. </p>

</div>
</div>
<a id="a18ceeca8b41079b1c15d86a22874b4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ceeca8b41079b1c15d86a22874b4b0">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified elements from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Remove the element at pos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last element removed. If the iterator <code>pos</code> refers to the last element, the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator is returned.</dd></dl>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator.</p>
<p>The iterator <code>pos</code> must be valid and dereferenceable. Thus the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator (which is valid, but is not dereferencable) cannot be used as a value for pos.</p>
<h3>Complexity</h3>
<p>Linear in <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee, i.e. guaranteed not to leak, but container may contain invalid data after exception is thrown. </p>

</div>
</div>
<a id="ad0da9b101b2900f0cf2fd5dbddf678b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0da9b101b2900f0cf2fd5dbddf678b0">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first element. Calling front on an empty container is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd>Either a writable proxy to the element or a copy (if called in const context).</dd></dl>
<p>Calling front on an empty container is undefined. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a351a64a3f7b23d385bba3723e1f8dc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351a64a3f7b23d385bba3723e1f8dc44">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first element. Calling front on an empty container is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd>Either a writable proxy to the element or a copy (if called in const context).</dd></dl>
<p>Calling front on an empty container is undefined. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a6937f9c4ae6c83cd54a88fef91607edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6937f9c4ae6c83cd54a88fef91607edb">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator begin_iterator_type, typename end_iterator_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">begin_iterator_type&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">end_iterator_type&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range <code>[begin_it, end_it)</code> before position in the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">begin_iterator_type</td><td>Must satisfy std::forward_iterator and std::common_reference_with&lt;std::iter_value_t&lt;begin_iterator_type&gt;, <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>&gt;. </td></tr>
    <tr><td class="paramname">end_iterator_type</td><td>Must satisfy std::sentinel_for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator before which the content will be inserted. <code>pos</code> may be the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_it</td><td>Begin of range to construct/assign from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_it</td><td>End of range to construct/assign from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or <code>pos</code> if <code>begin_it==end_it</code>.</dd></dl>
<p>The behaviour is undefined if begin_it and end_it are iterators into <code>*this</code>.</p>
<p>Causes reallocation if the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than the old <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>. If the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<h3>Complexity</h3>
<p>Worst-case linear in <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee, i.e. guaranteed not to leak, but container may contain invalid data after exception is thrown. </p>

</div>
</div>
<a id="a9c6ce56fa5b723ddec40d6e995588726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6ce56fa5b723ddec40d6e995588726">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of value before position in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. <code>pos</code> may be the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">count</td><td>Number of copies. </td></tr>
    <tr><td class="paramname">value</td><td>Element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or <code>pos</code> if <code>count==0</code>.</dd></dl>
<p>Causes reallocation if the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than the old <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>. If the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<h3>Complexity</h3>
<p>Worst-case linear in concat_size(). This is a drawback over e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;alphabet&gt;&gt;</code>.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee, i.e. guaranteed not to leak, but container may contain invalid data after exception is thrown. </p>

</div>
</div>
<a id="a62a1c950fdd86768a8a369a6c150c280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a1c950fdd86768a8a369a6c150c280">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list before position in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. <code>pos</code> may be the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">ilist</td><td>Initializer list with values to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or <code>pos</code> if <code>ilist</code> is empty.</dd></dl>
<p>Causes reallocation if the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than the old <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>. If the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<h3>Complexity</h3>
<p>Worst-case linear in concat_size(). This is a drawback over e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;alphabet&gt;&gt;</code>.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee, i.e. guaranteed not to leak, but container may contain invalid data after exception is thrown. </p>

</div>
</div>
<a id="afe29373a636b706dbd6cc13694918804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe29373a636b706dbd6cc13694918804">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7cc5c931e4e2eb5dbe0980684d1e8ba9">iterator</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7c71d49e13956c39731e31cb1d2e544d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value before position in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. <code>pos</code> may be the <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">value</td><td>Element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the inserted value.</dd></dl>
<p>Causes reallocation if the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than the old <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>. If the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<h3>Complexity</h3>
<p>Worst-case linear in <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee, i.e. guaranteed not to leak, but container may contain invalid data after exception is thrown. </p>

</div>
</div>
<a id="a5d5e568dcefe38275c1a47af4913e27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5e568dcefe38275c1a47af4913e27c">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="classbio_1_1bitcompressed__vector.html#a1bed2f5665f704de7af5a58d7efb6d74" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a>) for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<p>This value typically reflects the theoretical limit on the size of the container. At runtime, the size of the container may be limited to a value smaller than <a class="el" href="classbio_1_1bitcompressed__vector.html#a5d5e568dcefe38275c1a47af4913e27c" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a> by the amount of RAM available. </p><h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="ae42ba94c830f48ee9088171c0c75b5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42ba94c830f48ee9088171c0c75b5ac">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a>&amp; <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>A <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a></code> of <a class="el" href="structbio_1_1value__type.html" title="Exposes the value_type of another type.">value_type</a>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Linear in the size of <code>ilist</code>.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a10024a7309e34090cb8fc9b3b478b755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10024a7309e34090cb8fc9b3b478b755">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#aa9726a45c5a216b20db7950b1115334f">const_reference</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either a writable proxy to the element or a copy (if called in const context).</dd></dl>
<p>Accessing an element behind the last causes undefined behaviour. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a9a30ef4ab585f7929ef2230653b9684f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a30ef4ab585f7929ef2230653b9684f">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#a7fbce5b446665ed3468cef3ba594c05b">reference</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i-th element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either a writable proxy to the element or a copy (if called in const context).</dd></dl>
<p>Accessing an element behind the last causes undefined behaviour. In debug mode an assertion checks the size of the container.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="afa0eca6ca74207ac20006d51f735fee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0eca6ca74207ac20006d51f735fee5">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. </p>
<p>Calling <a class="el" href="classbio_1_1bitcompressed__vector.html#afa0eca6ca74207ac20006d51f735fee5" title="Removes the last element of the container.">pop_back()</a> on an empty container is undefined. In debug mode an assertion will be thrown.</p>
<p>No iterators or references except for <a class="el" href="classbio_1_1bitcompressed__vector.html#a8ba1805de922f834686c33ba73cd852b" title="Return the last element.">back()</a> and <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a> are invalidated.</p>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No exception is thrown in release mode.</p>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a29aacba70d90008824de4bdf425aeb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aacba70d90008824de4bdf425aeb68">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append.</td></tr>
  </table>
  </dd>
</dl>
<p>If the new <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</p>
<h3>Complexity</h3>
<p>Amortised constant, worst-case linear in <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>.</p>
<h3>Exceptions</h3>
<p>Basic exception guarantee, i.e. guaranteed not to leak, but container may contain invalid data after exception is thrown. </p>

</div>
</div>
<a id="a9bf0f8ea29f9c55a8e2f4d193806302f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf0f8ea29f9c55a8e2f4d193806302f">&#9670;&nbsp;</a></span>raw_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr data_type const&amp; <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::raw_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides direct, unsafe access to underlying data structures. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to an SDSL bitvector.</dd></dl>
<p>The exact representation of the data is implementation defined. Do not rely on it for API stability. </p>

</div>
</div>
<a id="a0a977b266705b8dc4629315c85ceed30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a977b266705b8dc4629315c85ceed30">&#9670;&nbsp;</a></span>raw_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr data_type&amp; <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::raw_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides direct, unsafe access to underlying data structures. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to an SDSL bitvector.</dd></dl>
<p>The exact representation of the data is implementation defined. Do not rely on it for API stability. </p>

</div>
</div>
<a id="a83e9603eca3cd066eede88603eeaf0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e9603eca3cd066eede88603eeaf0f4">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity to a value that's greater or equal to new_cap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>The new capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If new_cap &gt; <a class="el" href="classbio_1_1bitcompressed__vector.html#a5d5e568dcefe38275c1a47af4913e27c" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/exception.html">std::exception</a></td><td>Any exception thrown by <code>Allocator::allocate()</code> (typically <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc.html">std::bad_alloc</a></code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Increase the capacity of the vector to a value that's greater or equal to new_cap. If new_cap is greater than the current <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, new storage is allocated, otherwise the method does nothing. If new_cap is greater than <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</p>
<h3>Complexity</h3>
<p>At most linear in the <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the container.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="abab72f3bf702d164dacfac0b529895cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab72f3bf702d164dacfac0b529895cf">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If count &gt; <a class="el" href="classbio_1_1bitcompressed__vector.html#a5d5e568dcefe38275c1a47af4913e27c" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/exception.html">std::exception</a></td><td>Any exception thrown by <code>Allocator::allocate()</code> (typically <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc.html">std::bad_alloc</a></code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Increase the <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the vector to count.</p>
<p>If the current <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> is smaller than count, new storage is allocated and all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise only the past-the-end iterator is invalidated.</p>
<p>If the current size is greater than count, the container is reduced to its first count elements. Capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of <a class="el" href="classbio_1_1bitcompressed__vector.html#afa0eca6ca74207ac20006d51f735fee5" title="Removes the last element of the container.">pop_back()</a> calls.</p>
<h3>Complexity</h3>
<p>At most linear in the <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the container.</p>
<h3>Exceptions</h3>
<p>Only new size: Strong exception guarantee (no data is modified in case an exception is thrown).</p>
<p>New default value: Basic exception guarantee, i.e. guaranteed not to leak, but container my contain bogus data after exceptions is thrown. </p>

</div>
</div>
<a id="add41a2e4955b8481da2c02fdee8098d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add41a2e4955b8481da2c02fdee8098d8">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html#ac9ee67bf9f36119e001763eee14e3e60">value_type</a> const&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Append copies of value when resizing. </td></tr>
    <tr><td class="paramname">count</td><td>The new size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If count &gt; <a class="el" href="classbio_1_1bitcompressed__vector.html#a5d5e568dcefe38275c1a47af4913e27c" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/error/exception.html">std::exception</a></td><td>Any exception thrown by <code>Allocator::allocate()</code> (typically <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc.html">std::bad_alloc</a></code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Increase the <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the vector to count.</p>
<p>If the current <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> is smaller than count, new storage is allocated and all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise only the past-the-end iterator is invalidated.</p>
<p>If the current size is greater than count, the container is reduced to its first count elements. Capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of <a class="el" href="classbio_1_1bitcompressed__vector.html#afa0eca6ca74207ac20006d51f735fee5" title="Removes the last element of the container.">pop_back()</a> calls.</p>
<h3>Complexity</h3>
<p>At most linear in the <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the container.</p>
<h3>Exceptions</h3>
<p>Only new size: Strong exception guarantee (no data is modified in case an exception is thrown).</p>
<p>New default value: Basic exception guarantee, i.e. guaranteed not to leak, but container my contain bogus data after exceptions is thrown. </p>

</div>
</div>
<a id="a8ce571abdb61d2782922841983241764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce571abdb61d2782922841983241764">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>
<p>It is a non-binding request to reduce <a class="el" href="classbio_1_1bitcompressed__vector.html#a5efc2081d1d54cebbf1e9d79358a84fc" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> to <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> and concat_capacity() to concat_size(). It depends on the implementation if the request is fulfilled. If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</p>
<h3>Complexity</h3>
<p>At most linear in the <a class="el" href="classbio_1_1bitcompressed__vector.html#a295bd19be040cbdfbd7d02c02608da20" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> of the container.</p>
<h3>Exceptions</h3>
<p>Strong exception guarantee (no data is modified in case an exception is thrown). </p>

</div>
</div>
<a id="a295bd19be040cbdfbd7d02c02608da20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295bd19be040cbdfbd7d02c02608da20">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbio_1_1bitcompressed__vector.html#ab58a3a61636aa19e0fdfc70e5b06a779">size_type</a> <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. std::distance(<a class="el" href="classbio_1_1bitcompressed__vector.html#a1bed2f5665f704de7af5a58d7efb6d74" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classbio_1_1bitcompressed__vector.html#a00c4ca8855e6f2be0d10fbfb49f4f347" title="Returns an iterator to the element following the last element of the container.">end()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a8eb6f62a3a6042f2599192df2f8785c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb6f62a3a6042f2599192df2f8785c2">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a>&lt; alphabet_type &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap contents with another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The other instance to swap with.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a301e5ffe3f8dbbc8d0eace4775a53bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301e5ffe3f8dbbc8d0eace4775a53bb5">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classbio_1_1bitcompressed__vector.html">bio::bitcompressed_vector</a>&lt; alphabet_type &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a>&lt; alphabet_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap contents with another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The other instance to swap with.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae8ebc82faec312807470178e261e390f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ebc82faec312807470178e261e390f">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable_semialphabet alphabet_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr friend void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a>&lt; alphabet_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a>&lt; alphabet_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap contents with another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first instance. </td></tr>
    <tr><td class="paramname">rhs</td><td>The other instance to swap with.</td></tr>
  </table>
  </dd>
</dl>
<h3>Complexity</h3>
<p>Constant.</p>
<h3>Exceptions</h3>
<p>No-throw guarantee. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bio/ranges/container/<a class="el" href="bitcompressed__vector_8hpp_source.html">bitcompressed_vector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="navelem"><a class="el" href="namespacebio.html">bio</a></li><li class="navelem"><a class="el" href="classbio_1_1bitcompressed__vector.html">bitcompressed_vector</a></li>
    <li class="footer">Generated on Sun Jun 12 2022 17:23:28 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
