<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: Alphabet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">BioC++<span id="projectnumber">&#160;core-0.7.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__alphabet.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Alphabet</div></div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Alphabet:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__alphabet.svg" width="218" height="382"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__aminoacid"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aminoacid.html">Aminoacid</a></td></tr>
<tr class="memdesc:group__aminoacid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the amino acid alphabets and functionality for translation from nucleotide. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cigar"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cigar.html">CIGAR</a></td></tr>
<tr class="memdesc:group__cigar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides (semi-)alphabets for representing elements in CIGAR strings. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__alphabet__composite"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet__composite.html">Composite</a></td></tr>
<tr class="memdesc:group__alphabet__composite"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides templates for combining existing alphabets into new alphabet types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__alphabet__custom"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet__custom.html">Custom</a></td></tr>
<tr class="memdesc:group__alphabet__custom"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides customisation tags and alphabet adaptations of standard char and uint types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__gap"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gap.html">Gap</a></td></tr>
<tr class="memdesc:group__gap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the gap alphabet and functionality to make an alphabet a gapped alphabet. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mask"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mask.html">Mask</a></td></tr>
<tr class="memdesc:group__mask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the mask alphabet and functionality for creating masked composites. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__nucleotide"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nucleotide.html">Nucleotide</a></td></tr>
<tr class="memdesc:group__nucleotide"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the different DNA and RNA alphabet types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__quality"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__quality.html">Quality</a></td></tr>
<tr class="memdesc:group__quality"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the various quality score types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacebio_1_1alphabet"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio_1_1alphabet.html">bio::alphabet</a></td></tr>
<tr class="memdesc:namespacebio_1_1alphabet"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alphabet module's namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacebio_1_1alphabet_1_1custom"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio_1_1alphabet_1_1custom.html">bio::alphabet::custom</a></td></tr>
<tr class="memdesc:namespacebio_1_1alphabet_1_1custom"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace for third party and standard library specialisations of BioC++ customisation points. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacebio_1_1alphabet_1_1literals"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a></td></tr>
<tr class="memdesc:namespacebio_1_1alphabet_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline namespace for alphabet literals. It exists to safely allow <code>using namespace</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1alphabet_1_1base.html">bio::alphabet::base&lt; derived_type, size, char_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP-base that makes defining a custom alphabet easier.  <a href="classbio_1_1alphabet_1_1base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1alphabet_1_1base_3_01derived__type_00_011ul_00_01char__t_01_4.html">bio::alphabet::base&lt; derived_type, 1ul, char_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="classbio_1_1alphabet_1_1base.html" title="A CRTP-base that makes defining a custom alphabet easier.">bio::alphabet::base</a> for alphabets of size 1.  <a href="classbio_1_1alphabet_1_1base_3_01derived__type_00_011ul_00_01char__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01alphabet__t_01_4.html">std::hash&lt; alphabet_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for hashing a character.  <a href="structstd_1_1hash_3_01alphabet__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1alphabet_1_1proxy__base.html">bio::alphabet::proxy_base&lt; derived_type, alphabet_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP-base that eases the definition of proxy types returned in place of regular alphabets.  <a href="classbio_1_1alphabet_1_1proxy__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbio_1_1alphabet_1_1semialphabet.html">bio::alphabet::semialphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basis for <a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a>, but requires only rank interface (not char). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbio_1_1alphabet_1_1writable__semialphabet.html">bio::alphabet::writable_semialphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A refinement of <a class="el" href="conceptbio_1_1alphabet_1_1semialphabet.html" title="The basis for bio::alphabet::alphabet, but requires only rank interface (not char).">bio::alphabet::semialphabet</a> that adds assignability. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html">bio::alphabet::alphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic alphabet concept that covers most data types used in ranges. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbio_1_1alphabet_1_1writable__alphabet.html">bio::alphabet::writable_alphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines <a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> and adds assignability. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa16ddb3f7d394f68af7f530aeb24e5cf"><td class="memTemplParams" colspan="2"><a id="gaa16ddb3f7d394f68af7f530aeb24e5cf" name="gaa16ddb3f7d394f68af7f530aeb24e5cf"></a>
template&lt;typename alphabet_type &gt; </td></tr>
<tr class="memitem:gaa16ddb3f7d394f68af7f530aeb24e5cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bio::alphabet::char_t</b> = decltype(<a class="el" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/declval.html">std::declval</a>&lt; alphabet_type const  &gt;()))</td></tr>
<tr class="memdesc:gaa16ddb3f7d394f68af7f530aeb24e5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>char_type</code> of the alphabet; defined as the return type of <a class="el" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0" title="Return the char representation of an alphabet object.">bio::alphabet::to_char</a>. <br /></td></tr>
<tr class="separator:gaa16ddb3f7d394f68af7f530aeb24e5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96971d545b8ab7260d1023b83acb63a"><td class="memTemplParams" colspan="2"><a id="gaa96971d545b8ab7260d1023b83acb63a" name="gaa96971d545b8ab7260d1023b83acb63a"></a>
template&lt;typename semi_alphabet_type &gt; </td></tr>
<tr class="memitem:gaa96971d545b8ab7260d1023b83acb63a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bio::alphabet::rank_t</b> = decltype(<a class="el" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a>(<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/utility/declval.html">std::declval</a>&lt; semi_alphabet_type &gt;()))</td></tr>
<tr class="memdesc:gaa96971d545b8ab7260d1023b83acb63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>rank_type</code> of the semi-alphabet; defined as the return type of <a class="el" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e" title="Return the rank representation of a (semi-)alphabet object.">bio::alphabet::to_rank</a>. <br /></td></tr>
<tr class="separator:gaa96971d545b8ab7260d1023b83acb63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga299ddd5bf7e8221cb9d283f8a8d24f8d"><td class="memTemplParams" colspan="2">template&lt;typename alph_t , typename wrap_t  = meta::default_initialisable_wrap_t&lt;alph_t&gt;&gt; </td></tr>
<tr class="memitem:ga299ddd5bf7e8221cb9d283f8a8d24f8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d">bio::alphabet::size</a></td></tr>
<tr class="memdesc:ga299ddd5bf7e8221cb9d283f8a8d24f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that holds the size of a (semi-)alphabet.  <br /></td></tr>
<tr class="separator:ga299ddd5bf7e8221cb9d283f8a8d24f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Function objects</h2></td></tr>
<tr class="memitem:ga2a48a5c1883184e362f09e32ac33241e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a></td></tr>
<tr class="memdesc:ga2a48a5c1883184e362f09e32ac33241e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rank representation of a (semi-)alphabet object.  <br /></td></tr>
<tr class="separator:ga2a48a5c1883184e362f09e32ac33241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab718eab4e0f0e1b44f78b7600dee5e4d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">bio::alphabet::assign_rank_to</a></td></tr>
<tr class="memdesc:gab718eab4e0f0e1b44f78b7600dee5e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a rank to an alphabet object.  <br /></td></tr>
<tr class="separator:gab718eab4e0f0e1b44f78b7600dee5e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064e386f9360cca0fd3702b4957a27a0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a></td></tr>
<tr class="memdesc:ga064e386f9360cca0fd3702b4957a27a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the char representation of an alphabet object.  <br /></td></tr>
<tr class="separator:ga064e386f9360cca0fd3702b4957a27a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2eb25dabf59ccf9992b2661083ea5b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">bio::alphabet::assign_char_to</a></td></tr>
<tr class="memdesc:ga0c2eb25dabf59ccf9992b2661083ea5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a char to an alphabet object.  <br /></td></tr>
<tr class="separator:ga0c2eb25dabf59ccf9992b2661083ea5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c00e15570d3e7394f425c810e617ce"><td class="memTemplParams" colspan="2">template&lt;typename alph_t &gt; </td></tr>
<tr class="memitem:ga64c00e15570d3e7394f425c810e617ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce">bio::alphabet::char_is_valid_for</a></td></tr>
<tr class="memdesc:ga64c00e15570d3e7394f425c810e617ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a character is in the valid set of a <a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> (usually implies a bijective mapping to an alphabet value).  <br /></td></tr>
<tr class="separator:ga64c00e15570d3e7394f425c810e617ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec8dc2856700f9763590213b6cae625"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#gadec8dc2856700f9763590213b6cae625">bio::alphabet::assign_char_strictly_to</a></td></tr>
<tr class="memdesc:gadec8dc2856700f9763590213b6cae625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a character to an alphabet object, throw if the character is not valid.  <br /></td></tr>
<tr class="separator:gadec8dc2856700f9763590213b6cae625"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="autotoc_md0"></a>
Introduction</h1>
<p>Alphabets are a core component in BioC++. They enable us to represent the smallest unit of biological sequence data, e.g. a nucleotide or an amino acid.</p>
<p>In theory, these could just be represented as a <code>char</code> and this is how many people perceive them, but it makes sense to use a smaller, stricter and well-defined alphabet in almost all cases, because:</p>
<ul>
<li>Most of our sequences alphabets are actually smaller and can possibly be <b>represented by less bits</b> than a <code>char</code>, e.g. a <code>char</code> can have 256 values and thus must be represented by 8 bits of memory, but a DNA character <em>could</em> be represented by 2 bits, because it only has four values in the smallest representation ('A', 'C', 'G', 'T').</li>
<li>From a programmer's point of view it is very important to also access the <b>rank of a letter</b>, i.e. we need to be able to convert 'A', 'C', 'G', 'T' to <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> respectively. In fact the rank representation is used a lot more often than the visual representation which is only used in input/output.</li>
<li>You may want to prevent the user from selecting <b>letters that aren't part of that alphabet</b>, e.g. 'J' is not part of any nucleotide definition so people shouldn't be able to select 'J'. With a specialised alphabet you could instead convert those to a special "unknown"-character, e.g. you might want 'J' to be always converted to 'N'.</li>
</ul>
<p>In BioC++ there are alphabet types for typical sequence alphabets like DNA and amino acid, but also for qualities, RNA structures and alignment gaps. In addition there are templates for combining alphabet types into new alphabets, and wrappers for existing data types like the canonical <code>char</code>.</p>
<p>In addition to concrete alphabet types, BioC++ provides multiple <em>concepts</em> that describe groups of alphabets by their properties and can be used to <em>constrain</em> templates so that they only work with certain alphabet types. See the <a class="el" href="core_concepts.html">Tutorial on Concepts </a> for a gentle introduction to the topic.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
The alphabet concepts</h1>
<h3>alphabet size</h3>
<p>All alphabets in BioC++ have a fixed size. It can be queried via the <a class="el" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet::size</a> type trait and <em>optionally</em> also the <code>alphabet_size</code> static member of the alphabet (see below for "members VS free/global functions").</p>
<p>In some areas we provide alphabets types with different sizes for the same purpose, e.g. <a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a> ('A', 'C', 'G', 'T'), <a class="el" href="classbio_1_1alphabet_1_1dna5.html" title="The five letter DNA alphabet of A,C,G,T and the unknown character N..">bio::alphabet::dna5</a> (plus 'N') and <a class="el" href="classbio_1_1alphabet_1_1dna15.html" title="The 15 letter DNA alphabet, containing all IUPAC smybols minus the gap..">bio::alphabet::dna15</a> (plus ambiguous characters defined by IUPAC). By convention most of our alphabets carry their size in their name (<a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a> has size 4 a.s.o.).</p>
<p>A main reason for choosing a smaller alphabet over a bigger one is the possibility of <b>optimising for space efficiency</b>. Note, however, that a single letter by itself can never be smaller than a byte for architectural reasons. Actual space improvements are realised via secondary structures, e.g. when using a <code><a class="el" href="classbio_1_1ranges_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bio::ranges::bitcompressed_vector</a>&lt;<a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a>&gt;</code> instead of <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a>&gt;</code>. Also the single letter quality composite <code><a class="el" href="classbio_1_1alphabet_1_1qualified.html" title="Joins an arbitrary alphabet with a quality alphabet.">bio::alphabet::qualified</a>&lt;<a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a>, <a class="el" href="classbio_1_1alphabet_1_1phred42.html" title="Quality type for traditional Sanger and modern Illumina Phred scores (typical range)....">bio::alphabet::phred42</a>&gt;</code> fits into one byte, because the product of the alphabet sizes (4 * 42) is smaller than 256; whereas the same composite with <a class="el" href="classbio_1_1alphabet_1_1dna15.html" title="The 15 letter DNA alphabet, containing all IUPAC smybols minus the gap..">bio::alphabet::dna15</a> requires two bytes per letter (15 * 42 &gt; 256).</p>
<h3>Assigning and retrieving values</h3>
<p>As mentioned above, we typically think of alphabets in their character representation, but we also require them in "rank representation" as programmers. In C and C++ it is quite difficult to cleanly differentiate between these, because the <code>char</code> type is considered an integral type and can be used to index an array (e.g. <code>my_array['A']</code> translates to <code>my_array[65]</code>). Moreover the sign of <code>char</code> is implementation defined and on many platforms the smallest integer types <code>int8_t</code> and <code>uint8_t</code> are literally the same types as <code>signed char</code> and <code>unsigned char</code> respectively.</p>
<p>This leads to ambiguity when assigning and retrieving values:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// does not work:</span></div>
<div class="line">    <span class="comment">// bio::alphabet::dna4 my_letter{0};      // we want to set the default, an A</span></div>
<div class="line">    <span class="comment">// bio::alphabet::dna4 my_letter{&#39;A&#39;};    // we also want to set an A, but we are setting value 65</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; my_letter;         // you expect &#39;A&#39;, but how would you access the number?</span></div>
<div class="line">}</div>
<div class="ttc" id="adna4_8hpp_html"><div class="ttname"><a href="dna4_8hpp.html">dna4.hpp</a></div><div class="ttdoc">Provides bio::alphabet::dna4, container aliases and string literals.</div></div>
</div><!-- fragment --><p>To solve this problem, alphabets in BioC++ define two interfaces:</p>
<ol type="1">
<li>a <b>rank based interface</b> with<ul>
<li><a class="el" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e" title="Return the rank representation of a (semi-)alphabet object.">bio::alphabet::to_rank()</a> to produce the numerical representation;</li>
<li><a class="el" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d" title="Assign a rank to an alphabet object.">bio::alphabet::assign_rank_to()</a> to assign from the numerical representation;</li>
<li>the numerical representation is an unsigned integral type like <code>size_t</code>; the exact type can be retrieved via the <a class="el" href="group__alphabet.html#gaa96971d545b8ab7260d1023b83acb63a" title="The rank_type of the semi-alphabet; defined as the return type of bio::alphabet::to_rank.">bio::alphabet::rank_t</a>.</li>
</ul>
</li>
<li>a <b>character based interface</b> with<ul>
<li><a class="el" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0" title="Return the char representation of an alphabet object.">bio::alphabet::to_char()</a> to produce the visual representation;</li>
<li><a class="el" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b" title="Assign a char to an alphabet object.">bio::alphabet::assign_char_to()</a> to assign from the visual representation;</li>
<li><a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce" title="Returns whether a character is in the valid set of a bio::alphabet::alphabet (usually implies a bijec...">bio::alphabet::char_is_valid_for()</a> that checks whether a character value has a one-to-one mapping to an alphabet value;</li>
<li>the visual representation is a character type (almost always <code>char</code>, but could be <code>char16_t</code> or <code>char32_t</code>, as well); the exact type can be retrieved via <a class="el" href="group__alphabet.html#gaa16ddb3f7d394f68af7f530aeb24e5cf" title="The char_type of the alphabet; defined as the return type of bio::alphabet::to_char.">bio::alphabet::char_t</a>.</li>
</ul>
</li>
</ol>
<p>To prevent the aforementioned ambiguity, you can neither assign from rank or char representation via <code>operator=</code>, nor can you cast the alphabet to either of it's representation forms, <b>you need to explicitly use the interfaces</b>.</p>
<p>For efficiency, the representation saved internally is normally the rank representation, and the character representation is generated via conversion tables. This is, however, not required as long as both interfaces are provided and all functions operate in constant time.</p>
<p>The same applies for printing characters although we provide overloads for the {fmt}-library in <code>&lt;<a class="el" href="fmt_8hpp.html" title="Core alphabet concept and free function/type trait wrappers.">bio/alphabet/fmt.hpp</a>&gt;</code>.</p>
<p>Here is an example of explicit assignment of a rank and char, and how it can be printed via <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> and {fmt}: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a>&gt;</span>                                             <span class="comment">// for std::cout</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span>                                 <span class="comment">// for fmt::print</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna4.html">bio::alphabet::dna4</a> my_letter;</div>
<div class="line">    <a class="code hl_variable" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">bio::alphabet::assign_rank_to</a>(0, my_letter);                <span class="comment">// assign an A via rank interface</span></div>
<div class="line">    <a class="code hl_variable" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">bio::alphabet::assign_char_to</a>(<span class="charliteral">&#39;A&#39;</span>, my_letter);              <span class="comment">// assign an A via char interface</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(my_letter);             <span class="comment">// prints &#39;A&#39;</span></div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; (unsigned)<a class="code hl_variable" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a>(my_letter);   <span class="comment">// prints 0</span></div>
<div class="line">    <span class="comment">// we have to add the cast here, because uint8_t is also treated as a char type by default :(</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Using the format library:</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}&quot;</span>, <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(my_letter));        <span class="comment">// prints &#39;A&#39;</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}&quot;</span>, my_letter);                                <span class="comment">// prints &#39;A&#39; (calls to_char() automatically!)</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}&quot;</span>, <a class="code hl_variable" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a>(my_letter));        <span class="comment">// prints 0   (casts uint8_t to unsigned automatically!)</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassbio_1_1alphabet_1_1dna4_html"><div class="ttname"><a href="classbio_1_1alphabet_1_1dna4.html">bio::alphabet::dna4</a></div><div class="ttdoc">The four letter DNA alphabet of A,C,G,T..</div><div class="ttdef"><b>Definition:</b> dna4.hpp:49</div></div>
<div class="ttc" id="acout_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a></div></div>
<div class="ttc" id="afmt_8hpp_html"><div class="ttname"><a href="fmt_8hpp.html">fmt.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
<div class="ttc" id="agroup__alphabet_html_ga064e386f9360cca0fd3702b4957a27a0"><div class="ttname"><a href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a></div><div class="ttdeci">constexpr auto to_char</div><div class="ttdoc">Return the char representation of an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:192</div></div>
<div class="ttc" id="agroup__alphabet_html_ga0c2eb25dabf59ccf9992b2661083ea5b"><div class="ttname"><a href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">bio::alphabet::assign_char_to</a></div><div class="ttdeci">constexpr auto assign_char_to</div><div class="ttdoc">Assign a char to an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:260</div></div>
<div class="ttc" id="agroup__alphabet_html_ga2a48a5c1883184e362f09e32ac33241e"><div class="ttname"><a href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a></div><div class="ttdeci">constexpr auto to_rank</div><div class="ttdoc">Return the rank representation of a (semi-)alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:70</div></div>
<div class="ttc" id="agroup__alphabet_html_gab718eab4e0f0e1b44f78b7600dee5e4d"><div class="ttname"><a href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">bio::alphabet::assign_rank_to</a></div><div class="ttdeci">constexpr auto assign_rank_to</div><div class="ttdoc">Assign a rank to an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:138</div></div>
<div class="ttc" id="aiostream_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/header/iostream.html">iostream</a></div></div>
</div><!-- fragment --><p>To reduce the burden of calling <code>assign_char</code> often, most alphabets in BioC++ provide custom literals for the alphabet and sequences over the alphabet:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna4.html">bio::alphabet::dna4</a>        my_letter = <span class="charliteral">&#39;A&#39;</span>_dna4;           <span class="comment">// identical to assign_char_to(&#39;A&#39;, my_letter);</span></div>
<div class="line">    <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;bio::alphabet::dna4&gt;</a> my_seq    = <span class="stringliteral">&quot;ACGT&quot;</span>_dna4;        <span class="comment">// identical to calling assign_char for each element</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacebio_1_1alphabet_1_1literals_html"><div class="ttname"><a href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a></div><div class="ttdoc">An inline namespace for alphabet literals. It exists to safely allow using namespace.</div><div class="ttdef"><b>Definition:</b> aa10li.hpp:183</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><p>Note, however, that literals <b>are not</b> required by the concept.</p>
<h3>Different concepts</h3>
<p>All types that have valid implementations of the functions/functors described above model the concept <a class="el" href="conceptbio_1_1alphabet_1_1writable__alphabet.html" title="Refines bio::alphabet::alphabet and adds assignability.">bio::alphabet::writable_alphabet</a>. This is the strongest (i.e. most refined) <em>general case</em> concept. There are more refined concepts for specific biological applications (like <a class="el" href="conceptbio_1_1alphabet_1_1nucleotide.html" title="A concept that indicates whether an alphabet represents nucleotides.">bio::alphabet::nucleotide</a>), and there are less refined concepts that only model part of an alphabet:</p>
<ul>
<li><a class="el" href="conceptbio_1_1alphabet_1_1semialphabet.html" title="The basis for bio::alphabet::alphabet, but requires only rank interface (not char).">bio::alphabet::semialphabet</a> and derived concepts only require the rank interface;</li>
<li><a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> (without <code>writable*</code>) and derived concepts only require readability and not assignability.</li>
</ul>
<p>Typically you will use <a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> in "read-only" situations (e.g. <code>const</code> parameters) and <a class="el" href="conceptbio_1_1alphabet_1_1writable__alphabet.html" title="Refines bio::alphabet::alphabet and adds assignability.">bio::alphabet::writable_alphabet</a> whenever the values might be changed. Semi-alphabets are less useful in application code.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter"><a class="el" href="">semialphabet </a>   </th><th class="markdownTableHeadCenter"><a class="el" href="">writable_semialphabet </a>   </th><th class="markdownTableHeadCenter"><a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html">alphabet </a>   </th><th class="markdownTableHeadCenter"><a class="el" href="">writable_alphabet </a>)   </th><th class="markdownTableHeadCenter">Aux    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet::size</a>   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e" title="Return the rank representation of a (semi-)alphabet object.">bio::alphabet::to_rank()</a>   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#gaa96971d545b8ab7260d1023b83acb63a" title="The rank_type of the semi-alphabet; defined as the return type of bio::alphabet::to_rank.">bio::alphabet::rank_t</a>   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">🔗    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d" title="Assign a rank to an alphabet object.">bio::alphabet::assign_rank_to()</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0" title="Return the char representation of an alphabet object.">bio::alphabet::to_char()</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#gaa16ddb3f7d394f68af7f530aeb24e5cf" title="The char_type of the alphabet; defined as the return type of bio::alphabet::to_char.">bio::alphabet::char_t</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">🔗    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b" title="Assign a char to an alphabet object.">bio::alphabet::assign_char_to()</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce" title="Returns whether a character is in the valid set of a bio::alphabet::alphabet (usually implies a bijec...">bio::alphabet::char_is_valid_for()</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#gadec8dc2856700f9763590213b6cae625" title="Assign a character to an alphabet object, throw if the character is not valid.">bio::alphabet::assign_char_strictly_to()</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">🔗   </td></tr>
</table>
<p>The above table shows all alphabet concepts and related functions and type traits. The entities marked as "auxiliary" provide shortcuts to the other "essential" entities. This difference is only relevant if you want to create your own alphabet (you do not need to provide an implementation for the "auxiliary" entities, they are provided automatically).</p>
<h3>Members VS free/global functions</h3>
<p>The alphabet concept (as most concepts in BioC++) looks for free/global functions, i.e. you need to be able to call <code><a class="el" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e" title="Return the rank representation of a (semi-)alphabet object.">bio::alphabet::to_rank(my_letter)</a></code>, however <em>most</em> alphabets also provide a member function, i.e. <code>my_letter.to_rank()</code>. The same is true for the type trait <a class="el" href="group__alphabet.html#ga299ddd5bf7e8221cb9d283f8a8d24f8d" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet::size</a> vs the static data member <code>alphabet_size</code>.</p>
<p>Members are provided for convenience and if you are an application developer who works with a single concrete alphabet type you are fine with using the member functions. If you, however, implement a generic function that accepts different alphabet types, you need to use the free function / type trait interface, because it is the only interface guaranteed to exist (member functions are <b>not</b> required/enforced by the concept).</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Containers over alphabets</h1>
<p>In BioC++ it is recommended you use the STL container classes like <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> for storing sequence data, but you can use other class templates if they satisfy the respective bio::ranges::detail::container, e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/deque.html">std::deque</a></code> or <a href="https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md" target="_blank"><code>folly::fbvector</code></a> or even <a href="https://doc.qt.io/qt-5/qvector.html" target="_blank"><code>Qt::QVector</code></a>.</p>
<p><code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::basic_string</a></code> is also supported, however, we recommend against using it, because it is not safe (and not useful) to call certain members like <code>.c_str()</code> if our alphabets are used as value type.</p>
<p>We provide specialised containers with certain properties in the <a class="el" href="group__range.html">Ranges</a> module.</p>
<p>A container over an <a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> automatically models the bio::alphabet::sequence concept. </p>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gadec8dc2856700f9763590213b6cae625" name="gadec8dc2856700f9763590213b6cae625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadec8dc2856700f9763590213b6cae625">&#9670;&#160;</a></span>assign_char_strictly_to</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::alphabet::assign_char_strictly_to</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a character to an alphabet object, throw if the character is not valid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alph_type</td><td>Type of the target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>The character being assigned; must be of the <a class="el" href="group__alphabet.html#gaa16ddb3f7d394f68af7f530aeb24e5cf" title="The char_type of the alphabet; defined as the return type of bio::alphabet::to_char.">bio::alphabet::char_t</a> of the target object. </td></tr>
    <tr><td class="paramname">alph</td><td>The target object; its type must model <a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>alph</code> if <code>alph</code> was given as lvalue, otherwise a copy. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structbio_1_1alphabet_1_1invalid__char__assignment.html" title="An exception typically thrown by bio::alphabet::assign_char_strict.">bio::alphabet::invalid_char_assignment</a></td><td>If <code><a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce" title="Returns whether a character is in the valid set of a bio::alphabet::alphabet (usually implies a bijec...">bio::alphabet::char_is_valid_for</a>&lt;decltype(alph)&gt;(chr) == false</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a function object. Invoke it with the parameters specified above.</p>
<p>Note that this is not a customisation point and it cannot be "overloaded". It simply invokes <a class="el" href="group__alphabet.html#ga64c00e15570d3e7394f425c810e617ce" title="Returns whether a character is in the valid set of a bio::alphabet::alphabet (usually implies a bijec...">bio::alphabet::char_is_valid_for</a> and <a class="el" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b" title="Assign a char to an alphabet object.">bio::alphabet::assign_char_to</a>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/custom/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> c = <span class="charliteral">&#39;!&#39;</span>;</div>
<div class="line">    <a class="code hl_variable" href="group__alphabet.html#gadec8dc2856700f9763590213b6cae625">bio::alphabet::assign_char_strictly_to</a>(<span class="charliteral">&#39;?&#39;</span>, c);     <span class="comment">// calls bio::alphabet::custom::tag_invoke(bio::alphabet::custom::assign_char_strictly_to, &#39;A&#39;, c)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a> d{};</div>
<div class="line">    <a class="code hl_variable" href="group__alphabet.html#gadec8dc2856700f9763590213b6cae625">bio::alphabet::assign_char_strictly_to</a>(<span class="charliteral">&#39;A&#39;</span>, d);     <span class="comment">// calls .assign_char(&#39;A&#39;) member</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// also works for temporaries:</span></div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a> d2 = <a class="code hl_variable" href="group__alphabet.html#gadec8dc2856700f9763590213b6cae625">bio::alphabet::assign_char_strictly_to</a>(<span class="charliteral">&#39;A&#39;</span>, <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a>{});</div>
<div class="line">}</div>
<div class="ttc" id="aalphabet_2concept_8hpp_html"><div class="ttname"><a href="alphabet_2concept_8hpp.html">concept.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
<div class="ttc" id="achar_8hpp_html"><div class="ttname"><a href="char_8hpp.html">char.hpp</a></div><div class="ttdoc">Provides alphabet adaptations for standard char types.</div></div>
<div class="ttc" id="aclassbio_1_1alphabet_1_1dna5_html"><div class="ttname"><a href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a></div><div class="ttdoc">The five letter DNA alphabet of A,C,G,T and the unknown character N..</div><div class="ttdef"><b>Definition:</b> dna5.hpp:50</div></div>
<div class="ttc" id="adna5_8hpp_html"><div class="ttname"><a href="dna5_8hpp.html">dna5.hpp</a></div><div class="ttdoc">Provides bio::alphabet::dna5, container aliases and string literals.</div></div>
<div class="ttc" id="agroup__alphabet_html_gadec8dc2856700f9763590213b6cae625"><div class="ttname"><a href="group__alphabet.html#gadec8dc2856700f9763590213b6cae625">bio::alphabet::assign_char_strictly_to</a></div><div class="ttdeci">constexpr auto assign_char_strictly_to</div><div class="ttdoc">Assign a character to an alphabet object, throw if the character is not valid.</div><div class="ttdef"><b>Definition:</b> concept.hpp:461</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga0c2eb25dabf59ccf9992b2661083ea5b" name="ga0c2eb25dabf59ccf9992b2661083ea5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c2eb25dabf59ccf9992b2661083ea5b">&#9670;&#160;</a></span>assign_char_to</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::alphabet::assign_char_to</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a char to an alphabet object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alph_type</td><td>Type of the target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>The char being assigned; must be of the <a class="el" href="group__alphabet.html#gaa16ddb3f7d394f68af7f530aeb24e5cf" title="The char_type of the alphabet; defined as the return type of bio::alphabet::to_char.">bio::alphabet::char_t</a> of the target object. </td></tr>
    <tr><td class="paramname">alph</td><td>The target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>alph</code> if <code>alph</code> was given as lvalue, otherwise a copy.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It is defined for all (semi-)alphabets in BioC++.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/custom/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> c = <span class="charliteral">&#39;!&#39;</span>;</div>
<div class="line">    <a class="code hl_variable" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">bio::alphabet::assign_char_to</a>(<span class="charliteral">&#39;?&#39;</span>, c);     <span class="comment">// calls bio::alphabet::custom::tag_invoke(bio::alphabet::custom::assign_char_to, &#39;A&#39;, c)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a> d{};</div>
<div class="line">    <a class="code hl_variable" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">bio::alphabet::assign_char_to</a>(<span class="charliteral">&#39;A&#39;</span>, d);     <span class="comment">// calls .assign_char(&#39;A&#39;) member</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// also works for temporaries:</span></div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a> d2 = <a class="code hl_variable" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">bio::alphabet::assign_char_to</a>(<span class="charliteral">&#39;A&#39;</span>, <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a>{});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// invalid/unknown characters are converted:</span></div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a> d3 = <a class="code hl_variable" href="group__alphabet.html#ga0c2eb25dabf59ccf9992b2661083ea5b">bio::alphabet::assign_char_to</a>(<span class="charliteral">&#39;!&#39;</span>, <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a>{}); <span class="comment">// == &#39;N&#39;_dna5</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). <b>If you don't want to create your own alphabet, everything below is irrelevant to you!</b></p>
<p>This object acts as a wrapper and looks for an implementation with the following signature:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> alph_type &amp; tag_invoke(<a class="code hl_struct" href="structbio_1_1alphabet_1_1custom_1_1assign__char__to.html">bio::alphabet::custom::assign_char_to</a>, char_type <span class="keyword">const</span> <span class="keywordtype">char</span>, alph_type &amp; alph) <span class="keyword">noexcept</span></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1custom_1_1assign__char__to_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1custom_1_1assign__char__to.html">bio::alphabet::custom::assign_char_to</a></div><div class="ttdoc">Customisation tag for bio::alphabet::assign_char_to.</div><div class="ttdef"><b>Definition:</b> tag.hpp:37</div></div>
</div><!-- fragment --><p>Functions are found via ADL and considered only if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type is exactly <code>alph_type &amp;</code>.</p>
<p>To specify the behaviour for your own alphabet type, simply provide the above function as a <code>friend</code> or free function.</p>
<p><em>Note</em> that temporaries of <code>alph_type</code> are handled by this function object and <b>do not</b> require an additional overload. </p>

</div>
</div>
<a id="gab718eab4e0f0e1b44f78b7600dee5e4d" name="gab718eab4e0f0e1b44f78b7600dee5e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab718eab4e0f0e1b44f78b7600dee5e4d">&#9670;&#160;</a></span>assign_rank_to</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::alphabet::assign_rank_to</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a rank to an alphabet object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alph_type</td><td>Type of the target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>The rank being assigned; must be of the <a class="el" href="group__alphabet.html#gaa96971d545b8ab7260d1023b83acb63a" title="The rank_type of the semi-alphabet; defined as the return type of bio::alphabet::to_rank.">bio::alphabet::rank_t</a> of the target object. </td></tr>
    <tr><td class="paramname">alph</td><td>The target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>alph</code> if <code>alph</code> was given as lvalue, otherwise a copy.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It is defined for all (semi-)alphabets in BioC++.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/custom/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> c = <span class="charliteral">&#39;!&#39;</span>;</div>
<div class="line">    <a class="code hl_variable" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">bio::alphabet::assign_rank_to</a>(66, c);     <span class="comment">// calls bio::alphabet::custom::tag_invoke(bio::alphabet::custom::assign_rank_to, 66, c); == &#39;B&#39;</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a> d{};</div>
<div class="line">    <a class="code hl_variable" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">bio::alphabet::assign_rank_to</a>(2, d);     <span class="comment">// calls .assign_rank(2) member; == &#39;G&#39;_dna5</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// also works for temporaries:</span></div>
<div class="line">    <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a> d2 = <a class="code hl_variable" href="group__alphabet.html#gab718eab4e0f0e1b44f78b7600dee5e4d">bio::alphabet::assign_rank_to</a>(2, <a class="code hl_class" href="classbio_1_1alphabet_1_1dna5.html">bio::alphabet::dna5</a>{});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// too-large ranks are undefined behaviour:</span></div>
<div class="line">    <span class="comment">// bio::alphabet::dna5 d3 = bio::alphabet::assign_rank_to(50, bio::alphabet::dna5{});</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). <b>If you don't want to create your own alphabet, everything below is irrelevant to you!</b></p>
<p>This object acts as a wrapper and looks for an implementation with the following signature:</p>
<div class="fragment"><div class="line">cosntexpr alph_type &amp; tag_invoke(<a class="code hl_struct" href="structbio_1_1alphabet_1_1custom_1_1assign__rank__to.html">bio::alphabet::custom::assign_rank_to</a>, rank_type <span class="keyword">const</span> rank, alph_type &amp; alph) <span class="keyword">noexcept</span></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1custom_1_1assign__rank__to_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1custom_1_1assign__rank__to.html">bio::alphabet::custom::assign_rank_to</a></div><div class="ttdoc">Customisation tag for bio::alphabet::assign_rank_to.#.</div><div class="ttdef"><b>Definition:</b> tag.hpp:29</div></div>
</div><!-- fragment --><p>Implementations are found via ADL and considered only if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type is exactly <code>alph_type &amp;</code>.</p>
<p>To specify the behaviour for your own alphabet type, simply provide the above function as a <code>friend</code> or free function.</p>
<p><em>Note</em> that temporaries of <code>alph_type</code> are handled by this function object and <b>do not</b> require an additional overload. </p>

</div>
</div>
<a id="ga64c00e15570d3e7394f425c810e617ce" name="ga64c00e15570d3e7394f425c810e617ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c00e15570d3e7394f425c810e617ce">&#9670;&#160;</a></span>char_is_valid_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename alph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::alphabet::char_is_valid_for</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a character is in the valid set of a <a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a> (usually implies a bijective mapping to an alphabet value). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alph_type</td><td>The alphabet type being queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>The character being checked; must be convertible to <code><a class="el" href="group__alphabet.html#gaa16ddb3f7d394f68af7f530aeb24e5cf" title="The char_type of the alphabet; defined as the return type of bio::alphabet::to_char.">bio::alphabet::char_t</a>&lt;alph_type&gt;</code>. </td></tr>
    <tr><td class="paramname">alph</td><td>The target object; its type must model <a class="el" href="conceptbio_1_1alphabet_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet::alphabet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> or <code>false</code>.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It is defined for all (semi-)alphabets in BioC++.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/custom/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> b = bio::alphabet::char_is_valid_for&lt;char&gt;(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line">    <span class="comment">// calls bio::alphabet::custom::tag_invoke(bio::alphabet::custom::char_is_valid_for, &#39;A&#39;, char{}); always true</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> c = bio::alphabet::char_is_valid_for&lt;bio::alphabet::dna5&gt;(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line">    <span class="comment">// calls dna5::char_is_valid(&#39;A&#39;) member; == true</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// for some alphabets, characters that are not uniquely mappable are still valid:</span></div>
<div class="line">    <span class="keywordtype">bool</span> d = bio::alphabet::char_is_valid_for&lt;bio::alphabet::dna5&gt;(<span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line">    <span class="comment">// lower case also true</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Default Behaviour</h3>
<p>In contrast to the other alphabet related customisation points, it is <b>optional</b> to provide an implementation of this one for most¹ alphabets, because a default implementation exists.</p>
<p>The default behaviour is that all characters that are "preserved" when assigning to an object are valid, i.e. <code>to_char(assign_char_to(chr, alph_t{})) == chr</code>.</p>
<p>This means that e.g. assigning 'A' to <a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a> would be valid, but 'a' would not be, because <a class="el" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0" title="Return the char representation of an alphabet object.">bio::alphabet::to_char()</a> always produces upper-case for <a class="el" href="classbio_1_1alphabet_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T..">bio::alphabet::dna4</a>. For this reason, many alphabets have a specialised validity-check that also accepts defines lower-case letters as valid.</p>
<p>¹ All alphabets where the type is <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a>.</p>
<h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). <b>If you don't want to create your own alphabet, everything below is irrelevant to you!</b></p>
<p>This object acts as a wrapper and looks for an implementation with the following signature:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> tag_invoke(<a class="code hl_struct" href="structbio_1_1alphabet_1_1custom_1_1char__is__valid__for.html">bio::alphabet::custom::char_is_valid_for</a>, char_type <span class="keyword">const</span> <span class="keywordtype">char</span>, alph_type) <span class="keyword">noexcept</span></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1custom_1_1char__is__valid__for_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1custom_1_1char__is__valid__for.html">bio::alphabet::custom::char_is_valid_for</a></div><div class="ttdoc">Customisation tag for bio::alphabet::assign_char_to.</div><div class="ttdef"><b>Definition:</b> tag.hpp:41</div></div>
</div><!-- fragment --><p>If no implementation is found, it behaves as specified above.</p>
<p>Implementations are found via ADL and considered only if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type is exactly <code>bool</code>.</p>
<p>To specify the behaviour for your own alphabet type, simply provide the above function as a <code>friend</code> or free function.</p>
<p><em>Note</em> that the value of the alph_type argument is irrelevant, only the type is needed.</p>
<p><em>Note</em> that if the alphabet type with cvref removed is not <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a>, this function object will instead look for:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> tag_invoke(<a class="code hl_struct" href="structbio_1_1alphabet_1_1custom_1_1char__is__valid__for.html">bio::alphabet::custom::char_is_valid_for</a>, char_type <span class="keyword">const</span> <span class="keywordtype">char</span>, <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity&lt;alph_type&gt;</a>) <span class="keyword">noexcept</span></div>
<div class="ttc" id="atype_identity_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a></div></div>
</div><!-- fragment --><p>i.e. the type will be wrapped in <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a> so it can still be passed as a tag. In that case the <em>default behaviour</em> defined above <b>does not work</b>, and you are required to provide such an implementation. </p>

</div>
</div>
<a id="ga299ddd5bf7e8221cb9d283f8a8d24f8d" name="ga299ddd5bf7e8221cb9d283f8a8d24f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga299ddd5bf7e8221cb9d283f8a8d24f8d">&#9670;&#160;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename alph_t , typename wrap_t  = meta::default_initialisable_wrap_t&lt;alph_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::alphabet::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A type trait that holds the size of a (semi-)alphabet. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alph_type</td><td>The (semi-)alphabet type being queried.</td></tr>
  </table>
  </dd>
</dl>
<p>This is variable template. Instantiate it with an alphabet type.</p>
<p>It is defined for all (semi-)alphabets in BioC++.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/custom/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// calls bio::alphabet::custom::tag_invoke(bio::alphabet::custom::size, char{}); r2 == 256</span></div>
<div class="line">    <span class="keyword">auto</span> r2 = bio::alphabet::size&lt;char&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calls bio::alphabet::base&#39;s friend tag_invoke() which returns dna5::alphabet_size == 5</span></div>
<div class="line">    <span class="keyword">auto</span> r3 = bio::alphabet::size&lt;bio::alphabet::dna5&gt;;</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). <b>If you don't want to create your own alphabet, everything below is irrelevant to you!</b></p>
<p>This object acts as a wrapper and looks for an implementation with the following signature:</p>
<div class="fragment"><div class="line"><span class="keyword">consteval</span> <span class="keywordtype">size_t</span> tag_invoke(<a class="code hl_struct" href="structbio_1_1alphabet_1_1custom_1_1size.html">bio::alphabet::custom::size</a>, alph_type) <span class="keyword">noexcept</span></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1custom_1_1size_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1custom_1_1size.html">bio::alphabet::custom::size</a></div><div class="ttdoc">CPO tag definition for bio::alphabet::size.</div><div class="ttdef"><b>Definition:</b> tag.hpp:45</div></div>
</div><!-- fragment --><p>Implementations are found via ADL and considered only if they are marked <code>noexcept</code>, if they return a std::integral type and if they can be evaluated at compile-time (<code>consteval</code> is recommended, but<code>constexpr</code> is possible, too).</p>
<p>To specify the behaviour for your own alphabet type, simply provide the above function as a <code>friend</code> or free function.</p>
<p><em>Note</em> that if the alphabet type with cvref removed is not <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a> <b>at compile-time</b>, this function object will instead look for:</p>
<div class="fragment"><div class="line"><span class="keyword">consteval</span> <span class="keywordtype">size_t</span> tag_invoke(<a class="code hl_struct" href="structbio_1_1alphabet_1_1custom_1_1size.html">bio::alphabet::custom::size</a>, <a class="code hl_classRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity&lt;alph_type&gt;</a>) <span class="keyword">noexcept</span></div>
</div><!-- fragment --><p>i.e. the type will be wrapped in <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a> so it can still be passed as a tag. </p>

</div>
</div>
<a id="ga064e386f9360cca0fd3702b4957a27a0" name="ga064e386f9360cca0fd3702b4957a27a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga064e386f9360cca0fd3702b4957a27a0">&#9670;&#160;</a></span>to_char</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::alphabet::to_char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the char representation of an alphabet object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alph_type</td><td>Type of the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alph</td><td>The alphabet object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The char representation.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It is defined for all alphabets in BioC++.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/custom/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> r2 = <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(<span class="charliteral">&#39;A&#39;</span>);         <span class="comment">// calls bio::alphabet::custom::tag_invoke(bio::alphabet::custom::to_char, &#39;A&#39;); r2 == &#39;A&#39;</span></div>
<div class="line">    <span class="keyword">auto</span> r3 = <a class="code hl_variable" href="group__alphabet.html#ga064e386f9360cca0fd3702b4957a27a0">bio::alphabet::to_char</a>(<span class="charliteral">&#39;A&#39;</span>_dna5);    <span class="comment">// calls .to_char() member; r3 == &#39;A&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). <b>If you don't want to create your own alphabet, everything below is irrelevant to you!</b></p>
<p>This object acts as a wrapper and looks for an implementation with the following signature:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> char_type tag_invoke(<a class="code hl_struct" href="structbio_1_1alphabet_1_1custom_1_1to__char.html">bio::alphabet::custom::to_char</a>, alph_type <span class="keyword">const</span> alph) <span class="keyword">noexcept</span></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1custom_1_1to__char_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1custom_1_1to__char.html">bio::alphabet::custom::to_char</a></div><div class="ttdoc">Customisation tag for bio::alphabet::to_char.</div><div class="ttdef"><b>Definition:</b> tag.hpp:33</div></div>
</div><!-- fragment --><p>Implementations are found via ADL and considered only if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type models <a class="el" href="conceptbio_1_1meta_1_1builtin__character.html" title="This concept encompasses exactly the types char, signed char, unsigned char, wchar_t,...">bio::meta::builtin_character</a>.</p>
<p>To specify the behaviour for your own alphabet type, simply provide the above function as a <code>friend</code> or free function. </p>

</div>
</div>
<a id="ga2a48a5c1883184e362f09e32ac33241e" name="ga2a48a5c1883184e362f09e32ac33241e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a48a5c1883184e362f09e32ac33241e">&#9670;&#160;</a></span>to_rank</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::alphabet::to_rank</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the rank representation of a (semi-)alphabet object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alph_type</td><td>Type of the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alph</td><td>The (semi-)alphabet object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank representation; an integral type.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It is defined for all (semi-)alphabets in BioC++.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/custom/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacebio_1_1alphabet_1_1literals.html">bio::alphabet::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> r2 = <a class="code hl_variable" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a>(<span class="charliteral">&#39;A&#39;</span>);         <span class="comment">// calls bio::alphabet::custom::tag_invoke(bio::alphabet::custom::to_rank, &#39;A&#39;); r2 == 65</span></div>
<div class="line">    <span class="keyword">auto</span> r3 = <a class="code hl_variable" href="group__alphabet.html#ga2a48a5c1883184e362f09e32ac33241e">bio::alphabet::to_rank</a>(<span class="charliteral">&#39;A&#39;</span>_dna5);    <span class="comment">// calls .to_char() member; r3 == 0</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). <b>If you don't want to create your own alphabet, everything below is irrelevant to you!</b></p>
<p>This object acts as a wrapper and looks for an implementation with the following signature:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> rank_type tag_invoke(<a class="code hl_struct" href="structbio_1_1alphabet_1_1custom_1_1to__rank.html">bio::alphabet::custom::to_rank</a>, alph_type <span class="keyword">const</span> alph) <span class="keyword">noexcept</span></div>
<div class="ttc" id="astructbio_1_1alphabet_1_1custom_1_1to__rank_html"><div class="ttname"><a href="structbio_1_1alphabet_1_1custom_1_1to__rank.html">bio::alphabet::custom::to_rank</a></div><div class="ttdoc">Customisation tag for bio::alphabet::to_rank.</div><div class="ttdef"><b>Definition:</b> tag.hpp:25</div></div>
</div><!-- fragment --><p>Implementations are found via ADL and considered only if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type models std::integral.</p>
<p>To specify the behaviour for your own alphabet type, simply provide the above function as a <code>friend</code> or free function. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Thu Mar 30 2023 15:25:52 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
