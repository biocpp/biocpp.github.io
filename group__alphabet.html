<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BioC++: Alphabet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="biocpp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="biocpp_logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BioC++
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">The Modern C++ libraries for Bioinformatics.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__alphabet.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Alphabet</div>  </div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Alphabet:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__alphabet.svg" width="232" height="431"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__adaptation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adaptation.html">Adaptation</a></td></tr>
<tr class="memdesc:group__adaptation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides alphabet adaptions of some standard char and uint types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__aminoacid"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aminoacid.html">Aminoacid</a></td></tr>
<tr class="memdesc:group__aminoacid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the amino acid alphabets and functionality for translation from nucleotide. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cigar"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cigar.html">CIGAR</a></td></tr>
<tr class="memdesc:group__cigar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides (semi-)alphabets for representing elements in CIGAR strings. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__alphabet__composite"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet__composite.html">Composite</a></td></tr>
<tr class="memdesc:group__alphabet__composite"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides templates for combining existing alphabets into new alphabet types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__gap"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gap.html">Gap</a></td></tr>
<tr class="memdesc:group__gap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the gap alphabet and functionality to make an alphabet a gapped alphabet. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mask"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mask.html">Mask</a></td></tr>
<tr class="memdesc:group__mask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the mask alphabet and functionality for creating masked composites. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__nucleotide"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nucleotide.html">Nucleotide</a></td></tr>
<tr class="memdesc:group__nucleotide"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the different DNA and RNA alphabet types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__quality"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__quality.html">Quality</a></td></tr>
<tr class="memdesc:group__quality"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the various quality score types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__structure"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__structure.html">Structure</a></td></tr>
<tr class="memdesc:group__structure"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides types to represent single elements of RNA and protein structures. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1custom_1_1alphabet.html">bio::custom::alphabet&lt; t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that can be specialised to provide customisation point implementations so that third party types model alphabet concepts.  <a href="structbio_1_1custom_1_1alphabet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacebio_1_1alphabet.html">alphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic alphabet concept that covers most data types used in ranges.  <a href="interfacebio_1_1alphabet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1alphabet__base.html">bio::alphabet_base&lt; derived_type, size, char_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP-base that makes defining a custom alphabet easier.  <a href="classbio_1_1alphabet__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1alphabet__base_3_01derived__type_00_011ul_00_01char__t_01_4.html">bio::alphabet_base&lt; derived_type, 1ul, char_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="classbio_1_1alphabet__base.html" title="A CRTP-base that makes defining a custom alphabet easier.">bio::alphabet_base</a> for alphabets of size 1.  <a href="classbio_1_1alphabet__base_3_01derived__type_00_011ul_00_01char__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1alphabet__proxy.html">bio::alphabet_proxy&lt; derived_type, alphabet_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP-base that eases the definition of proxy types returned in place of regular alphabets.  <a href="classbio_1_1alphabet__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01alphabet__t_01_4.html">std::hash&lt; alphabet_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for hashing a character.  <a href="structstd_1_1hash_3_01alphabet__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01urng__t_01_4.html">std::hash&lt; urng_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for hashing a range of characters.  <a href="structstd_1_1hash_3_01urng__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacebio_1_1semialphabet.html">semialphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basis for <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>, but requires only rank interface (not char).  <a href="interfacebio_1_1semialphabet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacebio_1_1writable__alphabet.html">writable_alphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> and adds assignability.  <a href="interfacebio_1_1writable__alphabet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacebio_1_1writable__semialphabet.html">writable_semialphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A refinement of <a class="el" href="interfacebio_1_1semialphabet.html" title="The basis for bio::alphabet, but requires only rank interface (not char).">bio::semialphabet</a> that adds assignability.  <a href="interfacebio_1_1writable__semialphabet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga474c9ea1cc2c81b65e22ee09c746fc17"><td class="memTemplParams" colspan="2"><a id="ga474c9ea1cc2c81b65e22ee09c746fc17"></a>
template&lt;typename alphabet_type &gt; </td></tr>
<tr class="memitem:ga474c9ea1cc2c81b65e22ee09c746fc17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga474c9ea1cc2c81b65e22ee09c746fc17">bio::alphabet_char_t</a> = decltype(<a class="el" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(std::declval&lt; alphabet_type const  &gt;()))</td></tr>
<tr class="memdesc:ga474c9ea1cc2c81b65e22ee09c746fc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>char_type</code> of the alphabet; defined as the return type of <a class="el" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8" title="Return the char representation of an alphabet object.">bio::to_char</a>. <br /></td></tr>
<tr class="separator:ga474c9ea1cc2c81b65e22ee09c746fc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d7465944e58981cc10298677b82fec"><td class="memTemplParams" colspan="2"><a id="ga80d7465944e58981cc10298677b82fec"></a>
template&lt;typename semi_alphabet_type &gt; </td></tr>
<tr class="memitem:ga80d7465944e58981cc10298677b82fec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga80d7465944e58981cc10298677b82fec">bio::alphabet_rank_t</a> = decltype(<a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a>(std::declval&lt; semi_alphabet_type &gt;()))</td></tr>
<tr class="memdesc:ga80d7465944e58981cc10298677b82fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>rank_type</code> of the semi-alphabet; defined as the return type of <a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0" title="Return the rank representation of a (semi-)alphabet object.">bio::to_rank</a>. <br /></td></tr>
<tr class="separator:ga80d7465944e58981cc10298677b82fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gabd77e4c1f2d28c1af7a223605bbb7c82"><td class="memTemplParams" colspan="2">template&lt;typename alph_t &gt; </td></tr>
<tr class="memitem:gabd77e4c1f2d28c1af7a223605bbb7c82"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">bio::alphabet_size</a> = detail::adl_only::alphabet_size_obj&lt;alph_t&gt;()</td></tr>
<tr class="memdesc:gabd77e4c1f2d28c1af7a223605bbb7c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that holds the size of a (semi-)alphabet.  <a href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">More...</a><br /></td></tr>
<tr class="separator:gabd77e4c1f2d28c1af7a223605bbb7c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Function objects</h2></td></tr>
<tr class="memitem:ga9189b35f800d7e5abad51e021ea811a0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a> = detail::adl_only::to_rank_fn{}</td></tr>
<tr class="memdesc:ga9189b35f800d7e5abad51e021ea811a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rank representation of a (semi-)alphabet object.  <a href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">More...</a><br /></td></tr>
<tr class="separator:ga9189b35f800d7e5abad51e021ea811a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae34fa2b37a8b40f2f2fa64fed7bbb410"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">bio::assign_rank_to</a> = detail::adl_only::assign_rank_to_fn{}</td></tr>
<tr class="memdesc:gae34fa2b37a8b40f2f2fa64fed7bbb410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a rank to an alphabet object.  <a href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">More...</a><br /></td></tr>
<tr class="separator:gae34fa2b37a8b40f2f2fa64fed7bbb410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab295f04aea840000aafc640b5e6528c8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a> = detail::adl_only::to_char_fn{}</td></tr>
<tr class="memdesc:gab295f04aea840000aafc640b5e6528c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the char representation of an alphabet object.  <a href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">More...</a><br /></td></tr>
<tr class="separator:gab295f04aea840000aafc640b5e6528c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05da42eb0b9a48f4d1a554c7d3a9044d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">bio::assign_char_to</a> = detail::adl_only::assign_char_to_fn{}</td></tr>
<tr class="memdesc:ga05da42eb0b9a48f4d1a554c7d3a9044d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a character to an alphabet object.  <a href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">More...</a><br /></td></tr>
<tr class="separator:ga05da42eb0b9a48f4d1a554c7d3a9044d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510b0657b8a3ae7d304999afd8fdcd52"><td class="memTemplParams" colspan="2">template&lt;typename alph_t &gt; </td></tr>
<tr class="memitem:ga510b0657b8a3ae7d304999afd8fdcd52"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52">bio::char_is_valid_for</a> = detail::adl_only::char_is_valid_for_fn&lt;alph_t&gt;{}</td></tr>
<tr class="memdesc:ga510b0657b8a3ae7d304999afd8fdcd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a character is in the valid set of a <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> (usually implies a bijective mapping to an alphabet value).  <a href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52">More...</a><br /></td></tr>
<tr class="separator:ga510b0657b8a3ae7d304999afd8fdcd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab055c8c702ef4b8b48b7d301c12b18b2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alphabet.html#gab055c8c702ef4b8b48b7d301c12b18b2">bio::assign_char_strictly_to</a> = detail::adl_only::assign_char_strictly_to_fn{}</td></tr>
<tr class="memdesc:gab055c8c702ef4b8b48b7d301c12b18b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a character to an alphabet object, throw if the character is not valid.  <a href="group__alphabet.html#gab055c8c702ef4b8b48b7d301c12b18b2">More...</a><br /></td></tr>
<tr class="separator:gab055c8c702ef4b8b48b7d301c12b18b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="autotoc_md0"></a>
Introduction</h1>
<p>Alphabets are a core component in BioC++. They enable us to represent the smallest unit of biological sequence data, e.g. a nucleotide or an amino acid.</p>
<p>In theory, these could just be represented as a <code>char</code> and this is how many people perceive them, but it makes sense to use a smaller, stricter and well-defined alphabet in almost all cases, because:</p>
<ul>
<li>Most of our sequences alphabets are actually smaller and can possibly be <b>represented by less bits</b> than a <code>char</code>, e.g. a <code>char</code> can have 256 values and thus must be represented by 8 bits of memory, but a DNA character <em>could</em> be represented by 2 bits, because it only has four values in the smallest representation ('A', 'C', 'G', 'T').</li>
<li>From a programmer's point of view it is very important to also access the <b>rank of a letter</b>, i.e. we need to be able to convert 'A', 'C', 'G', 'T' to <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> respectively. In fact the rank representation is used a lot more often than the visual representation which is only used in input/output.</li>
<li>You may want to prevent the user from selecting <b>letters that aren't part of that alphabet</b>, e.g. 'J' is not part of any nucleotide definition so people shouldn't be able to select 'J'. With a specialised alphabet you could instead convert those to a special "unknown"-character, e.g. you might want 'J' to be always converted to 'N'.</li>
</ul>
<p>In BioC++ there are alphabet types for typical sequence alphabets like DNA and amino acid, but also for qualities, RNA structures and alignment gaps. In addition there are templates for combining alphabet types into new alphabets, and wrappers for existing data types like the canonical <code>char</code>.</p>
<p>In addition to concrete alphabet types, BioC++ provides multiple <em>concepts</em> that describe groups of alphabets by their properties and can be used to <em>constrain</em> templates so that they only work with certain alphabet types. See the <a class="el" href="core_concepts.html">Tutorial on Concepts </a> for a gentle introduction to the topic.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
The alphabet concepts</h1>
<h3>alphabet size</h3>
<p>All alphabets in BioC++ have a fixed size. It can be queried via the <a class="el" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet_size</a> type trait and <em>optionally</em> also the <code>alphabet_size</code> static member of the alphabet (see below for "members VS free/global functions").</p>
<p>In some areas we provide alphabets types with different sizes for the same purpose, e.g. <a class="el" href="classbio_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T.">bio::dna4</a> ('A', 'C', 'G', 'T'), <a class="el" href="classbio_1_1dna5.html" title="The five letter DNA alphabet of A,C,G,T and the unknown character N.">bio::dna5</a> (plus 'N') and <a class="el" href="classbio_1_1dna15.html" title="The 15 letter DNA alphabet, containing all IUPAC smybols minus the gap.">bio::dna15</a> (plus ambiguous characters defined by IUPAC). By convention most of our alphabets carry their size in their name (<a class="el" href="classbio_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T.">bio::dna4</a> has size 4 a.s.o.).</p>
<p>A main reason for choosing a smaller alphabet over a bigger one is the possibility of <b>optimising for space efficiency</b>. Note, however, that a single letter by itself can never be smaller than a byte for architectural reasons. Actual space improvements are realised via secondary structures, e.g. when using a <code><a class="el" href="classbio_1_1bitcompressed__vector.html" title="A space-optimised version of std::vector that compresses multiple letters into a single byte.">bio::bitcompressed_vector</a>&lt;<a class="el" href="classbio_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T.">bio::dna4</a>&gt;</code> instead of <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="classbio_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T.">bio::dna4</a>&gt;</code>. Also the single letter quality composite <code><a class="el" href="classbio_1_1qualified.html" title="Joins an arbitrary alphabet with a quality alphabet.">bio::qualified</a>&lt;<a class="el" href="classbio_1_1dna4.html" title="The four letter DNA alphabet of A,C,G,T.">bio::dna4</a>, <a class="el" href="classbio_1_1phred42.html" title="Quality type for traditional Sanger and modern Illumina Phred scores (typical range).">bio::phred42</a>&gt;</code> fits into one byte, because the product of the alphabet sizes (4 * 42) is smaller than 256; whereas the same composite with <a class="el" href="classbio_1_1dna15.html" title="The 15 letter DNA alphabet, containing all IUPAC smybols minus the gap.">bio::dna15</a> requires two bytes per letter (15 * 42 &gt; 256).</p>
<h3>Assigning and retrieving values</h3>
<p>As mentioned above, we typically think of alphabets in their character representation, but we also require them in "rank representation" as programmers. In C and C++ it is quite difficult to cleanly differentiate between these, because the <code>char</code> type is considered an integral type and can be used to index an array (e.g. <code>my_array['A']</code> translates to <code>my_array[65]</code>). Moreover the sign of <code>char</code> is implementation defined and on many platforms the smallest integer types <code>int8_t</code> and <code>uint8_t</code> are literally the same types as <code>signed char</code> and <code>unsigned char</code> respectively.</p>
<p>This leads to ambiguity when assigning and retrieving values:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// does not work:</span></div>
<div class="line">    <span class="comment">// bio::dna4 my_letter{0};      // we want to set the default, an A</span></div>
<div class="line">    <span class="comment">// bio::dna4 my_letter{&#39;A&#39;};    // we also want to set an A, but we are setting value 65</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; my_letter;         // you expect &#39;A&#39;, but how would you access the number?</span></div>
<div class="line">}</div>
<div class="ttc" id="adna4_8hpp_html"><div class="ttname"><a href="dna4_8hpp.html">dna4.hpp</a></div><div class="ttdoc">Provides bio::dna4, container aliases and string literals.</div></div>
</div><!-- fragment --><p>To solve this problem, alphabets in BioC++ define two interfaces:</p>
<ol type="1">
<li>a <b>rank based interface</b> with<ul>
<li><a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0" title="Return the rank representation of a (semi-)alphabet object.">bio::to_rank</a> to produce the numerical representation;</li>
<li><a class="el" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410" title="Assign a rank to an alphabet object.">bio::assign_rank_to</a> to assign from the numerical representation;</li>
<li>the numerical representation is an unsigned integral type like <code>size_t</code>; the exact type can be retrieved via the <a class="el" href="group__alphabet.html#ga80d7465944e58981cc10298677b82fec" title="The rank_type of the semi-alphabet; defined as the return type of bio::to_rank.">bio::alphabet_rank_t</a>.</li>
</ul>
</li>
<li>a <b>character based interface</b> with<ul>
<li><a class="el" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8" title="Return the char representation of an alphabet object.">bio::to_char</a> to produce the visual representation;</li>
<li><a class="el" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d" title="Assign a character to an alphabet object.">bio::assign_char_to</a> to assign from the visual representation;</li>
<li><a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52" title="Returns whether a character is in the valid set of a bio::alphabet (usually implies a bijective mappi...">bio::char_is_valid_for</a> that checks whether a character value has a one-to-one mapping to an alphabet value;</li>
<li>the visual representation is a character type (almost always <code>char</code>, but could be <code>char16_t</code> or <code>char32_t</code>, as well); the exact type can be retrieved via <a class="el" href="group__alphabet.html#ga474c9ea1cc2c81b65e22ee09c746fc17" title="The char_type of the alphabet; defined as the return type of bio::to_char.">bio::alphabet_char_t</a>.</li>
</ul>
</li>
</ol>
<p>To prevent the aforementioned ambiguity, you can neither assign from rank or char representation via <code>operator=</code>, nor can you cast the alphabet to either of it's representation forms, <b>you need to explicitly use the interfaces</b>.</p>
<p>For efficiency, the representation saved internally is normally the rank representation, and the character representation is generated via conversion tables. This is, however, not required as long as both interfaces are provided and all functions operate in constant time.</p>
<p>The same applies for printing characters although we provide overloads for the {fmt}-library in <code>&lt;<a class="el" href="fmt_8hpp.html" title="Core alphabet concept and free function/type trait wrappers.">bio/alphabet/fmt.hpp</a>&gt;</code>.</p>
<p>Here is an example of explicit assignment of a rank and char, and how it can be printed via <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> and {fmt}: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fmt_8hpp.html">bio/alphabet/fmt.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classbio_1_1dna4.html">bio::dna4</a> my_letter;</div>
<div class="line">    <a class="code" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">bio::assign_rank_to</a>(0, my_letter);               <span class="comment">// assign an A via rank interface</span></div>
<div class="line">    <a class="code" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">bio::assign_char_to</a>(<span class="charliteral">&#39;A&#39;</span>, my_letter);             <span class="comment">// assign an A via char interface</span></div>
<div class="line"> </div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(my_letter);            <span class="comment">// prints &#39;A&#39;</span></div>
<div class="line">    <a class="codeRef" target="_blank" href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a> &lt;&lt; (unsigned)<a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a>(my_letter);  <span class="comment">// prints 0</span></div>
<div class="line">    <span class="comment">// we have to add the cast here, because uint8_t is also treated as a char type by default :(</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Using the format library:</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}&quot;</span>, <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(my_letter));      <span class="comment">// prints &#39;A&#39;</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}&quot;</span>, my_letter);                    <span class="comment">// prints &#39;A&#39; (calls to_char() automatically!)</span></div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}&quot;</span>, <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a>(my_letter));      <span class="comment">// prints 0   (casts uint8_t to unsigned automatically!)</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassbio_1_1dna4_html"><div class="ttname"><a href="classbio_1_1dna4.html">bio::dna4</a></div><div class="ttdoc">The four letter DNA alphabet of A,C,G,T.</div><div class="ttdef"><b>Definition:</b> dna4.hpp:49</div></div>
<div class="ttc" id="acout_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/io/cout.html">std::cout</a></div></div>
<div class="ttc" id="afmt_8hpp_html"><div class="ttname"><a href="fmt_8hpp.html">fmt.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
<div class="ttc" id="agroup__alphabet_html_ga05da42eb0b9a48f4d1a554c7d3a9044d"><div class="ttname"><a href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">bio::assign_char_to</a></div><div class="ttdeci">constexpr auto assign_char_to</div><div class="ttdoc">Assign a character to an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:418</div></div>
<div class="ttc" id="agroup__alphabet_html_ga9189b35f800d7e5abad51e021ea811a0"><div class="ttname"><a href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a></div><div class="ttdeci">constexpr auto to_rank</div><div class="ttdoc">Return the rank representation of a (semi-)alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:144</div></div>
<div class="ttc" id="agroup__alphabet_html_gab295f04aea840000aafc640b5e6528c8"><div class="ttname"><a href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a></div><div class="ttdeci">constexpr auto to_char</div><div class="ttdoc">Return the char representation of an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:322</div></div>
<div class="ttc" id="agroup__alphabet_html_gae34fa2b37a8b40f2f2fa64fed7bbb410"><div class="ttname"><a href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">bio::assign_rank_to</a></div><div class="ttdeci">constexpr auto assign_rank_to</div><div class="ttdoc">Assign a rank to an alphabet object.</div><div class="ttdef"><b>Definition:</b> concept.hpp:240</div></div>
</div><!-- fragment --><p>To reduce the burden of calling <code>assign_char</code> often, most alphabets in BioC++ provide custom literals for the alphabet and sequences over the alphabet:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna4_8hpp.html">bio/alphabet/nucleotide/dna4.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_dna4;</div>
<div class="line">    <a class="code" href="classbio_1_1dna4.html">bio::dna4</a>        my_letter = <span class="charliteral">&#39;A&#39;</span>_dna4;           <span class="comment">// identical to assign_char_to(&#39;A&#39;, my_letter);</span></div>
<div class="line">    bio::dna4_vector my_seq    = <span class="stringliteral">&quot;ACGT&quot;</span>_dna4;        <span class="comment">// identical to calling assign_char for each element</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note, however, that literals <b>are not</b> required by the concept.</p>
<h3>Different concepts</h3>
<p>All types that have valid implementations of the functions/functors described above model the concept <a class="el" href="interfacebio_1_1writable__alphabet.html" title="Refines bio::alphabet and adds assignability.">bio::writable_alphabet</a>. This is the strongest (i.e. most refined) <em>general case</em> concept. There are more refined concepts for specific biological applications (like <a class="el" href="interfacebio_1_1nucleotide__alphabet.html" title="A concept that indicates whether an alphabet represents nucleotides.">bio::nucleotide_alphabet</a>), and there are less refined concepts that only model part of an alphabet:</p>
<ul>
<li><a class="el" href="interfacebio_1_1semialphabet.html" title="The basis for bio::alphabet, but requires only rank interface (not char).">bio::semialphabet</a> and derived concepts only require the rank interface;</li>
<li><a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> (without <code>writable*</code>) and derived concepts only require readability and not assignability.</li>
</ul>
<p>Typically you will use <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> in "read-only" situations (e.g. <code>const</code> parameters) and <a class="el" href="interfacebio_1_1writable__alphabet.html" title="Refines bio::alphabet and adds assignability.">bio::writable_alphabet</a> whenever the values might be changed. Semi-alphabets are less useful in application code.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter"><a class="el" href="interfacebio_1_1semialphabet.html">semialphabet</a>   </th><th class="markdownTableHeadCenter"><a class="el" href="interfacebio_1_1writable__semialphabet.html">writable_semialphabet</a>   </th><th class="markdownTableHeadCenter"><a class="el" href="interfacebio_1_1alphabet.html">alphabet</a>   </th><th class="markdownTableHeadCenter"><a class="el" href="interfacebio_1_1writable__alphabet.html">writable_alphabet</a>   </th><th class="markdownTableHeadCenter">Aux    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82">alphabet_size</a>   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">to_rank</a>   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga80d7465944e58981cc10298677b82fec">alphabet_rank_t</a>   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">🔗    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">assign_rank_to</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">to_char</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga474c9ea1cc2c81b65e22ee09c746fc17">alphabet_char_t</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">🔗    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">assign_char_to</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52">char_is_valid_for</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="group__alphabet.html#gab055c8c702ef4b8b48b7d301c12b18b2">assign_char_strictly_to</a>   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">✅   </td><td class="markdownTableBodyCenter">🔗   </td></tr>
</table>
<p>The above table shows all alphabet concepts and related functions and type traits. The entities marked as "auxiliary" provide shortcuts to the other "essential" entities. This difference is only relevant if you want to create your own alphabet (you do not need to provide an implementation for the "auxiliary" entities, they are provided automatically).</p>
<h3>Members VS free/global functions</h3>
<p>The alphabet concept (as most concepts in BioC++) looks for free/global functions, i.e. you need to be able to call <code>bio::to_rank(my_letter)</code>, however <em>most</em> alphabets also provide a member function, i.e. <code><a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0" title="Return the rank representation of a (semi-)alphabet object.">my_letter.to_rank()</a></code>. The same is true for the type trait <a class="el" href="group__alphabet.html#gabd77e4c1f2d28c1af7a223605bbb7c82" title="A type trait that holds the size of a (semi-)alphabet.">bio::alphabet_size</a> vs the static data member <code>alphabet_size</code>.</p>
<p>Members are provided for convenience and if you are an application developer who works with a single concrete alphabet type you are fine with using the member functions. If you, however, implement a generic function that accepts different alphabet types, you need to use the free function / type trait interface, because it is the only interface guaranteed to exist (member functions are <b>not</b> required/enforced by the concept).</p>
<h1><a class="anchor" id="autotoc_md2"></a>
containers over alphabets</h1>
<p>In BioC++ it is recommended you use the STL container classes like <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> for storing sequence data, but you can use other class templates if they satisfy the respective <a class="el" href="interfacebio_1_1container.html" title="The (most general) container concept as defined by the standard library.">bio::container</a>, e.g. <code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/container/deque.html">std::deque</a></code> or <a href="https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md" target="_blank"><code>folly::fbvector</code></a> or even <a href="https://doc.qt.io/qt-5/qvector.html" target="_blank"><code>Qt::QVector</code></a>.</p>
<p><code><a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::basic_string</a></code> is also supported, however, we recommend against using it, because it is not safe (and not useful) to call certain members like <code>.c_str()</code> if our alphabets are used as value type.</p>
<p>We provide specialised containers with certain properties in the <a class="el" href="group__range.html">Range</a> module.</p>
<p>A container over an <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> automatically models the <a class="el" href="interfacebio_1_1sequence.html" title="The generic concept for a sequence.">bio::sequence</a> concept. </p>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gabd77e4c1f2d28c1af7a223605bbb7c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd77e4c1f2d28c1af7a223605bbb7c82">&#9670;&nbsp;</a></span>alphabet_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename alph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::alphabet_size = detail::adl_only::alphabet_size_obj&lt;alph_t&gt;()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A type trait that holds the size of a (semi-)alphabet. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">your_type</td><td>The (semi-)alphabet type being queried.</td></tr>
  </table>
  </dd>
</dl>
<p>This type trait is implemented as a global variable template.</p>
<p>It is only defined for types that provide one of the following (checked in this order):</p>
<ol type="1">
<li>A <code>static constexpr</code> data member of <code><a class="el" href="structbio_1_1custom_1_1alphabet.html" title="A type that can be specialised to provide customisation point implementations so that third party typ...">bio::custom::alphabet</a>&lt;your_type&gt;</code> called <code>alphabet_size</code>.</li>
<li>A free function <code>alphabet_size(your_type const &amp;)</code> in the namespace of your type (or as <code>friend</code>) that returns the size.</li>
<li>A <code>static constexpr</code> data member of <code>your_type</code> called <code>alphabet_size</code>.</li>
</ol>
<p>Functions are only considered for one of the above cases if they are marked <code>noexcept</code> <b>and</b> <code>constexpr</code> and if the returned type models std::integral. For 2. the value of the argument to the function shall be ignored, the argument is only used to select the function via <a href="https://en.cppreference.com/w/cpp/language/adl">argument-dependent lookup</a>.</p>
<p>Every (semi-)alphabet type must provide one of the above.</p>
<p><em>Note</em> that if the (semi-)alphabet type with cvref removed is not <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a> or not <a class="el" href="structbio_1_1is__constexpr__default__constructible.html" title="Whether a type std::is_default_constructible in constexpr-context.">bio::is_constexpr_default_constructible</a>, this object will instead look for <code>alphabet_size(<a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a>&lt;your_type&gt; const &amp;)</code> with the same semantics (in case 2.).</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/adaptation/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> r2 = bio::alphabet_size&lt;char&gt;;            <span class="comment">// calls bio::custom::alphabet_size(char{}); r2 == 256</span></div>
<div class="line">    <span class="keyword">auto</span> r3 = bio::alphabet_size&lt;bio::dna5&gt;;    <span class="comment">// returns dna5::alphabet_size; r3 == 5</span></div>
<div class="line">}</div>
<div class="ttc" id="aalphabet_2concept_8hpp_html"><div class="ttname"><a href="alphabet_2concept_8hpp.html">concept.hpp</a></div><div class="ttdoc">Core alphabet concept and free function/type trait wrappers.</div></div>
<div class="ttc" id="achar_8hpp_html"><div class="ttname"><a href="char_8hpp.html">char.hpp</a></div><div class="ttdoc">Provides alphabet adaptations for standard char types.</div></div>
<div class="ttc" id="adna5_8hpp_html"><div class="ttname"><a href="dna5_8hpp.html">dna5.hpp</a></div><div class="ttdoc">Provides bio::dna5, container aliases and string literals.</div></div>
</div><!-- fragment --><p>For an example of a full alphabet definition with free function implementations (solution 1. above), see <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>.</p>
<h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). To specify the behaviour for your own alphabet type, simply provide one of the three functions specified above. </p>

</div>
</div>
<a id="gab055c8c702ef4b8b48b7d301c12b18b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab055c8c702ef4b8b48b7d301c12b18b2">&#9670;&nbsp;</a></span>assign_char_strictly_to</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::assign_char_strictly_to = detail::adl_only::assign_char_strictly_to_fn{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a character to an alphabet object, throw if the character is not valid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">your_type</td><td>Type of the target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>The character being assigned; must be of the <a class="el" href="group__alphabet.html#ga474c9ea1cc2c81b65e22ee09c746fc17" title="The char_type of the alphabet; defined as the return type of bio::to_char.">bio::alphabet_char_t</a> of the target object. </td></tr>
    <tr><td class="paramname">alph</td><td>The target object; its type must model <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>alph</code> if <code>alph</code> was given as lvalue, otherwise a copy. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structbio_1_1invalid__char__assignment.html" title="An exception typically thrown by bio::alphabet::assign_char_strict.">bio::invalid_char_assignment</a></td><td>If <code><a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52" title="Returns whether a character is in the valid set of a bio::alphabet (usually implies a bijective mappi...">bio::char_is_valid_for</a>&lt;decltype(alph)&gt;(chr) == false</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a function object. Invoke it with the parameters specified above.</p>
<p>Note that this is not a customisation point and it cannot be "overloaded". It simply invokes <a class="el" href="group__alphabet.html#ga510b0657b8a3ae7d304999afd8fdcd52" title="Returns whether a character is in the valid set of a bio::alphabet (usually implies a bijective mappi...">bio::char_is_valid_for</a> and <a class="el" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d" title="Assign a character to an alphabet object.">bio::assign_char_to</a>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/adaptation/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> c = <span class="charliteral">&#39;!&#39;</span>;</div>
<div class="line">    <a class="code" href="group__alphabet.html#gab055c8c702ef4b8b48b7d301c12b18b2">bio::assign_char_strictly_to</a>(<span class="charliteral">&#39;?&#39;</span>, c);     <span class="comment">// calls bio::custom::assign_char_strictly_to(&#39;A&#39;, c)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classbio_1_1dna5.html">bio::dna5</a> d{};</div>
<div class="line">    <a class="code" href="group__alphabet.html#gab055c8c702ef4b8b48b7d301c12b18b2">bio::assign_char_strictly_to</a>(<span class="charliteral">&#39;A&#39;</span>, d);     <span class="comment">// calls .assign_char(&#39;A&#39;) member</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// also works for temporaries:</span></div>
<div class="line">    <a class="code" href="classbio_1_1dna5.html">bio::dna5</a> d2 = <a class="code" href="group__alphabet.html#gab055c8c702ef4b8b48b7d301c12b18b2">bio::assign_char_strictly_to</a>(<span class="charliteral">&#39;A&#39;</span>, <a class="code" href="classbio_1_1dna5.html">bio::dna5</a>{});</div>
<div class="line">}</div>
<div class="ttc" id="aclassbio_1_1dna5_html"><div class="ttname"><a href="classbio_1_1dna5.html">bio::dna5</a></div><div class="ttdoc">The five letter DNA alphabet of A,C,G,T and the unknown character N.</div><div class="ttdef"><b>Definition:</b> dna5.hpp:50</div></div>
<div class="ttc" id="agroup__alphabet_html_gab055c8c702ef4b8b48b7d301c12b18b2"><div class="ttname"><a href="group__alphabet.html#gab055c8c702ef4b8b48b7d301c12b18b2">bio::assign_char_strictly_to</a></div><div class="ttdeci">constexpr auto assign_char_strictly_to</div><div class="ttdoc">Assign a character to an alphabet object, throw if the character is not valid.</div><div class="ttdef"><b>Definition:</b> concept.hpp:599</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga05da42eb0b9a48f4d1a554c7d3a9044d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05da42eb0b9a48f4d1a554c7d3a9044d">&#9670;&nbsp;</a></span>assign_char_to</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::assign_char_to = detail::adl_only::assign_char_to_fn{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a character to an alphabet object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">your_type</td><td>Type of the target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>The character being assigned; must be of the <a class="el" href="group__alphabet.html#ga474c9ea1cc2c81b65e22ee09c746fc17" title="The char_type of the alphabet; defined as the return type of bio::to_char.">bio::alphabet_char_t</a> of the target object. </td></tr>
    <tr><td class="paramname">alph</td><td>The target object; its type must model <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>alph</code> if <code>alph</code> was given as lvalue, otherwise a copy.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It acts as a wrapper and looks for three possible implementations (in this order):</p>
<ol type="1">
<li>A static member function <code>assign_char_to(char_type const chr, your_type &amp; a)</code> of the class <code><a class="el" href="structbio_1_1custom_1_1alphabet.html" title="A type that can be specialised to provide customisation point implementations so that third party typ...">bio::custom::alphabet</a>&lt;your_type&gt;</code>.</li>
<li>A free function <code>assign_char_to(char_type const chr, your_type &amp; a)</code> in the namespace of your type (or as <code>friend</code>).</li>
<li>A member function called <code>assign_char(char_type const chr)</code> (not <code>assign_char_to</code>).</li>
</ol>
<p>Functions are only considered for one of the above cases if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type is <code>your_type &amp;</code>.</p>
<p>Every alphabet type must provide one of the above. <em>Note</em> that temporaries of <code>your_type</code> are handled by this function object and <b>do not</b> require an additional overload.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/adaptation/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> c = <span class="charliteral">&#39;!&#39;</span>;</div>
<div class="line">    <a class="code" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">bio::assign_char_to</a>(<span class="charliteral">&#39;?&#39;</span>, c);     <span class="comment">// calls bio::custom::assign_char_to(&#39;A&#39;, c)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classbio_1_1dna5.html">bio::dna5</a> d{};</div>
<div class="line">    <a class="code" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">bio::assign_char_to</a>(<span class="charliteral">&#39;A&#39;</span>, d);     <span class="comment">// calls .assign_char(&#39;A&#39;) member</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// also works for temporaries:</span></div>
<div class="line">    <a class="code" href="classbio_1_1dna5.html">bio::dna5</a> d2 = <a class="code" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">bio::assign_char_to</a>(<span class="charliteral">&#39;A&#39;</span>, <a class="code" href="classbio_1_1dna5.html">bio::dna5</a>{});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// invalid/unknown characters are converted:</span></div>
<div class="line">    <a class="code" href="classbio_1_1dna5.html">bio::dna5</a> d3 = <a class="code" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d">bio::assign_char_to</a>(<span class="charliteral">&#39;!&#39;</span>, <a class="code" href="classbio_1_1dna5.html">bio::dna5</a>{}); <span class="comment">// == &#39;N&#39;_dna5</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>For an example of a full alphabet definition with free function implementations (solution 1. above), see <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>.</p>
<h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). To specify the behaviour for your own alphabet type, simply provide one of the three functions specified above. </p>

</div>
</div>
<a id="gae34fa2b37a8b40f2f2fa64fed7bbb410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae34fa2b37a8b40f2f2fa64fed7bbb410">&#9670;&nbsp;</a></span>assign_rank_to</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::assign_rank_to = detail::adl_only::assign_rank_to_fn{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a rank to an alphabet object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">your_type</td><td>Type of the target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>The rank being assigned; must be of the <a class="el" href="group__alphabet.html#ga80d7465944e58981cc10298677b82fec" title="The rank_type of the semi-alphabet; defined as the return type of bio::to_rank.">bio::alphabet_rank_t</a> of the target object. </td></tr>
    <tr><td class="paramname">alph</td><td>The target object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>alph</code> if <code>alph</code> was given as lvalue, otherwise a copy.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It acts as a wrapper and looks for three possible implementations (in this order):</p>
<ol type="1">
<li>A static member function <code>assign_rank_to(rank_type const chr, your_type &amp; a)</code> of the class <code><a class="el" href="structbio_1_1custom_1_1alphabet.html" title="A type that can be specialised to provide customisation point implementations so that third party typ...">bio::custom::alphabet</a>&lt;your_type&gt;</code>.</li>
<li>A free function <code>assign_rank_to(rank_type const chr, your_type &amp; a)</code> in the namespace of your type (or as <code>friend</code>).</li>
<li>A member function called <code>assign_rank(rank_type const chr)</code> (not <code>assign_rank_to</code>).</li>
</ol>
<p>Functions are only considered for one of the above cases if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type is <code>your_type &amp;</code>.</p>
<p>Every (semi-)alphabet type must provide one of the above. <em>Note</em> that temporaries of <code>your_type</code> are handled by this function object and <b>do not</b> require an additional overload.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/adaptation/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> c = <span class="charliteral">&#39;!&#39;</span>;</div>
<div class="line">    <a class="code" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">bio::assign_rank_to</a>(66, c);     <span class="comment">// calls bio::custom::assign_rank_to(66, c); == &#39;B&#39;</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classbio_1_1dna5.html">bio::dna5</a> d{};</div>
<div class="line">    <a class="code" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">bio::assign_rank_to</a>(2, d);     <span class="comment">// calls .assign_rank(2) member; == &#39;G&#39;_dna5</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// also works for temporaries:</span></div>
<div class="line">    <a class="code" href="classbio_1_1dna5.html">bio::dna5</a> d2 = <a class="code" href="group__alphabet.html#gae34fa2b37a8b40f2f2fa64fed7bbb410">bio::assign_rank_to</a>(2, <a class="code" href="classbio_1_1dna5.html">bio::dna5</a>{});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// too-large ranks are undefined behaviour:</span></div>
<div class="line">    <span class="comment">// bio::dna5 d3 = bio::assign_rank_to(50, bio::dna5{});</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>For an example of a full alphabet definition with free function implementations (solution 1. above), see <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>.</p>
<h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). To specify the behaviour for your own alphabet type, simply provide one of the three functions specified above. </p>

</div>
</div>
<a id="ga510b0657b8a3ae7d304999afd8fdcd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga510b0657b8a3ae7d304999afd8fdcd52">&#9670;&nbsp;</a></span>char_is_valid_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename alph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::char_is_valid_for = detail::adl_only::char_is_valid_for_fn&lt;alph_t&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a character is in the valid set of a <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a> (usually implies a bijective mapping to an alphabet value). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">your_type</td><td>The alphabet type being queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>The character being checked; must be convertible to <code><a class="el" href="group__alphabet.html#ga474c9ea1cc2c81b65e22ee09c746fc17" title="The char_type of the alphabet; defined as the return type of bio::to_char.">bio::alphabet_char_t</a>&lt;your_type&gt;</code>. </td></tr>
    <tr><td class="paramname">alph</td><td>The target object; its type must model <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> or <code>false</code>.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It acts as a wrapper and looks for three possible implementations (in this order):</p>
<ol type="1">
<li>A static member function <code>char_is_valid(char_type const chr)</code> of the class <code><a class="el" href="structbio_1_1custom_1_1alphabet.html" title="A type that can be specialised to provide customisation point implementations so that third party typ...">bio::custom::alphabet</a>&lt;your_type&gt;</code>.</li>
<li>A free function <code>char_is_valid_for(char_type const chr, your_type const &amp;)</code> in the namespace of your type (or as <code>friend</code>).</li>
<li>A <code>static</code> member function called <code>char_is_valid(char_type)</code> (not <code>char_is_valid_for</code>).</li>
</ol>
<p>Functions are only considered for one of the above cases if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type is convertible to <code>bool</code>. For 2. the value of the second argument to the function shall be ignored, it is only used to select the function via <a href="https://en.cppreference.com/w/cpp/language/adl">argument-dependent lookup</a>.</p>
<p>An alphabet type <em>may</em> provide one of the above. If none is provided, this function will declare every character <code>c</code> as valid for whom it holds that <code><a class="el" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8" title="Return the char representation of an alphabet object.">bio::to_char</a>(<a class="el" href="group__alphabet.html#ga05da42eb0b9a48f4d1a554c7d3a9044d" title="Assign a character to an alphabet object.">bio::assign_char_to</a>(c, alph_t{})) == c</code>, i.e. converting back and forth results in the same value.</p>
<p><em>Note</em> that if the alphabet type with cvref removed is not <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a>, this function object will instead look for <code>char_is_valid_for(char_type const chr, <a class="elRef" target="_blank" href="https://en.cppreference.com/w/cpp/types/type_identity.html">std::type_identity</a>&lt;your_type&gt; const &amp;)</code> in case 2. In that case the "fallback" above also does not work and you are required to provide such an implementation.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/adaptation/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> b = bio::char_is_valid_for&lt;char&gt;(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line">    <span class="comment">// calls bio::custom::char_is_valid_for&lt;char&gt;(&#39;A&#39;); always true</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> c = bio::char_is_valid_for&lt;bio::dna5&gt;(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line">    <span class="comment">// calls dna5::char_is_valid(&#39;A&#39;) member; == true</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// for some alphabets, characters that are not uniquely mappable are still valid:</span></div>
<div class="line">    <span class="keywordtype">bool</span> d = bio::char_is_valid_for&lt;bio::dna5&gt;(<span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line">    <span class="comment">// lower case also true</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). To specify the behaviour for your own alphabet type, simply provide one of the three functions specified above. </p>

</div>
</div>
<a id="gab295f04aea840000aafc640b5e6528c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab295f04aea840000aafc640b5e6528c8">&#9670;&nbsp;</a></span>to_char</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::to_char = detail::adl_only::to_char_fn{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the char representation of an alphabet object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">your_type</td><td>Type of the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alph</td><td>The alphabet object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The char representation; usually <code>char</code>.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It acts as a wrapper and looks for three possible implementations (in this order):</p>
<ol type="1">
<li>A static member function <code>to_char(your_type const a)</code> of the class <code><a class="el" href="structbio_1_1custom_1_1alphabet.html" title="A type that can be specialised to provide customisation point implementations so that third party typ...">bio::custom::alphabet</a>&lt;your_type&gt;</code>.</li>
</ol>
<ol type="1">
<li>A free function <code>to_char(your_type const a)</code> in the namespace of your type (or as <code>friend</code>).</li>
<li>A member function called <code><a class="el" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8" title="Return the char representation of an alphabet object.">to_char()</a></code>.</li>
</ol>
<p>Functions are only considered for one of the above cases if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type models <a class="el" href="interfacebio_1_1builtin__character.html" title="This concept encompasses exactly the types char, signed char, unsigned char, wchar_t,...">bio::builtin_character</a>.</p>
<p>Every alphabet type must provide one of the above.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/adaptation/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_dna5;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> r2 = <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(<span class="charliteral">&#39;A&#39;</span>);         <span class="comment">// calls bio::custom::to_char(&#39;A&#39;); r2 == &#39;A&#39;</span></div>
<div class="line">    <span class="keyword">auto</span> r3 = <a class="code" href="group__alphabet.html#gab295f04aea840000aafc640b5e6528c8">bio::to_char</a>(<span class="charliteral">&#39;A&#39;</span>_dna5);    <span class="comment">// calls .to_char() member; r3 == &#39;A&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>For an example of a full alphabet definition with free function implementations (solution 1. above), see <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>.</p>
<h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). To specify the behaviour for your own alphabet type, simply provide one of the three functions specified above. </p>

</div>
</div>
<a id="ga9189b35f800d7e5abad51e021ea811a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9189b35f800d7e5abad51e021ea811a0">&#9670;&nbsp;</a></span>to_rank</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bio::to_rank = detail::adl_only::to_rank_fn{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the rank representation of a (semi-)alphabet object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">your_type</td><td>Type of the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alph</td><td>The (semi-)alphabet object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank representation; an integral type.</dd></dl>
<p>This is a function object. Invoke it with the parameter(s) specified above.</p>
<p>It acts as a wrapper and looks for three possible implementations (in this order):</p>
<ol type="1">
<li>A static member function <code>to_rank(your_type const a)</code> of the class <code><a class="el" href="structbio_1_1custom_1_1alphabet.html" title="A type that can be specialised to provide customisation point implementations so that third party typ...">bio::custom::alphabet</a>&lt;your_type&gt;</code>.</li>
<li>A free function <code>to_rank(your_type const a)</code> in the namespace of your type (or as <code>friend</code>).</li>
<li>A member function called <code><a class="el" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0" title="Return the rank representation of a (semi-)alphabet object.">to_rank()</a></code>.</li>
</ol>
<p>Functions are only considered for one of the above cases if they are marked <code>noexcept</code> (<code>constexpr</code> is not required, but recommended) and if the returned type models std::integral.</p>
<p>Every (semi-)alphabet type must provide one of the above.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="alphabet_2concept_8hpp.html">bio/alphabet/concept.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="char_8hpp.html">bio/alphabet/adaptation/char.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna5_8hpp.html">bio/alphabet/nucleotide/dna5.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> bio::operator<span class="stringliteral">&quot;&quot;</span>_dna5;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> r2 = <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a>(<span class="charliteral">&#39;A&#39;</span>);         <span class="comment">// calls bio::custom::to_rank(&#39;A&#39;); r2 == 65</span></div>
<div class="line">    <span class="keyword">auto</span> r3 = <a class="code" href="group__alphabet.html#ga9189b35f800d7e5abad51e021ea811a0">bio::to_rank</a>(<span class="charliteral">&#39;A&#39;</span>_dna5);    <span class="comment">// calls .to_char() member; r3 == 0</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>For an example of a full alphabet definition with free function implementations (solution 1. above), see <a class="el" href="interfacebio_1_1alphabet.html" title="The generic alphabet concept that covers most data types used in ranges.">bio::alphabet</a>.</p>
<h3>Customisation point</h3>
<p>This is a customisation point (see <a class="el" href="biocpp_customisation.html">Customisation</a>). To specify the behaviour for your own alphabet type, simply provide one of the three functions specified above. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <div id="list_bottom_right" style="text-align:right; float:left; color:black; padding: 0px 0px 0px 10px"></div>
    <script type="text/javascript" charset="utf-8" src="version.js"></script>
    <li class="footer">Generated on Sun Jun 12 2022 17:23:28 for BioC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
